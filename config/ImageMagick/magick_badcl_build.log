build options: -cl-single-precision-constant -cl-mad-enable -DCLQuantum=ushort -DCLSignedQuantum=short -DCLPixelType=ushort4 -DQuantumRange=65535.000000 -DQuantumScale=0.000015 -DCharQuantumScale=257.000000 -DMagickEpsilon=0.000000 -DMagickPI=3.141593 -DMaxMap=65535 -DMAGICKCORE_QUANTUM_DEPTH=16
<program source>:23:2254: error: call to '__cl_sqrt' is ambiguous
inline CLQuantum getBlue(CLPixelType p) { return p.x; } inline void setBlue(CLPixelType* p, CLQuantum value) { (*p).x = value; } inline float getBlueF4(float4 p) { return p.x; } inline void setBlueF4(float4* p, float value) { (*p).x = value; } inline CLQuantum getGreen(CLPixelType p) { return p.y; } inline void setGreen(CLPixelType* p, CLQuantum value) { (*p).y = value; } inline float getGreenF4(float4 p) { return p.y; } inline void setGreenF4(float4* p, float value) { (*p).y = value; } inline CLQuantum getRed(CLPixelType p) { return p.z; } inline void setRed(CLPixelType* p, CLQuantum value) { (*p).z = value; } inline float getRedF4(float4 p) { return p.z; } inline void setRedF4(float4* p, float value) { (*p).z = value; } inline CLQuantum getOpacity(CLPixelType p) { return p.w; } inline void setOpacity(CLPixelType* p, CLQuantum value) { (*p).w = value; } inline float getOpacityF4(float4 p) { return p.w; } inline void setOpacityF4(float4* p, float value) { (*p).w = value; } inline void setGray(CLPixelType* p, CLQuantum value) { (*p).z = value; (*p).y = value; (*p).x = value; } inline float GetPixelIntensity(const int method, const int colorspace, CLPixelType p) { float red = getRed(p); float green = getGreen(p); float blue = getBlue(p); float intensity; if (colorspace == GRAYColorspace) return red; switch (method) { case AveragePixelIntensityMethod: { intensity=(red+green+blue)/3.0; break; } case BrightnessPixelIntensityMethod: { intensity=max(max(red,green),blue); break; } case LightnessPixelIntensityMethod: { intensity=(min(min(red,green),blue)+ max(max(red,green),blue))/2.0; break; } case MSPixelIntensityMethod: { intensity=(float) (((float) red*red+green*green+blue*blue)/ (3.0*QuantumRange)); break; } case Rec601LumaPixelIntensityMethod: { intensity=0.298839*red+0.586811*green+0.114350*blue; break; } case Rec601LuminancePixelIntensityMethod: { intensity=0.298839*red+0.586811*green+0.114350*blue; break; } case Rec709LumaPixelIntensityMethod: default: { intensity=0.212656*red+0.715158*green+0.072186*blue; break; } case Rec709LuminancePixelIntensityMethod: { intensity=0.212656*red+0.715158*green+0.072186*blue; break; } case RMSPixelIntensityMethod: { intensity=(float) (sqrt((float) red*red+green*green+blue*blue)/ sqrt(3.0)); break; } } return intensity; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4741:23: note: expanded from macro 'sqrt'
    #define sqrt(__x) __cl_sqrt(__x)
                      ^~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4738:15: note: candidate function
__CLFN_FD_1FD(__cl_sqrt);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:366:48: note: expanded from macro '__CLFN_FD_1FD'
#define __CLFN_FD_1FD(name) float __OVERLOAD__ name(float x); \
                                               ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4738:15: note: candidate function
__CLFN_FD_1FD(__cl_sqrt);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:367:21: note: expanded from macro '__CLFN_FD_1FD'
float2 __OVERLOAD__ name(float2 x); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4738:15: note: candidate function
__CLFN_FD_1FD(__cl_sqrt);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:368:21: note: expanded from macro '__CLFN_FD_1FD'
float3 __OVERLOAD__ name(float3 x); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4738:15: note: candidate function
__CLFN_FD_1FD(__cl_sqrt);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:369:21: note: expanded from macro '__CLFN_FD_1FD'
float4 __OVERLOAD__ name(float4 x); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4738:15: note: candidate function
__CLFN_FD_1FD(__cl_sqrt);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:370:21: note: expanded from macro '__CLFN_FD_1FD'
float8 __OVERLOAD__ name(float8 x); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4738:15: note: candidate function
__CLFN_FD_1FD(__cl_sqrt);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:371:22: note: expanded from macro '__CLFN_FD_1FD'
float16 __OVERLOAD__ name(float16 x);
                     ^
<program source>:24:1507: warning: comparison of integers of different signs: 'int' and 'unsigned int'
__kernel void ConvolveOptimized(const __global CLPixelType *input, __global CLPixelType *output, const unsigned int imageWidth, const unsigned int imageHeight, __constant float *filter, const unsigned int filterWidth, const unsigned int filterHeight, const uint matte, const ChannelType channel, __local CLPixelType *pixelLocalCache, __local float* filterCache) { int2 blockID; blockID.x = get_group_id(0); blockID.y = get_group_id(1); int2 imageAreaOrg; imageAreaOrg.x = blockID.x * get_local_size(0); imageAreaOrg.y = blockID.y * get_local_size(1); int2 midFilterDimen; midFilterDimen.x = (filterWidth-1)/2; midFilterDimen.y = (filterHeight-1)/2; int2 cachedAreaOrg = imageAreaOrg - midFilterDimen; int2 cachedAreaDimen; cachedAreaDimen.x = get_local_size(0) + filterWidth - 1; cachedAreaDimen.y = get_local_size(1) + filterHeight - 1; int localID = get_local_id(1)*get_local_size(0)+get_local_id(0); int cachedAreaNumPixels = cachedAreaDimen.x * cachedAreaDimen.y; int groupSize = get_local_size(0) * get_local_size(1); for (int i = localID; i < cachedAreaNumPixels; i+=groupSize) { int2 cachedAreaIndex; cachedAreaIndex.x = i % cachedAreaDimen.x; cachedAreaIndex.y = i / cachedAreaDimen.x; int2 imagePixelIndex; imagePixelIndex = cachedAreaOrg + cachedAreaIndex; imagePixelIndex.x = ClampToCanvas(imagePixelIndex.x, imageWidth); imagePixelIndex.y = ClampToCanvas(imagePixelIndex.y, imageHeight); pixelLocalCache[i] = input[imagePixelIndex.y * imageWidth + imagePixelIndex.x]; } for (int i = localID; i < filterHeight*filterWidth; i+=groupSize) { filterCache[i] = filter[i]; } barrier(CLK_LOCAL_MEM_FENCE); int2 imageIndex; imageIndex.x = imageAreaOrg.x + get_local_id(0); imageIndex.y = imageAreaOrg.y + get_local_id(1); if (imageIndex.x >= imageWidth || imageIndex.y >= imageHeight) { return; } int filterIndex = 0; float4 sum = (float4)0.0f; float gamma = 0.0f; if (((channel & OpacityChannel) == 0) || (matte == 0)) { int cacheIndexY = get_local_id(1); for (int j = 0; j < filterHeight; j++) { int cacheIndexX = get_local_id(0); for (int i = 0; i < filterWidth; i++) { CLPixelType p = pixelLocalCache[cacheIndexY*cachedAreaDimen.x + cacheIndexX]; float f = filterCache[filterIndex]; sum.x += f * p.x; sum.y += f * p.y; sum.z += f * p.z; sum.w += f * p.w; gamma += f; filterIndex++; cacheIndexX++; } cacheIndexY++; } } else { int cacheIndexY = get_local_id(1); for (int j = 0; j < filterHeight; j++) { int cacheIndexX = get_local_id(0); for (int i = 0; i < filterWidth; i++) { CLPixelType p = pixelLocalCache[cacheIndexY*cachedAreaDimen.x + cacheIndexX]; float alpha = QuantumScale*(QuantumRange-p.w); float f = filterCache[filterIndex]; float g = alpha * f; sum.x += g*p.x; sum.y += g*p.y; sum.z += g*p.z; sum.w += f*p.w; gamma += g; filterIndex++; cacheIndexX++; } cacheIndexY++; } gamma = PerceptibleReciprocal(gamma); sum.xyz = gamma*sum.xyz; } CLPixelType outputPixel; outputPixel.x = ClampToQuantum(sum.x); outputPixel.y = ClampToQuantum(sum.y); outputPixel.z = ClampToQuantum(sum.z); outputPixel.w = ((channel & OpacityChannel)!=0)?ClampToQuantum(sum.w):input[imageIndex.y * imageWidth + imageIndex.x].w; output[imageIndex.y * imageWidth + imageIndex.x] = outputPixel; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~
<program source>:24:1743: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void ConvolveOptimized(const __global CLPixelType *input, __global CLPixelType *output, const unsigned int imageWidth, const unsigned int imageHeight, __constant float *filter, const unsigned int filterWidth, const unsigned int filterHeight, const uint matte, const ChannelType channel, __local CLPixelType *pixelLocalCache, __local float* filterCache) { int2 blockID; blockID.x = get_group_id(0); blockID.y = get_group_id(1); int2 imageAreaOrg; imageAreaOrg.x = blockID.x * get_local_size(0); imageAreaOrg.y = blockID.y * get_local_size(1); int2 midFilterDimen; midFilterDimen.x = (filterWidth-1)/2; midFilterDimen.y = (filterHeight-1)/2; int2 cachedAreaOrg = imageAreaOrg - midFilterDimen; int2 cachedAreaDimen; cachedAreaDimen.x = get_local_size(0) + filterWidth - 1; cachedAreaDimen.y = get_local_size(1) + filterHeight - 1; int localID = get_local_id(1)*get_local_size(0)+get_local_id(0); int cachedAreaNumPixels = cachedAreaDimen.x * cachedAreaDimen.y; int groupSize = get_local_size(0) * get_local_size(1); for (int i = localID; i < cachedAreaNumPixels; i+=groupSize) { int2 cachedAreaIndex; cachedAreaIndex.x = i % cachedAreaDimen.x; cachedAreaIndex.y = i / cachedAreaDimen.x; int2 imagePixelIndex; imagePixelIndex = cachedAreaOrg + cachedAreaIndex; imagePixelIndex.x = ClampToCanvas(imagePixelIndex.x, imageWidth); imagePixelIndex.y = ClampToCanvas(imagePixelIndex.y, imageHeight); pixelLocalCache[i] = input[imagePixelIndex.y * imageWidth + imagePixelIndex.x]; } for (int i = localID; i < filterHeight*filterWidth; i+=groupSize) { filterCache[i] = filter[i]; } barrier(CLK_LOCAL_MEM_FENCE); int2 imageIndex; imageIndex.x = imageAreaOrg.x + get_local_id(0); imageIndex.y = imageAreaOrg.y + get_local_id(1); if (imageIndex.x >= imageWidth || imageIndex.y >= imageHeight) { return; } int filterIndex = 0; float4 sum = (float4)0.0f; float gamma = 0.0f; if (((channel & OpacityChannel) == 0) || (matte == 0)) { int cacheIndexY = get_local_id(1); for (int j = 0; j < filterHeight; j++) { int cacheIndexX = get_local_id(0); for (int i = 0; i < filterWidth; i++) { CLPixelType p = pixelLocalCache[cacheIndexY*cachedAreaDimen.x + cacheIndexX]; float f = filterCache[filterIndex]; sum.x += f * p.x; sum.y += f * p.y; sum.z += f * p.z; sum.w += f * p.w; gamma += f; filterIndex++; cacheIndexX++; } cacheIndexY++; } } else { int cacheIndexY = get_local_id(1); for (int j = 0; j < filterHeight; j++) { int cacheIndexX = get_local_id(0); for (int i = 0; i < filterWidth; i++) { CLPixelType p = pixelLocalCache[cacheIndexY*cachedAreaDimen.x + cacheIndexX]; float alpha = QuantumScale*(QuantumRange-p.w); float f = filterCache[filterIndex]; float g = alpha * f; sum.x += g*p.x; sum.y += g*p.y; sum.z += g*p.z; sum.w += f*p.w; gamma += g; filterIndex++; cacheIndexX++; } cacheIndexY++; } gamma = PerceptibleReciprocal(gamma); sum.xyz = gamma*sum.xyz; } CLPixelType outputPixel; outputPixel.x = ClampToQuantum(sum.x); outputPixel.y = ClampToQuantum(sum.y); outputPixel.z = ClampToQuantum(sum.z); outputPixel.w = ((channel & OpacityChannel)!=0)?ClampToQuantum(sum.w):input[imageIndex.y * imageWidth + imageIndex.x].w; output[imageIndex.y * imageWidth + imageIndex.x] = outputPixel; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ~~~~~~~~~~~~ ^  ~~~~~~~~~~
<program source>:24:1773: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void ConvolveOptimized(const __global CLPixelType *input, __global CLPixelType *output, const unsigned int imageWidth, const unsigned int imageHeight, __constant float *filter, const unsigned int filterWidth, const unsigned int filterHeight, const uint matte, const ChannelType channel, __local CLPixelType *pixelLocalCache, __local float* filterCache) { int2 blockID; blockID.x = get_group_id(0); blockID.y = get_group_id(1); int2 imageAreaOrg; imageAreaOrg.x = blockID.x * get_local_size(0); imageAreaOrg.y = blockID.y * get_local_size(1); int2 midFilterDimen; midFilterDimen.x = (filterWidth-1)/2; midFilterDimen.y = (filterHeight-1)/2; int2 cachedAreaOrg = imageAreaOrg - midFilterDimen; int2 cachedAreaDimen; cachedAreaDimen.x = get_local_size(0) + filterWidth - 1; cachedAreaDimen.y = get_local_size(1) + filterHeight - 1; int localID = get_local_id(1)*get_local_size(0)+get_local_id(0); int cachedAreaNumPixels = cachedAreaDimen.x * cachedAreaDimen.y; int groupSize = get_local_size(0) * get_local_size(1); for (int i = localID; i < cachedAreaNumPixels; i+=groupSize) { int2 cachedAreaIndex; cachedAreaIndex.x = i % cachedAreaDimen.x; cachedAreaIndex.y = i / cachedAreaDimen.x; int2 imagePixelIndex; imagePixelIndex = cachedAreaOrg + cachedAreaIndex; imagePixelIndex.x = ClampToCanvas(imagePixelIndex.x, imageWidth); imagePixelIndex.y = ClampToCanvas(imagePixelIndex.y, imageHeight); pixelLocalCache[i] = input[imagePixelIndex.y * imageWidth + imagePixelIndex.x]; } for (int i = localID; i < filterHeight*filterWidth; i+=groupSize) { filterCache[i] = filter[i]; } barrier(CLK_LOCAL_MEM_FENCE); int2 imageIndex; imageIndex.x = imageAreaOrg.x + get_local_id(0); imageIndex.y = imageAreaOrg.y + get_local_id(1); if (imageIndex.x >= imageWidth || imageIndex.y >= imageHeight) { return; } int filterIndex = 0; float4 sum = (float4)0.0f; float gamma = 0.0f; if (((channel & OpacityChannel) == 0) || (matte == 0)) { int cacheIndexY = get_local_id(1); for (int j = 0; j < filterHeight; j++) { int cacheIndexX = get_local_id(0); for (int i = 0; i < filterWidth; i++) { CLPixelType p = pixelLocalCache[cacheIndexY*cachedAreaDimen.x + cacheIndexX]; float f = filterCache[filterIndex]; sum.x += f * p.x; sum.y += f * p.y; sum.z += f * p.z; sum.w += f * p.w; gamma += f; filterIndex++; cacheIndexX++; } cacheIndexY++; } } else { int cacheIndexY = get_local_id(1); for (int j = 0; j < filterHeight; j++) { int cacheIndexX = get_local_id(0); for (int i = 0; i < filterWidth; i++) { CLPixelType p = pixelLocalCache[cacheIndexY*cachedAreaDimen.x + cacheIndexX]; float alpha = QuantumScale*(QuantumRange-p.w); float f = filterCache[filterIndex]; float g = alpha * f; sum.x += g*p.x; sum.y += g*p.y; sum.z += g*p.z; sum.w += f*p.w; gamma += g; filterIndex++; cacheIndexX++; } cacheIndexY++; } gamma = PerceptibleReciprocal(gamma); sum.xyz = gamma*sum.xyz; } CLPixelType outputPixel; outputPixel.x = ClampToQuantum(sum.x); outputPixel.y = ClampToQuantum(sum.y); outputPixel.z = ClampToQuantum(sum.z); outputPixel.w = ((channel & OpacityChannel)!=0)?ClampToQuantum(sum.w):input[imageIndex.y * imageWidth + imageIndex.x].w; output[imageIndex.y * imageWidth + imageIndex.x] = outputPixel; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ~~~~~~~~~~~~ ^  ~~~~~~~~~~~
<program source>:24:1979: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void ConvolveOptimized(const __global CLPixelType *input, __global CLPixelType *output, const unsigned int imageWidth, const unsigned int imageHeight, __constant float *filter, const unsigned int filterWidth, const unsigned int filterHeight, const uint matte, const ChannelType channel, __local CLPixelType *pixelLocalCache, __local float* filterCache) { int2 blockID; blockID.x = get_group_id(0); blockID.y = get_group_id(1); int2 imageAreaOrg; imageAreaOrg.x = blockID.x * get_local_size(0); imageAreaOrg.y = blockID.y * get_local_size(1); int2 midFilterDimen; midFilterDimen.x = (filterWidth-1)/2; midFilterDimen.y = (filterHeight-1)/2; int2 cachedAreaOrg = imageAreaOrg - midFilterDimen; int2 cachedAreaDimen; cachedAreaDimen.x = get_local_size(0) + filterWidth - 1; cachedAreaDimen.y = get_local_size(1) + filterHeight - 1; int localID = get_local_id(1)*get_local_size(0)+get_local_id(0); int cachedAreaNumPixels = cachedAreaDimen.x * cachedAreaDimen.y; int groupSize = get_local_size(0) * get_local_size(1); for (int i = localID; i < cachedAreaNumPixels; i+=groupSize) { int2 cachedAreaIndex; cachedAreaIndex.x = i % cachedAreaDimen.x; cachedAreaIndex.y = i / cachedAreaDimen.x; int2 imagePixelIndex; imagePixelIndex = cachedAreaOrg + cachedAreaIndex; imagePixelIndex.x = ClampToCanvas(imagePixelIndex.x, imageWidth); imagePixelIndex.y = ClampToCanvas(imagePixelIndex.y, imageHeight); pixelLocalCache[i] = input[imagePixelIndex.y * imageWidth + imagePixelIndex.x]; } for (int i = localID; i < filterHeight*filterWidth; i+=groupSize) { filterCache[i] = filter[i]; } barrier(CLK_LOCAL_MEM_FENCE); int2 imageIndex; imageIndex.x = imageAreaOrg.x + get_local_id(0); imageIndex.y = imageAreaOrg.y + get_local_id(1); if (imageIndex.x >= imageWidth || imageIndex.y >= imageHeight) { return; } int filterIndex = 0; float4 sum = (float4)0.0f; float gamma = 0.0f; if (((channel & OpacityChannel) == 0) || (matte == 0)) { int cacheIndexY = get_local_id(1); for (int j = 0; j < filterHeight; j++) { int cacheIndexX = get_local_id(0); for (int i = 0; i < filterWidth; i++) { CLPixelType p = pixelLocalCache[cacheIndexY*cachedAreaDimen.x + cacheIndexX]; float f = filterCache[filterIndex]; sum.x += f * p.x; sum.y += f * p.y; sum.z += f * p.z; sum.w += f * p.w; gamma += f; filterIndex++; cacheIndexX++; } cacheIndexY++; } } else { int cacheIndexY = get_local_id(1); for (int j = 0; j < filterHeight; j++) { int cacheIndexX = get_local_id(0); for (int i = 0; i < filterWidth; i++) { CLPixelType p = pixelLocalCache[cacheIndexY*cachedAreaDimen.x + cacheIndexX]; float alpha = QuantumScale*(QuantumRange-p.w); float f = filterCache[filterIndex]; float g = alpha * f; sum.x += g*p.x; sum.y += g*p.y; sum.z += g*p.z; sum.w += f*p.w; gamma += g; filterIndex++; cacheIndexX++; } cacheIndexY++; } gamma = PerceptibleReciprocal(gamma); sum.xyz = gamma*sum.xyz; } CLPixelType outputPixel; outputPixel.x = ClampToQuantum(sum.x); outputPixel.y = ClampToQuantum(sum.y); outputPixel.z = ClampToQuantum(sum.z); outputPixel.w = ((channel & OpacityChannel)!=0)?ClampToQuantum(sum.w):input[imageIndex.y * imageWidth + imageIndex.x].w; output[imageIndex.y * imageWidth + imageIndex.x] = outputPixel; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ~ ^ ~~~~~~~~~~~~
<program source>:24:2055: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void ConvolveOptimized(const __global CLPixelType *input, __global CLPixelType *output, const unsigned int imageWidth, const unsigned int imageHeight, __constant float *filter, const unsigned int filterWidth, const unsigned int filterHeight, const uint matte, const ChannelType channel, __local CLPixelType *pixelLocalCache, __local float* filterCache) { int2 blockID; blockID.x = get_group_id(0); blockID.y = get_group_id(1); int2 imageAreaOrg; imageAreaOrg.x = blockID.x * get_local_size(0); imageAreaOrg.y = blockID.y * get_local_size(1); int2 midFilterDimen; midFilterDimen.x = (filterWidth-1)/2; midFilterDimen.y = (filterHeight-1)/2; int2 cachedAreaOrg = imageAreaOrg - midFilterDimen; int2 cachedAreaDimen; cachedAreaDimen.x = get_local_size(0) + filterWidth - 1; cachedAreaDimen.y = get_local_size(1) + filterHeight - 1; int localID = get_local_id(1)*get_local_size(0)+get_local_id(0); int cachedAreaNumPixels = cachedAreaDimen.x * cachedAreaDimen.y; int groupSize = get_local_size(0) * get_local_size(1); for (int i = localID; i < cachedAreaNumPixels; i+=groupSize) { int2 cachedAreaIndex; cachedAreaIndex.x = i % cachedAreaDimen.x; cachedAreaIndex.y = i / cachedAreaDimen.x; int2 imagePixelIndex; imagePixelIndex = cachedAreaOrg + cachedAreaIndex; imagePixelIndex.x = ClampToCanvas(imagePixelIndex.x, imageWidth); imagePixelIndex.y = ClampToCanvas(imagePixelIndex.y, imageHeight); pixelLocalCache[i] = input[imagePixelIndex.y * imageWidth + imagePixelIndex.x]; } for (int i = localID; i < filterHeight*filterWidth; i+=groupSize) { filterCache[i] = filter[i]; } barrier(CLK_LOCAL_MEM_FENCE); int2 imageIndex; imageIndex.x = imageAreaOrg.x + get_local_id(0); imageIndex.y = imageAreaOrg.y + get_local_id(1); if (imageIndex.x >= imageWidth || imageIndex.y >= imageHeight) { return; } int filterIndex = 0; float4 sum = (float4)0.0f; float gamma = 0.0f; if (((channel & OpacityChannel) == 0) || (matte == 0)) { int cacheIndexY = get_local_id(1); for (int j = 0; j < filterHeight; j++) { int cacheIndexX = get_local_id(0); for (int i = 0; i < filterWidth; i++) { CLPixelType p = pixelLocalCache[cacheIndexY*cachedAreaDimen.x + cacheIndexX]; float f = filterCache[filterIndex]; sum.x += f * p.x; sum.y += f * p.y; sum.z += f * p.z; sum.w += f * p.w; gamma += f; filterIndex++; cacheIndexX++; } cacheIndexY++; } } else { int cacheIndexY = get_local_id(1); for (int j = 0; j < filterHeight; j++) { int cacheIndexX = get_local_id(0); for (int i = 0; i < filterWidth; i++) { CLPixelType p = pixelLocalCache[cacheIndexY*cachedAreaDimen.x + cacheIndexX]; float alpha = QuantumScale*(QuantumRange-p.w); float f = filterCache[filterIndex]; float g = alpha * f; sum.x += g*p.x; sum.y += g*p.y; sum.z += g*p.z; sum.w += f*p.w; gamma += g; filterIndex++; cacheIndexX++; } cacheIndexY++; } gamma = PerceptibleReciprocal(gamma); sum.xyz = gamma*sum.xyz; } CLPixelType outputPixel; outputPixel.x = ClampToQuantum(sum.x); outputPixel.y = ClampToQuantum(sum.y); outputPixel.z = ClampToQuantum(sum.z); outputPixel.w = ((channel & OpacityChannel)!=0)?ClampToQuantum(sum.w):input[imageIndex.y * imageWidth + imageIndex.x].w; output[imageIndex.y * imageWidth + imageIndex.x] = outputPixel; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ~ ^ ~~~~~~~~~~~
<program source>:24:2386: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void ConvolveOptimized(const __global CLPixelType *input, __global CLPixelType *output, const unsigned int imageWidth, const unsigned int imageHeight, __constant float *filter, const unsigned int filterWidth, const unsigned int filterHeight, const uint matte, const ChannelType channel, __local CLPixelType *pixelLocalCache, __local float* filterCache) { int2 blockID; blockID.x = get_group_id(0); blockID.y = get_group_id(1); int2 imageAreaOrg; imageAreaOrg.x = blockID.x * get_local_size(0); imageAreaOrg.y = blockID.y * get_local_size(1); int2 midFilterDimen; midFilterDimen.x = (filterWidth-1)/2; midFilterDimen.y = (filterHeight-1)/2; int2 cachedAreaOrg = imageAreaOrg - midFilterDimen; int2 cachedAreaDimen; cachedAreaDimen.x = get_local_size(0) + filterWidth - 1; cachedAreaDimen.y = get_local_size(1) + filterHeight - 1; int localID = get_local_id(1)*get_local_size(0)+get_local_id(0); int cachedAreaNumPixels = cachedAreaDimen.x * cachedAreaDimen.y; int groupSize = get_local_size(0) * get_local_size(1); for (int i = localID; i < cachedAreaNumPixels; i+=groupSize) { int2 cachedAreaIndex; cachedAreaIndex.x = i % cachedAreaDimen.x; cachedAreaIndex.y = i / cachedAreaDimen.x; int2 imagePixelIndex; imagePixelIndex = cachedAreaOrg + cachedAreaIndex; imagePixelIndex.x = ClampToCanvas(imagePixelIndex.x, imageWidth); imagePixelIndex.y = ClampToCanvas(imagePixelIndex.y, imageHeight); pixelLocalCache[i] = input[imagePixelIndex.y * imageWidth + imagePixelIndex.x]; } for (int i = localID; i < filterHeight*filterWidth; i+=groupSize) { filterCache[i] = filter[i]; } barrier(CLK_LOCAL_MEM_FENCE); int2 imageIndex; imageIndex.x = imageAreaOrg.x + get_local_id(0); imageIndex.y = imageAreaOrg.y + get_local_id(1); if (imageIndex.x >= imageWidth || imageIndex.y >= imageHeight) { return; } int filterIndex = 0; float4 sum = (float4)0.0f; float gamma = 0.0f; if (((channel & OpacityChannel) == 0) || (matte == 0)) { int cacheIndexY = get_local_id(1); for (int j = 0; j < filterHeight; j++) { int cacheIndexX = get_local_id(0); for (int i = 0; i < filterWidth; i++) { CLPixelType p = pixelLocalCache[cacheIndexY*cachedAreaDimen.x + cacheIndexX]; float f = filterCache[filterIndex]; sum.x += f * p.x; sum.y += f * p.y; sum.z += f * p.z; sum.w += f * p.w; gamma += f; filterIndex++; cacheIndexX++; } cacheIndexY++; } } else { int cacheIndexY = get_local_id(1); for (int j = 0; j < filterHeight; j++) { int cacheIndexX = get_local_id(0); for (int i = 0; i < filterWidth; i++) { CLPixelType p = pixelLocalCache[cacheIndexY*cachedAreaDimen.x + cacheIndexX]; float alpha = QuantumScale*(QuantumRange-p.w); float f = filterCache[filterIndex]; float g = alpha * f; sum.x += g*p.x; sum.y += g*p.y; sum.z += g*p.z; sum.w += f*p.w; gamma += g; filterIndex++; cacheIndexX++; } cacheIndexY++; } gamma = PerceptibleReciprocal(gamma); sum.xyz = gamma*sum.xyz; } CLPixelType outputPixel; outputPixel.x = ClampToQuantum(sum.x); outputPixel.y = ClampToQuantum(sum.y); outputPixel.z = ClampToQuantum(sum.z); outputPixel.w = ((channel & OpacityChannel)!=0)?ClampToQuantum(sum.w):input[imageIndex.y * imageWidth + imageIndex.x].w; output[imageIndex.y * imageWidth + imageIndex.x] = outputPixel; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ~ ^ ~~~~~~~~~~~~
<program source>:24:2462: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void ConvolveOptimized(const __global CLPixelType *input, __global CLPixelType *output, const unsigned int imageWidth, const unsigned int imageHeight, __constant float *filter, const unsigned int filterWidth, const unsigned int filterHeight, const uint matte, const ChannelType channel, __local CLPixelType *pixelLocalCache, __local float* filterCache) { int2 blockID; blockID.x = get_group_id(0); blockID.y = get_group_id(1); int2 imageAreaOrg; imageAreaOrg.x = blockID.x * get_local_size(0); imageAreaOrg.y = blockID.y * get_local_size(1); int2 midFilterDimen; midFilterDimen.x = (filterWidth-1)/2; midFilterDimen.y = (filterHeight-1)/2; int2 cachedAreaOrg = imageAreaOrg - midFilterDimen; int2 cachedAreaDimen; cachedAreaDimen.x = get_local_size(0) + filterWidth - 1; cachedAreaDimen.y = get_local_size(1) + filterHeight - 1; int localID = get_local_id(1)*get_local_size(0)+get_local_id(0); int cachedAreaNumPixels = cachedAreaDimen.x * cachedAreaDimen.y; int groupSize = get_local_size(0) * get_local_size(1); for (int i = localID; i < cachedAreaNumPixels; i+=groupSize) { int2 cachedAreaIndex; cachedAreaIndex.x = i % cachedAreaDimen.x; cachedAreaIndex.y = i / cachedAreaDimen.x; int2 imagePixelIndex; imagePixelIndex = cachedAreaOrg + cachedAreaIndex; imagePixelIndex.x = ClampToCanvas(imagePixelIndex.x, imageWidth); imagePixelIndex.y = ClampToCanvas(imagePixelIndex.y, imageHeight); pixelLocalCache[i] = input[imagePixelIndex.y * imageWidth + imagePixelIndex.x]; } for (int i = localID; i < filterHeight*filterWidth; i+=groupSize) { filterCache[i] = filter[i]; } barrier(CLK_LOCAL_MEM_FENCE); int2 imageIndex; imageIndex.x = imageAreaOrg.x + get_local_id(0); imageIndex.y = imageAreaOrg.y + get_local_id(1); if (imageIndex.x >= imageWidth || imageIndex.y >= imageHeight) { return; } int filterIndex = 0; float4 sum = (float4)0.0f; float gamma = 0.0f; if (((channel & OpacityChannel) == 0) || (matte == 0)) { int cacheIndexY = get_local_id(1); for (int j = 0; j < filterHeight; j++) { int cacheIndexX = get_local_id(0); for (int i = 0; i < filterWidth; i++) { CLPixelType p = pixelLocalCache[cacheIndexY*cachedAreaDimen.x + cacheIndexX]; float f = filterCache[filterIndex]; sum.x += f * p.x; sum.y += f * p.y; sum.z += f * p.z; sum.w += f * p.w; gamma += f; filterIndex++; cacheIndexX++; } cacheIndexY++; } } else { int cacheIndexY = get_local_id(1); for (int j = 0; j < filterHeight; j++) { int cacheIndexX = get_local_id(0); for (int i = 0; i < filterWidth; i++) { CLPixelType p = pixelLocalCache[cacheIndexY*cachedAreaDimen.x + cacheIndexX]; float alpha = QuantumScale*(QuantumRange-p.w); float f = filterCache[filterIndex]; float g = alpha * f; sum.x += g*p.x; sum.y += g*p.y; sum.z += g*p.z; sum.w += f*p.w; gamma += g; filterIndex++; cacheIndexX++; } cacheIndexY++; } gamma = PerceptibleReciprocal(gamma); sum.xyz = gamma*sum.xyz; } CLPixelType outputPixel; outputPixel.x = ClampToQuantum(sum.x); outputPixel.y = ClampToQuantum(sum.y); outputPixel.z = ClampToQuantum(sum.z); outputPixel.w = ((channel & OpacityChannel)!=0)?ClampToQuantum(sum.w):input[imageIndex.y * imageWidth + imageIndex.x].w; output[imageIndex.y * imageWidth + imageIndex.x] = outputPixel; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ~ ^ ~~~~~~~~~~~
<program source>:25:374: warning: comparison of integers of different signs: 'int' and 'const uint' (aka 'const unsigned int')
__kernel void Convolve(const __global CLPixelType *input, __global CLPixelType *output, const uint imageWidth, const uint imageHeight, __constant float *filter, const unsigned int filterWidth, const unsigned int filterHeight, const uint matte, const ChannelType channel) { int2 imageIndex; imageIndex.x = get_global_id(0); imageIndex.y = get_global_id(1); if (imageIndex.x >= imageWidth || imageIndex.y >= imageHeight) return; int2 midFilterDimen; midFilterDimen.x = (filterWidth-1)/2; midFilterDimen.y = (filterHeight-1)/2; int filterIndex = 0; float4 sum = (float4)0.0f; float gamma = 0.0f; if (((channel & OpacityChannel) == 0) || (matte == 0)) { for (int j = 0; j < filterHeight; j++) { int2 inputPixelIndex; inputPixelIndex.y = imageIndex.y - midFilterDimen.y + j; inputPixelIndex.y = ClampToCanvas(inputPixelIndex.y, imageHeight); for (int i = 0; i < filterWidth; i++) { inputPixelIndex.x = imageIndex.x - midFilterDimen.x + i; inputPixelIndex.x = ClampToCanvas(inputPixelIndex.x, imageWidth); CLPixelType p = input[inputPixelIndex.y * imageWidth + inputPixelIndex.x]; float f = filter[filterIndex]; sum.x += f * p.x; sum.y += f * p.y; sum.z += f * p.z; sum.w += f * p.w; gamma += f; filterIndex++; } } } else { for (int j = 0; j < filterHeight; j++) { int2 inputPixelIndex; inputPixelIndex.y = imageIndex.y - midFilterDimen.y + j; inputPixelIndex.y = ClampToCanvas(inputPixelIndex.y, imageHeight); for (int i = 0; i < filterWidth; i++) { inputPixelIndex.x = imageIndex.x - midFilterDimen.x + i; inputPixelIndex.x = ClampToCanvas(inputPixelIndex.x, imageWidth); CLPixelType p = input[inputPixelIndex.y * imageWidth + inputPixelIndex.x]; float alpha = QuantumScale*(QuantumRange-p.w); float f = filter[filterIndex]; float g = alpha * f; sum.x += g*p.x; sum.y += g*p.y; sum.z += g*p.z; sum.w += f*p.w; gamma += g; filterIndex++; } } gamma = PerceptibleReciprocal(gamma); sum.xyz = gamma*sum.xyz; } CLPixelType outputPixel; outputPixel.x = ClampToQuantum(sum.x); outputPixel.y = ClampToQuantum(sum.y); outputPixel.z = ClampToQuantum(sum.z); outputPixel.w = ((channel & OpacityChannel)!=0)?ClampToQuantum(sum.w):input[imageIndex.y * imageWidth + imageIndex.x].w; output[imageIndex.y * imageWidth + imageIndex.x] = outputPixel; }
                                                                                                                                                                                                                                                                                                                                                                        ~~~~~~~~~~~~ ^  ~~~~~~~~~~
<program source>:25:404: warning: comparison of integers of different signs: 'int' and 'const uint' (aka 'const unsigned int')
__kernel void Convolve(const __global CLPixelType *input, __global CLPixelType *output, const uint imageWidth, const uint imageHeight, __constant float *filter, const unsigned int filterWidth, const unsigned int filterHeight, const uint matte, const ChannelType channel) { int2 imageIndex; imageIndex.x = get_global_id(0); imageIndex.y = get_global_id(1); if (imageIndex.x >= imageWidth || imageIndex.y >= imageHeight) return; int2 midFilterDimen; midFilterDimen.x = (filterWidth-1)/2; midFilterDimen.y = (filterHeight-1)/2; int filterIndex = 0; float4 sum = (float4)0.0f; float gamma = 0.0f; if (((channel & OpacityChannel) == 0) || (matte == 0)) { for (int j = 0; j < filterHeight; j++) { int2 inputPixelIndex; inputPixelIndex.y = imageIndex.y - midFilterDimen.y + j; inputPixelIndex.y = ClampToCanvas(inputPixelIndex.y, imageHeight); for (int i = 0; i < filterWidth; i++) { inputPixelIndex.x = imageIndex.x - midFilterDimen.x + i; inputPixelIndex.x = ClampToCanvas(inputPixelIndex.x, imageWidth); CLPixelType p = input[inputPixelIndex.y * imageWidth + inputPixelIndex.x]; float f = filter[filterIndex]; sum.x += f * p.x; sum.y += f * p.y; sum.z += f * p.z; sum.w += f * p.w; gamma += f; filterIndex++; } } } else { for (int j = 0; j < filterHeight; j++) { int2 inputPixelIndex; inputPixelIndex.y = imageIndex.y - midFilterDimen.y + j; inputPixelIndex.y = ClampToCanvas(inputPixelIndex.y, imageHeight); for (int i = 0; i < filterWidth; i++) { inputPixelIndex.x = imageIndex.x - midFilterDimen.x + i; inputPixelIndex.x = ClampToCanvas(inputPixelIndex.x, imageWidth); CLPixelType p = input[inputPixelIndex.y * imageWidth + inputPixelIndex.x]; float alpha = QuantumScale*(QuantumRange-p.w); float f = filter[filterIndex]; float g = alpha * f; sum.x += g*p.x; sum.y += g*p.y; sum.z += g*p.z; sum.w += f*p.w; gamma += g; filterIndex++; } } gamma = PerceptibleReciprocal(gamma); sum.xyz = gamma*sum.xyz; } CLPixelType outputPixel; outputPixel.x = ClampToQuantum(sum.x); outputPixel.y = ClampToQuantum(sum.y); outputPixel.z = ClampToQuantum(sum.z); outputPixel.w = ((channel & OpacityChannel)!=0)?ClampToQuantum(sum.w):input[imageIndex.y * imageWidth + imageIndex.x].w; output[imageIndex.y * imageWidth + imageIndex.x] = outputPixel; }
                                                                                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~ ^  ~~~~~~~~~~~
<program source>:25:669: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void Convolve(const __global CLPixelType *input, __global CLPixelType *output, const uint imageWidth, const uint imageHeight, __constant float *filter, const unsigned int filterWidth, const unsigned int filterHeight, const uint matte, const ChannelType channel) { int2 imageIndex; imageIndex.x = get_global_id(0); imageIndex.y = get_global_id(1); if (imageIndex.x >= imageWidth || imageIndex.y >= imageHeight) return; int2 midFilterDimen; midFilterDimen.x = (filterWidth-1)/2; midFilterDimen.y = (filterHeight-1)/2; int filterIndex = 0; float4 sum = (float4)0.0f; float gamma = 0.0f; if (((channel & OpacityChannel) == 0) || (matte == 0)) { for (int j = 0; j < filterHeight; j++) { int2 inputPixelIndex; inputPixelIndex.y = imageIndex.y - midFilterDimen.y + j; inputPixelIndex.y = ClampToCanvas(inputPixelIndex.y, imageHeight); for (int i = 0; i < filterWidth; i++) { inputPixelIndex.x = imageIndex.x - midFilterDimen.x + i; inputPixelIndex.x = ClampToCanvas(inputPixelIndex.x, imageWidth); CLPixelType p = input[inputPixelIndex.y * imageWidth + inputPixelIndex.x]; float f = filter[filterIndex]; sum.x += f * p.x; sum.y += f * p.y; sum.z += f * p.z; sum.w += f * p.w; gamma += f; filterIndex++; } } } else { for (int j = 0; j < filterHeight; j++) { int2 inputPixelIndex; inputPixelIndex.y = imageIndex.y - midFilterDimen.y + j; inputPixelIndex.y = ClampToCanvas(inputPixelIndex.y, imageHeight); for (int i = 0; i < filterWidth; i++) { inputPixelIndex.x = imageIndex.x - midFilterDimen.x + i; inputPixelIndex.x = ClampToCanvas(inputPixelIndex.x, imageWidth); CLPixelType p = input[inputPixelIndex.y * imageWidth + inputPixelIndex.x]; float alpha = QuantumScale*(QuantumRange-p.w); float f = filter[filterIndex]; float g = alpha * f; sum.x += g*p.x; sum.y += g*p.y; sum.z += g*p.z; sum.w += f*p.w; gamma += g; filterIndex++; } } gamma = PerceptibleReciprocal(gamma); sum.xyz = gamma*sum.xyz; } CLPixelType outputPixel; outputPixel.x = ClampToQuantum(sum.x); outputPixel.y = ClampToQuantum(sum.y); outputPixel.z = ClampToQuantum(sum.z); outputPixel.w = ((channel & OpacityChannel)!=0)?ClampToQuantum(sum.w):input[imageIndex.y * imageWidth + imageIndex.x].w; output[imageIndex.y * imageWidth + imageIndex.x] = outputPixel; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ~ ^ ~~~~~~~~~~~~
<program source>:25:856: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void Convolve(const __global CLPixelType *input, __global CLPixelType *output, const uint imageWidth, const uint imageHeight, __constant float *filter, const unsigned int filterWidth, const unsigned int filterHeight, const uint matte, const ChannelType channel) { int2 imageIndex; imageIndex.x = get_global_id(0); imageIndex.y = get_global_id(1); if (imageIndex.x >= imageWidth || imageIndex.y >= imageHeight) return; int2 midFilterDimen; midFilterDimen.x = (filterWidth-1)/2; midFilterDimen.y = (filterHeight-1)/2; int filterIndex = 0; float4 sum = (float4)0.0f; float gamma = 0.0f; if (((channel & OpacityChannel) == 0) || (matte == 0)) { for (int j = 0; j < filterHeight; j++) { int2 inputPixelIndex; inputPixelIndex.y = imageIndex.y - midFilterDimen.y + j; inputPixelIndex.y = ClampToCanvas(inputPixelIndex.y, imageHeight); for (int i = 0; i < filterWidth; i++) { inputPixelIndex.x = imageIndex.x - midFilterDimen.x + i; inputPixelIndex.x = ClampToCanvas(inputPixelIndex.x, imageWidth); CLPixelType p = input[inputPixelIndex.y * imageWidth + inputPixelIndex.x]; float f = filter[filterIndex]; sum.x += f * p.x; sum.y += f * p.y; sum.z += f * p.z; sum.w += f * p.w; gamma += f; filterIndex++; } } } else { for (int j = 0; j < filterHeight; j++) { int2 inputPixelIndex; inputPixelIndex.y = imageIndex.y - midFilterDimen.y + j; inputPixelIndex.y = ClampToCanvas(inputPixelIndex.y, imageHeight); for (int i = 0; i < filterWidth; i++) { inputPixelIndex.x = imageIndex.x - midFilterDimen.x + i; inputPixelIndex.x = ClampToCanvas(inputPixelIndex.x, imageWidth); CLPixelType p = input[inputPixelIndex.y * imageWidth + inputPixelIndex.x]; float alpha = QuantumScale*(QuantumRange-p.w); float f = filter[filterIndex]; float g = alpha * f; sum.x += g*p.x; sum.y += g*p.y; sum.z += g*p.z; sum.w += f*p.w; gamma += g; filterIndex++; } } gamma = PerceptibleReciprocal(gamma); sum.xyz = gamma*sum.xyz; } CLPixelType outputPixel; outputPixel.x = ClampToQuantum(sum.x); outputPixel.y = ClampToQuantum(sum.y); outputPixel.z = ClampToQuantum(sum.z); outputPixel.w = ((channel & OpacityChannel)!=0)?ClampToQuantum(sum.w):input[imageIndex.y * imageWidth + imageIndex.x].w; output[imageIndex.y * imageWidth + imageIndex.x] = outputPixel; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ~ ^ ~~~~~~~~~~~
<program source>:25:1237: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void Convolve(const __global CLPixelType *input, __global CLPixelType *output, const uint imageWidth, const uint imageHeight, __constant float *filter, const unsigned int filterWidth, const unsigned int filterHeight, const uint matte, const ChannelType channel) { int2 imageIndex; imageIndex.x = get_global_id(0); imageIndex.y = get_global_id(1); if (imageIndex.x >= imageWidth || imageIndex.y >= imageHeight) return; int2 midFilterDimen; midFilterDimen.x = (filterWidth-1)/2; midFilterDimen.y = (filterHeight-1)/2; int filterIndex = 0; float4 sum = (float4)0.0f; float gamma = 0.0f; if (((channel & OpacityChannel) == 0) || (matte == 0)) { for (int j = 0; j < filterHeight; j++) { int2 inputPixelIndex; inputPixelIndex.y = imageIndex.y - midFilterDimen.y + j; inputPixelIndex.y = ClampToCanvas(inputPixelIndex.y, imageHeight); for (int i = 0; i < filterWidth; i++) { inputPixelIndex.x = imageIndex.x - midFilterDimen.x + i; inputPixelIndex.x = ClampToCanvas(inputPixelIndex.x, imageWidth); CLPixelType p = input[inputPixelIndex.y * imageWidth + inputPixelIndex.x]; float f = filter[filterIndex]; sum.x += f * p.x; sum.y += f * p.y; sum.z += f * p.z; sum.w += f * p.w; gamma += f; filterIndex++; } } } else { for (int j = 0; j < filterHeight; j++) { int2 inputPixelIndex; inputPixelIndex.y = imageIndex.y - midFilterDimen.y + j; inputPixelIndex.y = ClampToCanvas(inputPixelIndex.y, imageHeight); for (int i = 0; i < filterWidth; i++) { inputPixelIndex.x = imageIndex.x - midFilterDimen.x + i; inputPixelIndex.x = ClampToCanvas(inputPixelIndex.x, imageWidth); CLPixelType p = input[inputPixelIndex.y * imageWidth + inputPixelIndex.x]; float alpha = QuantumScale*(QuantumRange-p.w); float f = filter[filterIndex]; float g = alpha * f; sum.x += g*p.x; sum.y += g*p.y; sum.z += g*p.z; sum.w += f*p.w; gamma += g; filterIndex++; } } gamma = PerceptibleReciprocal(gamma); sum.xyz = gamma*sum.xyz; } CLPixelType outputPixel; outputPixel.x = ClampToQuantum(sum.x); outputPixel.y = ClampToQuantum(sum.y); outputPixel.z = ClampToQuantum(sum.z); outputPixel.w = ((channel & OpacityChannel)!=0)?ClampToQuantum(sum.w):input[imageIndex.y * imageWidth + imageIndex.x].w; output[imageIndex.y * imageWidth + imageIndex.x] = outputPixel; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ~ ^ ~~~~~~~~~~~~
<program source>:25:1424: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void Convolve(const __global CLPixelType *input, __global CLPixelType *output, const uint imageWidth, const uint imageHeight, __constant float *filter, const unsigned int filterWidth, const unsigned int filterHeight, const uint matte, const ChannelType channel) { int2 imageIndex; imageIndex.x = get_global_id(0); imageIndex.y = get_global_id(1); if (imageIndex.x >= imageWidth || imageIndex.y >= imageHeight) return; int2 midFilterDimen; midFilterDimen.x = (filterWidth-1)/2; midFilterDimen.y = (filterHeight-1)/2; int filterIndex = 0; float4 sum = (float4)0.0f; float gamma = 0.0f; if (((channel & OpacityChannel) == 0) || (matte == 0)) { for (int j = 0; j < filterHeight; j++) { int2 inputPixelIndex; inputPixelIndex.y = imageIndex.y - midFilterDimen.y + j; inputPixelIndex.y = ClampToCanvas(inputPixelIndex.y, imageHeight); for (int i = 0; i < filterWidth; i++) { inputPixelIndex.x = imageIndex.x - midFilterDimen.x + i; inputPixelIndex.x = ClampToCanvas(inputPixelIndex.x, imageWidth); CLPixelType p = input[inputPixelIndex.y * imageWidth + inputPixelIndex.x]; float f = filter[filterIndex]; sum.x += f * p.x; sum.y += f * p.y; sum.z += f * p.z; sum.w += f * p.w; gamma += f; filterIndex++; } } } else { for (int j = 0; j < filterHeight; j++) { int2 inputPixelIndex; inputPixelIndex.y = imageIndex.y - midFilterDimen.y + j; inputPixelIndex.y = ClampToCanvas(inputPixelIndex.y, imageHeight); for (int i = 0; i < filterWidth; i++) { inputPixelIndex.x = imageIndex.x - midFilterDimen.x + i; inputPixelIndex.x = ClampToCanvas(inputPixelIndex.x, imageWidth); CLPixelType p = input[inputPixelIndex.y * imageWidth + inputPixelIndex.x]; float alpha = QuantumScale*(QuantumRange-p.w); float f = filter[filterIndex]; float g = alpha * f; sum.x += g*p.x; sum.y += g*p.y; sum.z += g*p.z; sum.w += f*p.w; gamma += g; filterIndex++; } } gamma = PerceptibleReciprocal(gamma); sum.xyz = gamma*sum.xyz; } CLPixelType outputPixel; outputPixel.x = ClampToQuantum(sum.x); outputPixel.y = ClampToQuantum(sum.y); outputPixel.z = ClampToQuantum(sum.z); outputPixel.w = ((channel & OpacityChannel)!=0)?ClampToQuantum(sum.w):input[imageIndex.y * imageWidth + imageIndex.x].w; output[imageIndex.y * imageWidth + imageIndex.x] = outputPixel; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ~ ^ ~~~~~~~~~~~
<program source>:27:13: warning: no previous prototype for function 'ApplyFunction'
CLPixelType ApplyFunction(CLPixelType pixel,const MagickFunction function, const unsigned int number_parameters, __constant float *parameters) { float4 result = (float4) 0.0f; switch (function) { case PolynomialFunction: { for (unsigned int i=0; i < number_parameters; i++) result = result*(float4)QuantumScale*convert_float4(pixel) + parameters[i]; result *= (float4)QuantumRange; break; } case SinusoidFunction: { float freq,phase,ampl,bias; freq = ( number_parameters >= 1 ) ? parameters[0] : 1.0f; phase = ( number_parameters >= 2 ) ? parameters[1] : 0.0f; ampl = ( number_parameters >= 3 ) ? parameters[2] : 0.5f; bias = ( number_parameters >= 4 ) ? parameters[3] : 0.5f; result.x = QuantumRange*(ampl*sin(2.0f*MagickPI* (freq*QuantumScale*(float)pixel.x + phase/360.0f)) + bias); result.y = QuantumRange*(ampl*sin(2.0f*MagickPI* (freq*QuantumScale*(float)pixel.y + phase/360.0f)) + bias); result.z = QuantumRange*(ampl*sin(2.0f*MagickPI* (freq*QuantumScale*(float)pixel.z + phase/360.0f)) + bias); result.w = QuantumRange*(ampl*sin(2.0f*MagickPI* (freq*QuantumScale*(float)pixel.w + phase/360.0f)) + bias); break; } case ArcsinFunction: { float width,range,center,bias; width = ( number_parameters >= 1 ) ? parameters[0] : 1.0f; center = ( number_parameters >= 2 ) ? parameters[1] : 0.5f; range = ( number_parameters >= 3 ) ? parameters[2] : 1.0f; bias = ( number_parameters >= 4 ) ? parameters[3] : 0.5f; result.x = 2.0f/width*(QuantumScale*(float)pixel.x - center); result.x = range/MagickPI*asin(result.x)+bias; result.x = ( result.x <= -1.0f ) ? bias - range/2.0f : result.x; result.x = ( result.x >= 1.0f ) ? bias + range/2.0f : result.x; result.y = 2.0f/width*(QuantumScale*(float)pixel.y - center); result.y = range/MagickPI*asin(result.y)+bias; result.y = ( result.y <= -1.0f ) ? bias - range/2.0f : result.y; result.y = ( result.y >= 1.0f ) ? bias + range/2.0f : result.y; result.z = 2.0f/width*(QuantumScale*(float)pixel.z - center); result.z = range/MagickPI*asin(result.z)+bias; result.z = ( result.z <= -1.0f ) ? bias - range/2.0f : result.x; result.z = ( result.z >= 1.0f ) ? bias + range/2.0f : result.x; result.w = 2.0f/width*(QuantumScale*(float)pixel.w - center); result.w = range/MagickPI*asin(result.w)+bias; result.w = ( result.w <= -1.0f ) ? bias - range/2.0f : result.w; result.w = ( result.w >= 1.0f ) ? bias + range/2.0f : result.w; result *= (float4)QuantumRange; break; } case ArctanFunction: { float slope,range,center,bias; slope = ( number_parameters >= 1 ) ? parameters[0] : 1.0f; center = ( number_parameters >= 2 ) ? parameters[1] : 0.5f; range = ( number_parameters >= 3 ) ? parameters[2] : 1.0f; bias = ( number_parameters >= 4 ) ? parameters[3] : 0.5f; result = (float4)MagickPI*(float4)slope*((float4)QuantumScale*convert_float4(pixel)-(float4)center); result = (float4)QuantumRange*((float4)range/(float4)MagickPI*atan(result) + (float4)bias); break; } case UndefinedFunction: break; } return (CLPixelType) (ClampToQuantum(result.x), ClampToQuantum(result.y), ClampToQuantum(result.z), ClampToQuantum(result.w)); }
            ^
<program source>:27:708: error: call to '__fast_relax_sin' is ambiguous
CLPixelType ApplyFunction(CLPixelType pixel,const MagickFunction function, const unsigned int number_parameters, __constant float *parameters) { float4 result = (float4) 0.0f; switch (function) { case PolynomialFunction: { for (unsigned int i=0; i < number_parameters; i++) result = result*(float4)QuantumScale*convert_float4(pixel) + parameters[i]; result *= (float4)QuantumRange; break; } case SinusoidFunction: { float freq,phase,ampl,bias; freq = ( number_parameters >= 1 ) ? parameters[0] : 1.0f; phase = ( number_parameters >= 2 ) ? parameters[1] : 0.0f; ampl = ( number_parameters >= 3 ) ? parameters[2] : 0.5f; bias = ( number_parameters >= 4 ) ? parameters[3] : 0.5f; result.x = QuantumRange*(ampl*sin(2.0f*MagickPI* (freq*QuantumScale*(float)pixel.x + phase/360.0f)) + bias); result.y = QuantumRange*(ampl*sin(2.0f*MagickPI* (freq*QuantumScale*(float)pixel.y + phase/360.0f)) + bias); result.z = QuantumRange*(ampl*sin(2.0f*MagickPI* (freq*QuantumScale*(float)pixel.z + phase/360.0f)) + bias); result.w = QuantumRange*(ampl*sin(2.0f*MagickPI* (freq*QuantumScale*(float)pixel.w + phase/360.0f)) + bias); break; } case ArcsinFunction: { float width,range,center,bias; width = ( number_parameters >= 1 ) ? parameters[0] : 1.0f; center = ( number_parameters >= 2 ) ? parameters[1] : 0.5f; range = ( number_parameters >= 3 ) ? parameters[2] : 1.0f; bias = ( number_parameters >= 4 ) ? parameters[3] : 0.5f; result.x = 2.0f/width*(QuantumScale*(float)pixel.x - center); result.x = range/MagickPI*asin(result.x)+bias; result.x = ( result.x <= -1.0f ) ? bias - range/2.0f : result.x; result.x = ( result.x >= 1.0f ) ? bias + range/2.0f : result.x; result.y = 2.0f/width*(QuantumScale*(float)pixel.y - center); result.y = range/MagickPI*asin(result.y)+bias; result.y = ( result.y <= -1.0f ) ? bias - range/2.0f : result.y; result.y = ( result.y >= 1.0f ) ? bias + range/2.0f : result.y; result.z = 2.0f/width*(QuantumScale*(float)pixel.z - center); result.z = range/MagickPI*asin(result.z)+bias; result.z = ( result.z <= -1.0f ) ? bias - range/2.0f : result.x; result.z = ( result.z >= 1.0f ) ? bias + range/2.0f : result.x; result.w = 2.0f/width*(QuantumScale*(float)pixel.w - center); result.w = range/MagickPI*asin(result.w)+bias; result.w = ( result.w <= -1.0f ) ? bias - range/2.0f : result.w; result.w = ( result.w >= 1.0f ) ? bias + range/2.0f : result.w; result *= (float4)QuantumRange; break; } case ArctanFunction: { float slope,range,center,bias; slope = ( number_parameters >= 1 ) ? parameters[0] : 1.0f; center = ( number_parameters >= 2 ) ? parameters[1] : 0.5f; range = ( number_parameters >= 3 ) ? parameters[2] : 1.0f; bias = ( number_parameters >= 4 ) ? parameters[3] : 0.5f; result = (float4)MagickPI*(float4)slope*((float4)QuantumScale*convert_float4(pixel)-(float4)center); result = (float4)QuantumRange*((float4)range/(float4)MagickPI*atan(result) + (float4)bias); break; } case UndefinedFunction: break; } return (CLPixelType) (ClampToQuantum(result.x), ClampToQuantum(result.y), ClampToQuantum(result.z), ClampToQuantum(result.w)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4718:22: note: expanded from macro 'sin'
    #define sin(__x) __fast_relax_sin(__x)
                     ^~~~~~~~~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:416:27: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float __OVERLOAD__ _name(float x) { return _default_name(x); } \
                          ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:417:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float2 __OVERLOAD__ _name(float2 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:418:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float3 __OVERLOAD__ _name(float3 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:419:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float4 __OVERLOAD__ _name(float4 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:420:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float8 __OVERLOAD__ _name(float8 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:421:29: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float16 __OVERLOAD__ _name(float16 x){ return _default_name(x); }
                            ^
<program source>:27:817: error: call to '__fast_relax_sin' is ambiguous
CLPixelType ApplyFunction(CLPixelType pixel,const MagickFunction function, const unsigned int number_parameters, __constant float *parameters) { float4 result = (float4) 0.0f; switch (function) { case PolynomialFunction: { for (unsigned int i=0; i < number_parameters; i++) result = result*(float4)QuantumScale*convert_float4(pixel) + parameters[i]; result *= (float4)QuantumRange; break; } case SinusoidFunction: { float freq,phase,ampl,bias; freq = ( number_parameters >= 1 ) ? parameters[0] : 1.0f; phase = ( number_parameters >= 2 ) ? parameters[1] : 0.0f; ampl = ( number_parameters >= 3 ) ? parameters[2] : 0.5f; bias = ( number_parameters >= 4 ) ? parameters[3] : 0.5f; result.x = QuantumRange*(ampl*sin(2.0f*MagickPI* (freq*QuantumScale*(float)pixel.x + phase/360.0f)) + bias); result.y = QuantumRange*(ampl*sin(2.0f*MagickPI* (freq*QuantumScale*(float)pixel.y + phase/360.0f)) + bias); result.z = QuantumRange*(ampl*sin(2.0f*MagickPI* (freq*QuantumScale*(float)pixel.z + phase/360.0f)) + bias); result.w = QuantumRange*(ampl*sin(2.0f*MagickPI* (freq*QuantumScale*(float)pixel.w + phase/360.0f)) + bias); break; } case ArcsinFunction: { float width,range,center,bias; width = ( number_parameters >= 1 ) ? parameters[0] : 1.0f; center = ( number_parameters >= 2 ) ? parameters[1] : 0.5f; range = ( number_parameters >= 3 ) ? parameters[2] : 1.0f; bias = ( number_parameters >= 4 ) ? parameters[3] : 0.5f; result.x = 2.0f/width*(QuantumScale*(float)pixel.x - center); result.x = range/MagickPI*asin(result.x)+bias; result.x = ( result.x <= -1.0f ) ? bias - range/2.0f : result.x; result.x = ( result.x >= 1.0f ) ? bias + range/2.0f : result.x; result.y = 2.0f/width*(QuantumScale*(float)pixel.y - center); result.y = range/MagickPI*asin(result.y)+bias; result.y = ( result.y <= -1.0f ) ? bias - range/2.0f : result.y; result.y = ( result.y >= 1.0f ) ? bias + range/2.0f : result.y; result.z = 2.0f/width*(QuantumScale*(float)pixel.z - center); result.z = range/MagickPI*asin(result.z)+bias; result.z = ( result.z <= -1.0f ) ? bias - range/2.0f : result.x; result.z = ( result.z >= 1.0f ) ? bias + range/2.0f : result.x; result.w = 2.0f/width*(QuantumScale*(float)pixel.w - center); result.w = range/MagickPI*asin(result.w)+bias; result.w = ( result.w <= -1.0f ) ? bias - range/2.0f : result.w; result.w = ( result.w >= 1.0f ) ? bias + range/2.0f : result.w; result *= (float4)QuantumRange; break; } case ArctanFunction: { float slope,range,center,bias; slope = ( number_parameters >= 1 ) ? parameters[0] : 1.0f; center = ( number_parameters >= 2 ) ? parameters[1] : 0.5f; range = ( number_parameters >= 3 ) ? parameters[2] : 1.0f; bias = ( number_parameters >= 4 ) ? parameters[3] : 0.5f; result = (float4)MagickPI*(float4)slope*((float4)QuantumScale*convert_float4(pixel)-(float4)center); result = (float4)QuantumRange*((float4)range/(float4)MagickPI*atan(result) + (float4)bias); break; } case UndefinedFunction: break; } return (CLPixelType) (ClampToQuantum(result.x), ClampToQuantum(result.y), ClampToQuantum(result.z), ClampToQuantum(result.w)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4718:22: note: expanded from macro 'sin'
    #define sin(__x) __fast_relax_sin(__x)
                     ^~~~~~~~~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:416:27: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float __OVERLOAD__ _name(float x) { return _default_name(x); } \
                          ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:417:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float2 __OVERLOAD__ _name(float2 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:418:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float3 __OVERLOAD__ _name(float3 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:419:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float4 __OVERLOAD__ _name(float4 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:420:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float8 __OVERLOAD__ _name(float8 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:421:29: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float16 __OVERLOAD__ _name(float16 x){ return _default_name(x); }
                            ^
<program source>:27:926: error: call to '__fast_relax_sin' is ambiguous
CLPixelType ApplyFunction(CLPixelType pixel,const MagickFunction function, const unsigned int number_parameters, __constant float *parameters) { float4 result = (float4) 0.0f; switch (function) { case PolynomialFunction: { for (unsigned int i=0; i < number_parameters; i++) result = result*(float4)QuantumScale*convert_float4(pixel) + parameters[i]; result *= (float4)QuantumRange; break; } case SinusoidFunction: { float freq,phase,ampl,bias; freq = ( number_parameters >= 1 ) ? parameters[0] : 1.0f; phase = ( number_parameters >= 2 ) ? parameters[1] : 0.0f; ampl = ( number_parameters >= 3 ) ? parameters[2] : 0.5f; bias = ( number_parameters >= 4 ) ? parameters[3] : 0.5f; result.x = QuantumRange*(ampl*sin(2.0f*MagickPI* (freq*QuantumScale*(float)pixel.x + phase/360.0f)) + bias); result.y = QuantumRange*(ampl*sin(2.0f*MagickPI* (freq*QuantumScale*(float)pixel.y + phase/360.0f)) + bias); result.z = QuantumRange*(ampl*sin(2.0f*MagickPI* (freq*QuantumScale*(float)pixel.z + phase/360.0f)) + bias); result.w = QuantumRange*(ampl*sin(2.0f*MagickPI* (freq*QuantumScale*(float)pixel.w + phase/360.0f)) + bias); break; } case ArcsinFunction: { float width,range,center,bias; width = ( number_parameters >= 1 ) ? parameters[0] : 1.0f; center = ( number_parameters >= 2 ) ? parameters[1] : 0.5f; range = ( number_parameters >= 3 ) ? parameters[2] : 1.0f; bias = ( number_parameters >= 4 ) ? parameters[3] : 0.5f; result.x = 2.0f/width*(QuantumScale*(float)pixel.x - center); result.x = range/MagickPI*asin(result.x)+bias; result.x = ( result.x <= -1.0f ) ? bias - range/2.0f : result.x; result.x = ( result.x >= 1.0f ) ? bias + range/2.0f : result.x; result.y = 2.0f/width*(QuantumScale*(float)pixel.y - center); result.y = range/MagickPI*asin(result.y)+bias; result.y = ( result.y <= -1.0f ) ? bias - range/2.0f : result.y; result.y = ( result.y >= 1.0f ) ? bias + range/2.0f : result.y; result.z = 2.0f/width*(QuantumScale*(float)pixel.z - center); result.z = range/MagickPI*asin(result.z)+bias; result.z = ( result.z <= -1.0f ) ? bias - range/2.0f : result.x; result.z = ( result.z >= 1.0f ) ? bias + range/2.0f : result.x; result.w = 2.0f/width*(QuantumScale*(float)pixel.w - center); result.w = range/MagickPI*asin(result.w)+bias; result.w = ( result.w <= -1.0f ) ? bias - range/2.0f : result.w; result.w = ( result.w >= 1.0f ) ? bias + range/2.0f : result.w; result *= (float4)QuantumRange; break; } case ArctanFunction: { float slope,range,center,bias; slope = ( number_parameters >= 1 ) ? parameters[0] : 1.0f; center = ( number_parameters >= 2 ) ? parameters[1] : 0.5f; range = ( number_parameters >= 3 ) ? parameters[2] : 1.0f; bias = ( number_parameters >= 4 ) ? parameters[3] : 0.5f; result = (float4)MagickPI*(float4)slope*((float4)QuantumScale*convert_float4(pixel)-(float4)center); result = (float4)QuantumRange*((float4)range/(float4)MagickPI*atan(result) + (float4)bias); break; } case UndefinedFunction: break; } return (CLPixelType) (ClampToQuantum(result.x), ClampToQuantum(result.y), ClampToQuantum(result.z), ClampToQuantum(result.w)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4718:22: note: expanded from macro 'sin'
    #define sin(__x) __fast_relax_sin(__x)
                     ^~~~~~~~~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:416:27: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float __OVERLOAD__ _name(float x) { return _default_name(x); } \
                          ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:417:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float2 __OVERLOAD__ _name(float2 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:418:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float3 __OVERLOAD__ _name(float3 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:419:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float4 __OVERLOAD__ _name(float4 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:420:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float8 __OVERLOAD__ _name(float8 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:421:29: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float16 __OVERLOAD__ _name(float16 x){ return _default_name(x); }
                            ^
<program source>:27:1035: error: call to '__fast_relax_sin' is ambiguous
CLPixelType ApplyFunction(CLPixelType pixel,const MagickFunction function, const unsigned int number_parameters, __constant float *parameters) { float4 result = (float4) 0.0f; switch (function) { case PolynomialFunction: { for (unsigned int i=0; i < number_parameters; i++) result = result*(float4)QuantumScale*convert_float4(pixel) + parameters[i]; result *= (float4)QuantumRange; break; } case SinusoidFunction: { float freq,phase,ampl,bias; freq = ( number_parameters >= 1 ) ? parameters[0] : 1.0f; phase = ( number_parameters >= 2 ) ? parameters[1] : 0.0f; ampl = ( number_parameters >= 3 ) ? parameters[2] : 0.5f; bias = ( number_parameters >= 4 ) ? parameters[3] : 0.5f; result.x = QuantumRange*(ampl*sin(2.0f*MagickPI* (freq*QuantumScale*(float)pixel.x + phase/360.0f)) + bias); result.y = QuantumRange*(ampl*sin(2.0f*MagickPI* (freq*QuantumScale*(float)pixel.y + phase/360.0f)) + bias); result.z = QuantumRange*(ampl*sin(2.0f*MagickPI* (freq*QuantumScale*(float)pixel.z + phase/360.0f)) + bias); result.w = QuantumRange*(ampl*sin(2.0f*MagickPI* (freq*QuantumScale*(float)pixel.w + phase/360.0f)) + bias); break; } case ArcsinFunction: { float width,range,center,bias; width = ( number_parameters >= 1 ) ? parameters[0] : 1.0f; center = ( number_parameters >= 2 ) ? parameters[1] : 0.5f; range = ( number_parameters >= 3 ) ? parameters[2] : 1.0f; bias = ( number_parameters >= 4 ) ? parameters[3] : 0.5f; result.x = 2.0f/width*(QuantumScale*(float)pixel.x - center); result.x = range/MagickPI*asin(result.x)+bias; result.x = ( result.x <= -1.0f ) ? bias - range/2.0f : result.x; result.x = ( result.x >= 1.0f ) ? bias + range/2.0f : result.x; result.y = 2.0f/width*(QuantumScale*(float)pixel.y - center); result.y = range/MagickPI*asin(result.y)+bias; result.y = ( result.y <= -1.0f ) ? bias - range/2.0f : result.y; result.y = ( result.y >= 1.0f ) ? bias + range/2.0f : result.y; result.z = 2.0f/width*(QuantumScale*(float)pixel.z - center); result.z = range/MagickPI*asin(result.z)+bias; result.z = ( result.z <= -1.0f ) ? bias - range/2.0f : result.x; result.z = ( result.z >= 1.0f ) ? bias + range/2.0f : result.x; result.w = 2.0f/width*(QuantumScale*(float)pixel.w - center); result.w = range/MagickPI*asin(result.w)+bias; result.w = ( result.w <= -1.0f ) ? bias - range/2.0f : result.w; result.w = ( result.w >= 1.0f ) ? bias + range/2.0f : result.w; result *= (float4)QuantumRange; break; } case ArctanFunction: { float slope,range,center,bias; slope = ( number_parameters >= 1 ) ? parameters[0] : 1.0f; center = ( number_parameters >= 2 ) ? parameters[1] : 0.5f; range = ( number_parameters >= 3 ) ? parameters[2] : 1.0f; bias = ( number_parameters >= 4 ) ? parameters[3] : 0.5f; result = (float4)MagickPI*(float4)slope*((float4)QuantumScale*convert_float4(pixel)-(float4)center); result = (float4)QuantumRange*((float4)range/(float4)MagickPI*atan(result) + (float4)bias); break; } case UndefinedFunction: break; } return (CLPixelType) (ClampToQuantum(result.x), ClampToQuantum(result.y), ClampToQuantum(result.z), ClampToQuantum(result.w)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4718:22: note: expanded from macro 'sin'
    #define sin(__x) __fast_relax_sin(__x)
                     ^~~~~~~~~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:416:27: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float __OVERLOAD__ _name(float x) { return _default_name(x); } \
                          ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:417:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float2 __OVERLOAD__ _name(float2 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:418:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float3 __OVERLOAD__ _name(float3 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:419:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float4 __OVERLOAD__ _name(float4 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:420:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float8 __OVERLOAD__ _name(float8 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4716:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:421:29: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float16 __OVERLOAD__ _name(float16 x){ return _default_name(x); }
                            ^
<program source>:32:531: warning: unused variable 'groupY'
__kernel void BlurRow(__global CLPixelType *im, __global float4 *filtered_im, const ChannelType channel, __constant float *filter, const unsigned int width, const unsigned int imageColumns, const unsigned int imageRows, __local CLPixelType *temp) { const int x = get_global_id(0); const int y = get_global_id(1); const int columns = imageColumns; const unsigned int radius = (width-1)/2; const int wsize = get_local_size(0); const unsigned int loadSize = wsize+width; const int groupX=get_local_size(0)*get_group_id(0); const int groupY=get_local_size(1)*get_group_id(1); for (int i=get_local_id(0); i < loadSize; i=i+get_local_size(0)) { temp[i] = im[y * columns + ClampToCanvas(i+groupX-radius, columns)]; } barrier(CLK_LOCAL_MEM_FENCE); if (get_global_id(0) < columns) { float4 result = (float4) 0; int i = 0; 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
<program source>:32:603: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void BlurRow(__global CLPixelType *im, __global float4 *filtered_im, const ChannelType channel, __constant float *filter, const unsigned int width, const unsigned int imageColumns, const unsigned int imageRows, __local CLPixelType *temp) { const int x = get_global_id(0); const int y = get_global_id(1); const int columns = imageColumns; const unsigned int radius = (width-1)/2; const int wsize = get_local_size(0); const unsigned int loadSize = wsize+width; const int groupX=get_local_size(0)*get_group_id(0); const int groupY=get_local_size(1)*get_group_id(1); for (int i=get_local_id(0); i < loadSize; i=i+get_local_size(0)) { temp[i] = im[y * columns + ClampToCanvas(i+groupX-radius, columns)]; } barrier(CLK_LOCAL_MEM_FENCE); if (get_global_id(0) < columns) { float4 result = (float4) 0; int i = 0; 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ~ ^ ~~~~~~~~
<program source>:32:762: warning: comparison of integers of different signs: 'size_t' (aka 'unsigned long') and 'const int'
__kernel void BlurRow(__global CLPixelType *im, __global float4 *filtered_im, const ChannelType channel, __constant float *filter, const unsigned int width, const unsigned int imageColumns, const unsigned int imageRows, __local CLPixelType *temp) { const int x = get_global_id(0); const int y = get_global_id(1); const int columns = imageColumns; const unsigned int radius = (width-1)/2; const int wsize = get_local_size(0); const unsigned int loadSize = wsize+width; const int groupX=get_local_size(0)*get_group_id(0); const int groupY=get_local_size(1)*get_group_id(1); for (int i=get_local_id(0); i < loadSize; i=i+get_local_size(0)) { temp[i] = im[y * columns + ClampToCanvas(i+groupX-radius, columns)]; } barrier(CLK_LOCAL_MEM_FENCE); if (get_global_id(0) < columns) { float4 result = (float4) 0; int i = 0; 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ~~~~~~~~~~~~~~~~ ^ ~~~~~~~
<program source>:38:20: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
 for ( ; i+UFACTOR < width; ) { 
         ~~~~~~~~~ ^ ~~~~~
<program source>:40:114: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
 for (int j=0; j < UFACTOR; j++, i++) { result+=filter[i]*convert_float4(temp[i+get_local_id(0)]); } } for ( ; i < width; i++) { result+=filter[i]*convert_float4(temp[i+get_local_id(0)]); } result.x = ClampToQuantum(result.x); result.y = ClampToQuantum(result.y); result.z = ClampToQuantum(result.z); result.w = ClampToQuantum(result.w); filtered_im[y*columns+x] = result; } }
                                                                                                               ~ ^ ~~~~~
<program source>:41:597: warning: unused variable 'groupY'
__kernel void BlurRowSection(__global CLPixelType *im, __global float4 *filtered_im, const ChannelType channel, __constant float *filter, const unsigned int width, const unsigned int imageColumns, const unsigned int imageRows, __local CLPixelType *temp, const unsigned int offsetRows, const unsigned int section) { const int x = get_global_id(0); const int y = get_global_id(1); const int columns = imageColumns; const unsigned int radius = (width-1)/2; const int wsize = get_local_size(0); const unsigned int loadSize = wsize+width; const int groupX=get_local_size(0)*get_group_id(0); const int groupY=get_local_size(1)*get_group_id(1); im += imageColumns * (offsetRows - radius * section); for (int i=get_local_id(0); i < loadSize; i=i+get_local_size(0)) { temp[i] = im[y * columns + ClampToCanvas(i+groupX-radius, columns)]; } barrier(CLK_LOCAL_MEM_FENCE); if (get_global_id(0) < columns) { float4 result = (float4) 0; int i = 0; 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
<program source>:41:723: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void BlurRowSection(__global CLPixelType *im, __global float4 *filtered_im, const ChannelType channel, __constant float *filter, const unsigned int width, const unsigned int imageColumns, const unsigned int imageRows, __local CLPixelType *temp, const unsigned int offsetRows, const unsigned int section) { const int x = get_global_id(0); const int y = get_global_id(1); const int columns = imageColumns; const unsigned int radius = (width-1)/2; const int wsize = get_local_size(0); const unsigned int loadSize = wsize+width; const int groupX=get_local_size(0)*get_group_id(0); const int groupY=get_local_size(1)*get_group_id(1); im += imageColumns * (offsetRows - radius * section); for (int i=get_local_id(0); i < loadSize; i=i+get_local_size(0)) { temp[i] = im[y * columns + ClampToCanvas(i+groupX-radius, columns)]; } barrier(CLK_LOCAL_MEM_FENCE); if (get_global_id(0) < columns) { float4 result = (float4) 0; int i = 0; 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ~ ^ ~~~~~~~~
<program source>:41:882: warning: comparison of integers of different signs: 'size_t' (aka 'unsigned long') and 'const int'
__kernel void BlurRowSection(__global CLPixelType *im, __global float4 *filtered_im, const ChannelType channel, __constant float *filter, const unsigned int width, const unsigned int imageColumns, const unsigned int imageRows, __local CLPixelType *temp, const unsigned int offsetRows, const unsigned int section) { const int x = get_global_id(0); const int y = get_global_id(1); const int columns = imageColumns; const unsigned int radius = (width-1)/2; const int wsize = get_local_size(0); const unsigned int loadSize = wsize+width; const int groupX=get_local_size(0)*get_group_id(0); const int groupY=get_local_size(1)*get_group_id(1); im += imageColumns * (offsetRows - radius * section); for (int i=get_local_id(0); i < loadSize; i=i+get_local_size(0)) { temp[i] = im[y * columns + ClampToCanvas(i+groupX-radius, columns)]; } barrier(CLK_LOCAL_MEM_FENCE); if (get_global_id(0) < columns) { float4 result = (float4) 0; int i = 0; 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ~~~~~~~~~~~~~~~~ ^ ~~~~~~~
<program source>:47:20: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
 for ( ; i+UFACTOR < width; ) { 
         ~~~~~~~~~ ^ ~~~~~
<program source>:49:114: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
 for (int j=0; j < UFACTOR; j++, i++) { result+=filter[i]*convert_float4(temp[i+get_local_id(0)]); } } for ( ; i < width; i++) { result+=filter[i]*convert_float4(temp[i+get_local_id(0)]); } result.x = ClampToQuantum(result.x); result.y = ClampToQuantum(result.y); result.z = ClampToQuantum(result.z); result.w = ClampToQuantum(result.w); filtered_im[y*columns+x] = result; } }
                                                                                                               ~ ^ ~~~~~
<program source>:50:640: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void BlurColumn(const __global float4 *blurRowData, __global CLPixelType *filtered_im, const ChannelType channel, __constant float *filter, const unsigned int width, const unsigned int imageColumns, const unsigned int imageRows, __local float4 *temp) { const int x = get_global_id(0); const int y = get_global_id(1); const int columns = imageColumns; const int rows = imageRows; unsigned int radius = (width-1)/2; const int wsize = get_local_size(1); const unsigned int loadSize = wsize+width; const int groupX=get_local_size(0)*get_group_id(0); const int groupY=get_local_size(1)*get_group_id(1); for (int i = get_local_id(1); i < loadSize; i=i+get_local_size(1)) { temp[i] = blurRowData[ClampToCanvas(i+groupY-radius, rows) * columns + groupX]; } barrier(CLK_LOCAL_MEM_FENCE); if (get_global_id(1) < rows) { float4 result = (float4) 0; int i = 0; 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ~ ^ ~~~~~~~~
<program source>:50:810: warning: comparison of integers of different signs: 'size_t' (aka 'unsigned long') and 'const int'
__kernel void BlurColumn(const __global float4 *blurRowData, __global CLPixelType *filtered_im, const ChannelType channel, __constant float *filter, const unsigned int width, const unsigned int imageColumns, const unsigned int imageRows, __local float4 *temp) { const int x = get_global_id(0); const int y = get_global_id(1); const int columns = imageColumns; const int rows = imageRows; unsigned int radius = (width-1)/2; const int wsize = get_local_size(1); const unsigned int loadSize = wsize+width; const int groupX=get_local_size(0)*get_group_id(0); const int groupY=get_local_size(1)*get_group_id(1); for (int i = get_local_id(1); i < loadSize; i=i+get_local_size(1)) { temp[i] = blurRowData[ClampToCanvas(i+groupY-radius, rows) * columns + groupX]; } barrier(CLK_LOCAL_MEM_FENCE); if (get_global_id(1) < rows) { float4 result = (float4) 0; int i = 0; 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ~~~~~~~~~~~~~~~~ ^ ~~~~
<program source>:56:20: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
 for ( ; i+UFACTOR < width; ) { 
         ~~~~~~~~~ ^ ~~~~~
<program source>:58:98: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
 for (int j=0; j < UFACTOR; j++, i++) { result+=filter[i]*temp[i+get_local_id(1)]; } } for ( ; i < width; i++) { result+=filter[i]*temp[i+get_local_id(1)]; } result.x = ClampToQuantum(result.x); result.y = ClampToQuantum(result.y); result.z = ClampToQuantum(result.z); result.w = ClampToQuantum(result.w); filtered_im[y*columns+x] = (CLPixelType) (result.x,result.y,result.z,result.w); } }
                                                                                               ~ ^ ~~~~~
<program source>:59:754: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void BlurColumnSection(const __global float4 *blurRowData, __global CLPixelType *filtered_im, const ChannelType channel, __constant float *filter, const unsigned int width, const unsigned int imageColumns, const unsigned int imageRows, __local float4 *temp, const unsigned int offsetRows, const unsigned int section) { const int x = get_global_id(0); const int y = get_global_id(1); const int columns = imageColumns; const int rows = imageRows; unsigned int radius = (width-1)/2; const int wsize = get_local_size(1); const unsigned int loadSize = wsize+width; const int groupX=get_local_size(0)*get_group_id(0); const int groupY=get_local_size(1)*get_group_id(1); blurRowData += imageColumns * radius * section; for (int i = get_local_id(1); i < loadSize; i=i+get_local_size(1)) { int pos = ClampToCanvasWithHalo(i+groupY-radius, rows, radius, section) * columns + groupX; temp[i] = *(blurRowData+pos); } barrier(CLK_LOCAL_MEM_FENCE); if (get_global_id(1) < rows) { float4 result = (float4) 0; int i = 0; 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ~ ^ ~~~~~~~~
<program source>:59:966: warning: comparison of integers of different signs: 'size_t' (aka 'unsigned long') and 'const int'
__kernel void BlurColumnSection(const __global float4 *blurRowData, __global CLPixelType *filtered_im, const ChannelType channel, __constant float *filter, const unsigned int width, const unsigned int imageColumns, const unsigned int imageRows, __local float4 *temp, const unsigned int offsetRows, const unsigned int section) { const int x = get_global_id(0); const int y = get_global_id(1); const int columns = imageColumns; const int rows = imageRows; unsigned int radius = (width-1)/2; const int wsize = get_local_size(1); const unsigned int loadSize = wsize+width; const int groupX=get_local_size(0)*get_group_id(0); const int groupY=get_local_size(1)*get_group_id(1); blurRowData += imageColumns * radius * section; for (int i = get_local_id(1); i < loadSize; i=i+get_local_size(1)) { int pos = ClampToCanvasWithHalo(i+groupY-radius, rows, radius, section) * columns + groupX; temp[i] = *(blurRowData+pos); } barrier(CLK_LOCAL_MEM_FENCE); if (get_global_id(1) < rows) { float4 result = (float4) 0; int i = 0; 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ~~~~~~~~~~~~~~~~ ^ ~~~~
<program source>:65:20: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
 for ( ; i+UFACTOR < width; ) { 
         ~~~~~~~~~ ^ ~~~~~
<program source>:67:98: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
 for (int j=0; j < UFACTOR; j++, i++) { result+=filter[i]*temp[i+get_local_id(1)]; } } for ( ; i < width; i++) { result+=filter[i]*temp[i+get_local_id(1)]; } result.x = ClampToQuantum(result.x); result.y = ClampToQuantum(result.y); result.z = ClampToQuantum(result.z); result.w = ClampToQuantum(result.w); filtered_im += imageColumns * offsetRows; filtered_im[y*columns+x] = (CLPixelType) (result.x,result.y,result.z,result.w); } }
                                                                                               ~ ^ ~~~~~
<program source>:68:645: warning: comparison of integers of different signs: 'const int' and 'const unsigned int'
__kernel void UnsharpMaskBlurColumn(const __global CLPixelType* inputImage, const __global float4 *blurRowData, __global CLPixelType *filtered_im, const unsigned int imageColumns, const unsigned int imageRows, __local float4* cachedData, __local float* cachedFilter, const ChannelType channel, const __global float *filter, const unsigned int width, const float gain, const float threshold) { const unsigned int radius = (width-1)/2; const int groupX = get_group_id(0); const int groupStartY = get_group_id(1)*get_local_size(1) - radius; const int groupStopY = (get_group_id(1)+1)*get_local_size(1) + radius; if (groupStartY >= 0 && groupStopY < imageRows) { event_t e = async_work_group_strided_copy(cachedData ,blurRowData+groupStartY*imageColumns+groupX ,groupStopY-groupStartY,imageColumns,0); wait_group_events(1,&e); } else { for (int i = get_local_id(1); i < (groupStopY - groupStartY); i+=get_local_size(1)) { cachedData[i] = blurRowData[ClampToCanvas(groupStartY+i,imageRows)*imageColumns+ groupX]; } barrier(CLK_LOCAL_MEM_FENCE); } event_t e = async_work_group_copy(cachedFilter,filter,width,0); wait_group_events(1,&e); const int cy = get_global_id(1); if (cy < imageRows) { float4 blurredPixel = (float4) 0.0f; int i = 0; 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ~~~~~~~~~~ ^ ~~~~~~~~~
<program source>:68:1172: warning: comparison of integers of different signs: 'const int' and 'const unsigned int'
__kernel void UnsharpMaskBlurColumn(const __global CLPixelType* inputImage, const __global float4 *blurRowData, __global CLPixelType *filtered_im, const unsigned int imageColumns, const unsigned int imageRows, __local float4* cachedData, __local float* cachedFilter, const ChannelType channel, const __global float *filter, const unsigned int width, const float gain, const float threshold) { const unsigned int radius = (width-1)/2; const int groupX = get_group_id(0); const int groupStartY = get_group_id(1)*get_local_size(1) - radius; const int groupStopY = (get_group_id(1)+1)*get_local_size(1) + radius; if (groupStartY >= 0 && groupStopY < imageRows) { event_t e = async_work_group_strided_copy(cachedData ,blurRowData+groupStartY*imageColumns+groupX ,groupStopY-groupStartY,imageColumns,0); wait_group_events(1,&e); } else { for (int i = get_local_id(1); i < (groupStopY - groupStartY); i+=get_local_size(1)) { cachedData[i] = blurRowData[ClampToCanvas(groupStartY+i,imageRows)*imageColumns+ groupX]; } barrier(CLK_LOCAL_MEM_FENCE); } event_t e = async_work_group_copy(cachedFilter,filter,width,0); wait_group_events(1,&e); const int cy = get_global_id(1); if (cy < imageRows) { float4 blurredPixel = (float4) 0.0f; int i = 0; 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ~~ ^ ~~~~~~~~~
<program source>:74:20: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
 for ( ; i+UFACTOR < width; ) { 
         ~~~~~~~~~ ^ ~~~~~
<program source>:76:116: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
 for (int j=0; j < UFACTOR; j++, i++) { blurredPixel+=cachedFilter[i]*cachedData[i+get_local_id(1)]; } } for ( ; i < width; i++) { blurredPixel+=cachedFilter[i]*cachedData[i+get_local_id(1)]; } blurredPixel = floor((float4)(ClampToQuantum(blurredPixel.x), ClampToQuantum(blurredPixel.y) ,ClampToQuantum(blurredPixel.z), ClampToQuantum(blurredPixel.w))); float4 inputImagePixel = convert_float4(inputImage[cy*imageColumns+groupX]); float4 outputPixel = inputImagePixel - blurredPixel; float quantumThreshold = QuantumRange*threshold; int4 mask = isless(fabs(2.0f*outputPixel), (float4)quantumThreshold); outputPixel = select(inputImagePixel + outputPixel * gain, inputImagePixel, mask); filtered_im[cy*imageColumns+groupX] = (CLPixelType) (ClampToQuantum(outputPixel.x), ClampToQuantum(outputPixel.y) ,ClampToQuantum(outputPixel.z), ClampToQuantum(outputPixel.w)); } } __kernel void UnsharpMaskBlurColumnSection(const __global CLPixelType* inputImage, const __global float4 *blurRowData, __global CLPixelType *filtered_im, const unsigned int imageColumns, const unsigned int imageRows, __local float4* cachedData, __local float* cachedFilter, const ChannelType channel, const __global float *filter, const unsigned int width, const float gain, const float threshold, const unsigned int offsetRows, const unsigned int section) { const unsigned int radius = (width-1)/2; const int groupX = get_group_id(0); const int groupStartY = get_group_id(1)*get_local_size(1) - radius; const int groupStopY = (get_group_id(1)+1)*get_local_size(1) + radius; blurRowData += imageColumns * radius * section; if (groupStartY >= 0 && groupStopY < imageRows) { event_t e = async_work_group_strided_copy(cachedData ,blurRowData+groupStartY*imageColumns+groupX ,groupStopY-groupStartY,imageColumns,0); wait_group_events(1,&e); } else { for (int i = get_local_id(1); i < (groupStopY - groupStartY); i+=get_local_size(1)) { int pos = ClampToCanvasWithHalo(groupStartY+i,imageRows, radius, section)*imageColumns+ groupX; cachedData[i] = *(blurRowData + pos); } barrier(CLK_LOCAL_MEM_FENCE); } event_t e = async_work_group_copy(cachedFilter,filter,width,0); wait_group_events(1,&e); const int cy = get_global_id(1); if (cy < imageRows) { float4 blurredPixel = (float4) 0.0f; int i = 0; 
                                                                                                                 ~ ^ ~~~~~
<program source>:76:1627: warning: comparison of integers of different signs: 'const int' and 'const unsigned int'
 for (int j=0; j < UFACTOR; j++, i++) { blurredPixel+=cachedFilter[i]*cachedData[i+get_local_id(1)]; } } for ( ; i < width; i++) { blurredPixel+=cachedFilter[i]*cachedData[i+get_local_id(1)]; } blurredPixel = floor((float4)(ClampToQuantum(blurredPixel.x), ClampToQuantum(blurredPixel.y) ,ClampToQuantum(blurredPixel.z), ClampToQuantum(blurredPixel.w))); float4 inputImagePixel = convert_float4(inputImage[cy*imageColumns+groupX]); float4 outputPixel = inputImagePixel - blurredPixel; float quantumThreshold = QuantumRange*threshold; int4 mask = isless(fabs(2.0f*outputPixel), (float4)quantumThreshold); outputPixel = select(inputImagePixel + outputPixel * gain, inputImagePixel, mask); filtered_im[cy*imageColumns+groupX] = (CLPixelType) (ClampToQuantum(outputPixel.x), ClampToQuantum(outputPixel.y) ,ClampToQuantum(outputPixel.z), ClampToQuantum(outputPixel.w)); } } __kernel void UnsharpMaskBlurColumnSection(const __global CLPixelType* inputImage, const __global float4 *blurRowData, __global CLPixelType *filtered_im, const unsigned int imageColumns, const unsigned int imageRows, __local float4* cachedData, __local float* cachedFilter, const ChannelType channel, const __global float *filter, const unsigned int width, const float gain, const float threshold, const unsigned int offsetRows, const unsigned int section) { const unsigned int radius = (width-1)/2; const int groupX = get_group_id(0); const int groupStartY = get_group_id(1)*get_local_size(1) - radius; const int groupStopY = (get_group_id(1)+1)*get_local_size(1) + radius; blurRowData += imageColumns * radius * section; if (groupStartY >= 0 && groupStopY < imageRows) { event_t e = async_work_group_strided_copy(cachedData ,blurRowData+groupStartY*imageColumns+groupX ,groupStopY-groupStartY,imageColumns,0); wait_group_events(1,&e); } else { for (int i = get_local_id(1); i < (groupStopY - groupStartY); i+=get_local_size(1)) { int pos = ClampToCanvasWithHalo(groupStartY+i,imageRows, radius, section)*imageColumns+ groupX; cachedData[i] = *(blurRowData + pos); } barrier(CLK_LOCAL_MEM_FENCE); } event_t e = async_work_group_copy(cachedFilter,filter,width,0); wait_group_events(1,&e); const int cy = get_global_id(1); if (cy < imageRows) { float4 blurredPixel = (float4) 0.0f; int i = 0; 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ~~~~~~~~~~ ^ ~~~~~~~~~
<program source>:76:2198: warning: comparison of integers of different signs: 'const int' and 'const unsigned int'
 for (int j=0; j < UFACTOR; j++, i++) { blurredPixel+=cachedFilter[i]*cachedData[i+get_local_id(1)]; } } for ( ; i < width; i++) { blurredPixel+=cachedFilter[i]*cachedData[i+get_local_id(1)]; } blurredPixel = floor((float4)(ClampToQuantum(blurredPixel.x), ClampToQuantum(blurredPixel.y) ,ClampToQuantum(blurredPixel.z), ClampToQuantum(blurredPixel.w))); float4 inputImagePixel = convert_float4(inputImage[cy*imageColumns+groupX]); float4 outputPixel = inputImagePixel - blurredPixel; float quantumThreshold = QuantumRange*threshold; int4 mask = isless(fabs(2.0f*outputPixel), (float4)quantumThreshold); outputPixel = select(inputImagePixel + outputPixel * gain, inputImagePixel, mask); filtered_im[cy*imageColumns+groupX] = (CLPixelType) (ClampToQuantum(outputPixel.x), ClampToQuantum(outputPixel.y) ,ClampToQuantum(outputPixel.z), ClampToQuantum(outputPixel.w)); } } __kernel void UnsharpMaskBlurColumnSection(const __global CLPixelType* inputImage, const __global float4 *blurRowData, __global CLPixelType *filtered_im, const unsigned int imageColumns, const unsigned int imageRows, __local float4* cachedData, __local float* cachedFilter, const ChannelType channel, const __global float *filter, const unsigned int width, const float gain, const float threshold, const unsigned int offsetRows, const unsigned int section) { const unsigned int radius = (width-1)/2; const int groupX = get_group_id(0); const int groupStartY = get_group_id(1)*get_local_size(1) - radius; const int groupStopY = (get_group_id(1)+1)*get_local_size(1) + radius; blurRowData += imageColumns * radius * section; if (groupStartY >= 0 && groupStopY < imageRows) { event_t e = async_work_group_strided_copy(cachedData ,blurRowData+groupStartY*imageColumns+groupX ,groupStopY-groupStartY,imageColumns,0); wait_group_events(1,&e); } else { for (int i = get_local_id(1); i < (groupStopY - groupStartY); i+=get_local_size(1)) { int pos = ClampToCanvasWithHalo(groupStartY+i,imageRows, radius, section)*imageColumns+ groupX; cachedData[i] = *(blurRowData + pos); } barrier(CLK_LOCAL_MEM_FENCE); } event_t e = async_work_group_copy(cachedFilter,filter,width,0); wait_group_events(1,&e); const int cy = get_global_id(1); if (cy < imageRows) { float4 blurredPixel = (float4) 0.0f; int i = 0; 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ~~ ^ ~~~~~~~~~
<program source>:82:20: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
 for ( ; i+UFACTOR < width; ) { 
         ~~~~~~~~~ ^ ~~~~~
<program source>:84:116: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
 for (int j=0; j < UFACTOR; j++, i++) { blurredPixel+=cachedFilter[i]*cachedData[i+get_local_id(1)]; } } for ( ; i < width; i++) { blurredPixel+=cachedFilter[i]*cachedData[i+get_local_id(1)]; } blurredPixel = floor((float4)(ClampToQuantum(blurredPixel.x), ClampToQuantum(blurredPixel.y) ,ClampToQuantum(blurredPixel.z), ClampToQuantum(blurredPixel.w))); inputImage += imageColumns * offsetRows; filtered_im += imageColumns * offsetRows; float4 inputImagePixel = convert_float4(inputImage[cy*imageColumns+groupX]); float4 outputPixel = inputImagePixel - blurredPixel; float quantumThreshold = QuantumRange*threshold; int4 mask = isless(fabs(2.0f*outputPixel), (float4)quantumThreshold); outputPixel = select(inputImagePixel + outputPixel * gain, inputImagePixel, mask); filtered_im[cy*imageColumns+groupX] = (CLPixelType) (ClampToQuantum(outputPixel.x), ClampToQuantum(outputPixel.y) ,ClampToQuantum(outputPixel.z), ClampToQuantum(outputPixel.w)); } }
                                                                                                                 ~ ^ ~~~~~
<program source>:85:626: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void UnsharpMask(__global CLPixelType *im, __global CLPixelType *filtered_im, __constant float *filter, const unsigned int width, const unsigned int imageColumns, const unsigned int imageRows, __local float4 *pixels, const float gain, const float threshold, const unsigned int justBlur) { const int x = get_global_id(0); const int y = get_global_id(1); const unsigned int radius = (width - 1) / 2; int row = y - radius; int baseRow = get_group_id(1) * get_local_size(1) - radius; int endRow = (get_group_id(1) + 1) * get_local_size(1) + radius; while (row < endRow) { int srcy = (row < 0) ? -row : row; srcy = (srcy >= imageRows) ? (2 * imageRows - srcy - 1) : srcy; float4 value = 0.0f; int ix = x - radius; int i = 0; while (i + 7 < width) { for (int j = 0; j < 8; ++j) { int srcx = ix + j; srcx = (srcx < 0) ? -srcx : srcx; srcx = (srcx >= imageColumns) ? (2 * imageColumns - srcx - 1) : srcx; value += filter[i + j] * convert_float4(im[srcx + srcy * imageColumns]); } ix += 8; i += 8; } while (i < width) { int srcx = (ix < 0) ? -ix : ix; srcx = (srcx >= imageColumns) ? (2 * imageColumns - srcx - 1) : srcx; value += filter[i] * convert_float4(im[srcx + srcy * imageColumns]); ++i; ++ix; } pixels[(row - baseRow) * get_local_size(0) + get_local_id(0)] = value; row += get_local_size(1); } barrier(CLK_LOCAL_MEM_FENCE); const int px = get_local_id(0); const int py = get_local_id(1); const int prp = get_local_size(0); float4 value = (float4)(0.0f); int i = 0; while (i + 7 < width) { value += (float4)(filter[i]) * pixels[px + (py + i) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 1) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 2) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 3) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 4) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 5) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 6) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 7) * prp]; i += 8; } while (i < width) { value += (float4)(filter[i]) * pixels[px + (py + i) * prp]; ++i; } if (justBlur == 0) { float4 srcPixel = convert_float4(im[x + y * imageColumns]); float4 diff = srcPixel - value; float quantumThreshold = QuantumRange*threshold; int4 mask = isless(fabs(2.0f * diff), (float4)quantumThreshold); value = select(srcPixel + diff * gain, srcPixel, mask); } if ((x < imageColumns) && (y < imageRows)) filtered_im[x + y * imageColumns] = (CLPixelType)(ClampToQuantum(value.s0), ClampToQuantum(value.s1), ClampToQuantum(value.s2), ClampToQuantum(value.s3)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ~~~~ ^  ~~~~~~~~~
<program source>:85:743: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void UnsharpMask(__global CLPixelType *im, __global CLPixelType *filtered_im, __constant float *filter, const unsigned int width, const unsigned int imageColumns, const unsigned int imageRows, __local float4 *pixels, const float gain, const float threshold, const unsigned int justBlur) { const int x = get_global_id(0); const int y = get_global_id(1); const unsigned int radius = (width - 1) / 2; int row = y - radius; int baseRow = get_group_id(1) * get_local_size(1) - radius; int endRow = (get_group_id(1) + 1) * get_local_size(1) + radius; while (row < endRow) { int srcy = (row < 0) ? -row : row; srcy = (srcy >= imageRows) ? (2 * imageRows - srcy - 1) : srcy; float4 value = 0.0f; int ix = x - radius; int i = 0; while (i + 7 < width) { for (int j = 0; j < 8; ++j) { int srcx = ix + j; srcx = (srcx < 0) ? -srcx : srcx; srcx = (srcx >= imageColumns) ? (2 * imageColumns - srcx - 1) : srcx; value += filter[i + j] * convert_float4(im[srcx + srcy * imageColumns]); } ix += 8; i += 8; } while (i < width) { int srcx = (ix < 0) ? -ix : ix; srcx = (srcx >= imageColumns) ? (2 * imageColumns - srcx - 1) : srcx; value += filter[i] * convert_float4(im[srcx + srcy * imageColumns]); ++i; ++ix; } pixels[(row - baseRow) * get_local_size(0) + get_local_id(0)] = value; row += get_local_size(1); } barrier(CLK_LOCAL_MEM_FENCE); const int px = get_local_id(0); const int py = get_local_id(1); const int prp = get_local_size(0); float4 value = (float4)(0.0f); int i = 0; while (i + 7 < width) { value += (float4)(filter[i]) * pixels[px + (py + i) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 1) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 2) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 3) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 4) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 5) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 6) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 7) * prp]; i += 8; } while (i < width) { value += (float4)(filter[i]) * pixels[px + (py + i) * prp]; ++i; } if (justBlur == 0) { float4 srcPixel = convert_float4(im[x + y * imageColumns]); float4 diff = srcPixel - value; float quantumThreshold = QuantumRange*threshold; int4 mask = isless(fabs(2.0f * diff), (float4)quantumThreshold); value = select(srcPixel + diff * gain, srcPixel, mask); } if ((x < imageColumns) && (y < imageRows)) filtered_im[x + y * imageColumns] = (CLPixelType)(ClampToQuantum(value.s0), ClampToQuantum(value.s1), ClampToQuantum(value.s2), ClampToQuantum(value.s3)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ~~~~~ ^ ~~~~~
<program source>:85:850: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void UnsharpMask(__global CLPixelType *im, __global CLPixelType *filtered_im, __constant float *filter, const unsigned int width, const unsigned int imageColumns, const unsigned int imageRows, __local float4 *pixels, const float gain, const float threshold, const unsigned int justBlur) { const int x = get_global_id(0); const int y = get_global_id(1); const unsigned int radius = (width - 1) / 2; int row = y - radius; int baseRow = get_group_id(1) * get_local_size(1) - radius; int endRow = (get_group_id(1) + 1) * get_local_size(1) + radius; while (row < endRow) { int srcy = (row < 0) ? -row : row; srcy = (srcy >= imageRows) ? (2 * imageRows - srcy - 1) : srcy; float4 value = 0.0f; int ix = x - radius; int i = 0; while (i + 7 < width) { for (int j = 0; j < 8; ++j) { int srcx = ix + j; srcx = (srcx < 0) ? -srcx : srcx; srcx = (srcx >= imageColumns) ? (2 * imageColumns - srcx - 1) : srcx; value += filter[i + j] * convert_float4(im[srcx + srcy * imageColumns]); } ix += 8; i += 8; } while (i < width) { int srcx = (ix < 0) ? -ix : ix; srcx = (srcx >= imageColumns) ? (2 * imageColumns - srcx - 1) : srcx; value += filter[i] * convert_float4(im[srcx + srcy * imageColumns]); ++i; ++ix; } pixels[(row - baseRow) * get_local_size(0) + get_local_id(0)] = value; row += get_local_size(1); } barrier(CLK_LOCAL_MEM_FENCE); const int px = get_local_id(0); const int py = get_local_id(1); const int prp = get_local_size(0); float4 value = (float4)(0.0f); int i = 0; while (i + 7 < width) { value += (float4)(filter[i]) * pixels[px + (py + i) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 1) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 2) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 3) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 4) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 5) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 6) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 7) * prp]; i += 8; } while (i < width) { value += (float4)(filter[i]) * pixels[px + (py + i) * prp]; ++i; } if (justBlur == 0) { float4 srcPixel = convert_float4(im[x + y * imageColumns]); float4 diff = srcPixel - value; float quantumThreshold = QuantumRange*threshold; int4 mask = isless(fabs(2.0f * diff), (float4)quantumThreshold); value = select(srcPixel + diff * gain, srcPixel, mask); } if ((x < imageColumns) && (y < imageRows)) filtered_im[x + y * imageColumns] = (CLPixelType)(ClampToQuantum(value.s0), ClampToQuantum(value.s1), ClampToQuantum(value.s2), ClampToQuantum(value.s3)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ~~~~ ^  ~~~~~~~~~~~~
<program source>:85:1010: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void UnsharpMask(__global CLPixelType *im, __global CLPixelType *filtered_im, __constant float *filter, const unsigned int width, const unsigned int imageColumns, const unsigned int imageRows, __local float4 *pixels, const float gain, const float threshold, const unsigned int justBlur) { const int x = get_global_id(0); const int y = get_global_id(1); const unsigned int radius = (width - 1) / 2; int row = y - radius; int baseRow = get_group_id(1) * get_local_size(1) - radius; int endRow = (get_group_id(1) + 1) * get_local_size(1) + radius; while (row < endRow) { int srcy = (row < 0) ? -row : row; srcy = (srcy >= imageRows) ? (2 * imageRows - srcy - 1) : srcy; float4 value = 0.0f; int ix = x - radius; int i = 0; while (i + 7 < width) { for (int j = 0; j < 8; ++j) { int srcx = ix + j; srcx = (srcx < 0) ? -srcx : srcx; srcx = (srcx >= imageColumns) ? (2 * imageColumns - srcx - 1) : srcx; value += filter[i + j] * convert_float4(im[srcx + srcy * imageColumns]); } ix += 8; i += 8; } while (i < width) { int srcx = (ix < 0) ? -ix : ix; srcx = (srcx >= imageColumns) ? (2 * imageColumns - srcx - 1) : srcx; value += filter[i] * convert_float4(im[srcx + srcy * imageColumns]); ++i; ++ix; } pixels[(row - baseRow) * get_local_size(0) + get_local_id(0)] = value; row += get_local_size(1); } barrier(CLK_LOCAL_MEM_FENCE); const int px = get_local_id(0); const int py = get_local_id(1); const int prp = get_local_size(0); float4 value = (float4)(0.0f); int i = 0; while (i + 7 < width) { value += (float4)(filter[i]) * pixels[px + (py + i) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 1) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 2) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 3) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 4) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 5) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 6) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 7) * prp]; i += 8; } while (i < width) { value += (float4)(filter[i]) * pixels[px + (py + i) * prp]; ++i; } if (justBlur == 0) { float4 srcPixel = convert_float4(im[x + y * imageColumns]); float4 diff = srcPixel - value; float quantumThreshold = QuantumRange*threshold; int4 mask = isless(fabs(2.0f * diff), (float4)quantumThreshold); value = select(srcPixel + diff * gain, srcPixel, mask); } if ((x < imageColumns) && (y < imageRows)) filtered_im[x + y * imageColumns] = (CLPixelType)(ClampToQuantum(value.s0), ClampToQuantum(value.s1), ClampToQuantum(value.s2), ClampToQuantum(value.s3)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ~ ^ ~~~~~
<program source>:85:1066: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void UnsharpMask(__global CLPixelType *im, __global CLPixelType *filtered_im, __constant float *filter, const unsigned int width, const unsigned int imageColumns, const unsigned int imageRows, __local float4 *pixels, const float gain, const float threshold, const unsigned int justBlur) { const int x = get_global_id(0); const int y = get_global_id(1); const unsigned int radius = (width - 1) / 2; int row = y - radius; int baseRow = get_group_id(1) * get_local_size(1) - radius; int endRow = (get_group_id(1) + 1) * get_local_size(1) + radius; while (row < endRow) { int srcy = (row < 0) ? -row : row; srcy = (srcy >= imageRows) ? (2 * imageRows - srcy - 1) : srcy; float4 value = 0.0f; int ix = x - radius; int i = 0; while (i + 7 < width) { for (int j = 0; j < 8; ++j) { int srcx = ix + j; srcx = (srcx < 0) ? -srcx : srcx; srcx = (srcx >= imageColumns) ? (2 * imageColumns - srcx - 1) : srcx; value += filter[i + j] * convert_float4(im[srcx + srcy * imageColumns]); } ix += 8; i += 8; } while (i < width) { int srcx = (ix < 0) ? -ix : ix; srcx = (srcx >= imageColumns) ? (2 * imageColumns - srcx - 1) : srcx; value += filter[i] * convert_float4(im[srcx + srcy * imageColumns]); ++i; ++ix; } pixels[(row - baseRow) * get_local_size(0) + get_local_id(0)] = value; row += get_local_size(1); } barrier(CLK_LOCAL_MEM_FENCE); const int px = get_local_id(0); const int py = get_local_id(1); const int prp = get_local_size(0); float4 value = (float4)(0.0f); int i = 0; while (i + 7 < width) { value += (float4)(filter[i]) * pixels[px + (py + i) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 1) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 2) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 3) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 4) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 5) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 6) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 7) * prp]; i += 8; } while (i < width) { value += (float4)(filter[i]) * pixels[px + (py + i) * prp]; ++i; } if (justBlur == 0) { float4 srcPixel = convert_float4(im[x + y * imageColumns]); float4 diff = srcPixel - value; float quantumThreshold = QuantumRange*threshold; int4 mask = isless(fabs(2.0f * diff), (float4)quantumThreshold); value = select(srcPixel + diff * gain, srcPixel, mask); } if ((x < imageColumns) && (y < imageRows)) filtered_im[x + y * imageColumns] = (CLPixelType)(ClampToQuantum(value.s0), ClampToQuantum(value.s1), ClampToQuantum(value.s2), ClampToQuantum(value.s3)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ~~~~ ^  ~~~~~~~~~~~~
<program source>:85:1488: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void UnsharpMask(__global CLPixelType *im, __global CLPixelType *filtered_im, __constant float *filter, const unsigned int width, const unsigned int imageColumns, const unsigned int imageRows, __local float4 *pixels, const float gain, const float threshold, const unsigned int justBlur) { const int x = get_global_id(0); const int y = get_global_id(1); const unsigned int radius = (width - 1) / 2; int row = y - radius; int baseRow = get_group_id(1) * get_local_size(1) - radius; int endRow = (get_group_id(1) + 1) * get_local_size(1) + radius; while (row < endRow) { int srcy = (row < 0) ? -row : row; srcy = (srcy >= imageRows) ? (2 * imageRows - srcy - 1) : srcy; float4 value = 0.0f; int ix = x - radius; int i = 0; while (i + 7 < width) { for (int j = 0; j < 8; ++j) { int srcx = ix + j; srcx = (srcx < 0) ? -srcx : srcx; srcx = (srcx >= imageColumns) ? (2 * imageColumns - srcx - 1) : srcx; value += filter[i + j] * convert_float4(im[srcx + srcy * imageColumns]); } ix += 8; i += 8; } while (i < width) { int srcx = (ix < 0) ? -ix : ix; srcx = (srcx >= imageColumns) ? (2 * imageColumns - srcx - 1) : srcx; value += filter[i] * convert_float4(im[srcx + srcy * imageColumns]); ++i; ++ix; } pixels[(row - baseRow) * get_local_size(0) + get_local_id(0)] = value; row += get_local_size(1); } barrier(CLK_LOCAL_MEM_FENCE); const int px = get_local_id(0); const int py = get_local_id(1); const int prp = get_local_size(0); float4 value = (float4)(0.0f); int i = 0; while (i + 7 < width) { value += (float4)(filter[i]) * pixels[px + (py + i) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 1) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 2) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 3) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 4) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 5) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 6) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 7) * prp]; i += 8; } while (i < width) { value += (float4)(filter[i]) * pixels[px + (py + i) * prp]; ++i; } if (justBlur == 0) { float4 srcPixel = convert_float4(im[x + y * imageColumns]); float4 diff = srcPixel - value; float quantumThreshold = QuantumRange*threshold; int4 mask = isless(fabs(2.0f * diff), (float4)quantumThreshold); value = select(srcPixel + diff * gain, srcPixel, mask); } if ((x < imageColumns) && (y < imageRows)) filtered_im[x + y * imageColumns] = (CLPixelType)(ClampToQuantum(value.s0), ClampToQuantum(value.s1), ClampToQuantum(value.s2), ClampToQuantum(value.s3)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ~~~~~ ^ ~~~~~
<program source>:85:2026: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void UnsharpMask(__global CLPixelType *im, __global CLPixelType *filtered_im, __constant float *filter, const unsigned int width, const unsigned int imageColumns, const unsigned int imageRows, __local float4 *pixels, const float gain, const float threshold, const unsigned int justBlur) { const int x = get_global_id(0); const int y = get_global_id(1); const unsigned int radius = (width - 1) / 2; int row = y - radius; int baseRow = get_group_id(1) * get_local_size(1) - radius; int endRow = (get_group_id(1) + 1) * get_local_size(1) + radius; while (row < endRow) { int srcy = (row < 0) ? -row : row; srcy = (srcy >= imageRows) ? (2 * imageRows - srcy - 1) : srcy; float4 value = 0.0f; int ix = x - radius; int i = 0; while (i + 7 < width) { for (int j = 0; j < 8; ++j) { int srcx = ix + j; srcx = (srcx < 0) ? -srcx : srcx; srcx = (srcx >= imageColumns) ? (2 * imageColumns - srcx - 1) : srcx; value += filter[i + j] * convert_float4(im[srcx + srcy * imageColumns]); } ix += 8; i += 8; } while (i < width) { int srcx = (ix < 0) ? -ix : ix; srcx = (srcx >= imageColumns) ? (2 * imageColumns - srcx - 1) : srcx; value += filter[i] * convert_float4(im[srcx + srcy * imageColumns]); ++i; ++ix; } pixels[(row - baseRow) * get_local_size(0) + get_local_id(0)] = value; row += get_local_size(1); } barrier(CLK_LOCAL_MEM_FENCE); const int px = get_local_id(0); const int py = get_local_id(1); const int prp = get_local_size(0); float4 value = (float4)(0.0f); int i = 0; while (i + 7 < width) { value += (float4)(filter[i]) * pixels[px + (py + i) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 1) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 2) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 3) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 4) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 5) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 6) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 7) * prp]; i += 8; } while (i < width) { value += (float4)(filter[i]) * pixels[px + (py + i) * prp]; ++i; } if (justBlur == 0) { float4 srcPixel = convert_float4(im[x + y * imageColumns]); float4 diff = srcPixel - value; float quantumThreshold = QuantumRange*threshold; int4 mask = isless(fabs(2.0f * diff), (float4)quantumThreshold); value = select(srcPixel + diff * gain, srcPixel, mask); } if ((x < imageColumns) && (y < imageRows)) filtered_im[x + y * imageColumns] = (CLPixelType)(ClampToQuantum(value.s0), ClampToQuantum(value.s1), ClampToQuantum(value.s2), ClampToQuantum(value.s3)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ~ ^ ~~~~~
<program source>:85:2396: warning: comparison of integers of different signs: 'const int' and 'const unsigned int'
__kernel void UnsharpMask(__global CLPixelType *im, __global CLPixelType *filtered_im, __constant float *filter, const unsigned int width, const unsigned int imageColumns, const unsigned int imageRows, __local float4 *pixels, const float gain, const float threshold, const unsigned int justBlur) { const int x = get_global_id(0); const int y = get_global_id(1); const unsigned int radius = (width - 1) / 2; int row = y - radius; int baseRow = get_group_id(1) * get_local_size(1) - radius; int endRow = (get_group_id(1) + 1) * get_local_size(1) + radius; while (row < endRow) { int srcy = (row < 0) ? -row : row; srcy = (srcy >= imageRows) ? (2 * imageRows - srcy - 1) : srcy; float4 value = 0.0f; int ix = x - radius; int i = 0; while (i + 7 < width) { for (int j = 0; j < 8; ++j) { int srcx = ix + j; srcx = (srcx < 0) ? -srcx : srcx; srcx = (srcx >= imageColumns) ? (2 * imageColumns - srcx - 1) : srcx; value += filter[i + j] * convert_float4(im[srcx + srcy * imageColumns]); } ix += 8; i += 8; } while (i < width) { int srcx = (ix < 0) ? -ix : ix; srcx = (srcx >= imageColumns) ? (2 * imageColumns - srcx - 1) : srcx; value += filter[i] * convert_float4(im[srcx + srcy * imageColumns]); ++i; ++ix; } pixels[(row - baseRow) * get_local_size(0) + get_local_id(0)] = value; row += get_local_size(1); } barrier(CLK_LOCAL_MEM_FENCE); const int px = get_local_id(0); const int py = get_local_id(1); const int prp = get_local_size(0); float4 value = (float4)(0.0f); int i = 0; while (i + 7 < width) { value += (float4)(filter[i]) * pixels[px + (py + i) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 1) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 2) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 3) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 4) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 5) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 6) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 7) * prp]; i += 8; } while (i < width) { value += (float4)(filter[i]) * pixels[px + (py + i) * prp]; ++i; } if (justBlur == 0) { float4 srcPixel = convert_float4(im[x + y * imageColumns]); float4 diff = srcPixel - value; float quantumThreshold = QuantumRange*threshold; int4 mask = isless(fabs(2.0f * diff), (float4)quantumThreshold); value = select(srcPixel + diff * gain, srcPixel, mask); } if ((x < imageColumns) && (y < imageRows)) filtered_im[x + y * imageColumns] = (CLPixelType)(ClampToQuantum(value.s0), ClampToQuantum(value.s1), ClampToQuantum(value.s2), ClampToQuantum(value.s3)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ~ ^ ~~~~~~~~~~~~
<program source>:85:2418: warning: comparison of integers of different signs: 'const int' and 'const unsigned int'
__kernel void UnsharpMask(__global CLPixelType *im, __global CLPixelType *filtered_im, __constant float *filter, const unsigned int width, const unsigned int imageColumns, const unsigned int imageRows, __local float4 *pixels, const float gain, const float threshold, const unsigned int justBlur) { const int x = get_global_id(0); const int y = get_global_id(1); const unsigned int radius = (width - 1) / 2; int row = y - radius; int baseRow = get_group_id(1) * get_local_size(1) - radius; int endRow = (get_group_id(1) + 1) * get_local_size(1) + radius; while (row < endRow) { int srcy = (row < 0) ? -row : row; srcy = (srcy >= imageRows) ? (2 * imageRows - srcy - 1) : srcy; float4 value = 0.0f; int ix = x - radius; int i = 0; while (i + 7 < width) { for (int j = 0; j < 8; ++j) { int srcx = ix + j; srcx = (srcx < 0) ? -srcx : srcx; srcx = (srcx >= imageColumns) ? (2 * imageColumns - srcx - 1) : srcx; value += filter[i + j] * convert_float4(im[srcx + srcy * imageColumns]); } ix += 8; i += 8; } while (i < width) { int srcx = (ix < 0) ? -ix : ix; srcx = (srcx >= imageColumns) ? (2 * imageColumns - srcx - 1) : srcx; value += filter[i] * convert_float4(im[srcx + srcy * imageColumns]); ++i; ++ix; } pixels[(row - baseRow) * get_local_size(0) + get_local_id(0)] = value; row += get_local_size(1); } barrier(CLK_LOCAL_MEM_FENCE); const int px = get_local_id(0); const int py = get_local_id(1); const int prp = get_local_size(0); float4 value = (float4)(0.0f); int i = 0; while (i + 7 < width) { value += (float4)(filter[i]) * pixels[px + (py + i) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 1) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 2) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 3) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 4) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 5) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 6) * prp]; value += (float4)(filter[i]) * pixels[px + (py + i + 7) * prp]; i += 8; } while (i < width) { value += (float4)(filter[i]) * pixels[px + (py + i) * prp]; ++i; } if (justBlur == 0) { float4 srcPixel = convert_float4(im[x + y * imageColumns]); float4 diff = srcPixel - value; float quantumThreshold = QuantumRange*threshold; int4 mask = isless(fabs(2.0f * diff), (float4)quantumThreshold); value = select(srcPixel + diff * gain, srcPixel, mask); } if ((x < imageColumns) && (y < imageRows)) filtered_im[x + y * imageColumns] = (CLPixelType)(ClampToQuantum(value.s0), ClampToQuantum(value.s1), ClampToQuantum(value.s2), ClampToQuantum(value.s3)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ~ ^ ~~~~~~~~~
<program source>:98:192: error: call to 'max' is ambiguous
inline void ConvertRGBToHSL(const CLQuantum red,const CLQuantum green, const CLQuantum blue, float *hue, float *saturation, float *lightness) { float c, tmax, tmin; tmax=max(QuantumScale*red,max(QuantumScale*green, QuantumScale*blue)); tmin=min(QuantumScale*red,min(QuantumScale*green, QuantumScale*blue)); c=tmax-tmin; *lightness=(tmax+tmin)/2.0; if (c <= 0.0) { *hue=0.0; *saturation=0.0; return; } if (tmax == (QuantumScale*red)) { *hue=(QuantumScale*green-QuantumScale*blue)/c; if ((QuantumScale*green) < (QuantumScale*blue)) *hue+=6.0; } else if (tmax == (QuantumScale*green)) *hue=2.0+(QuantumScale*blue-QuantumScale*red)/c; else *hue=4.0+(QuantumScale*red-QuantumScale*green)/c; *hue*=60.0/360.0; if (*lightness <= 0.5) *saturation=c/(2.0*(*lightness)); else *saturation=c/(2.0-2.0*(*lightness)); } inline void ConvertHSLToRGB(const float hue,const float saturation, const float lightness, CLQuantum *red,CLQuantum *green,CLQuantum *blue) { float b, c, g, h, tmin, r, x; h=hue*360.0; if (lightness <= 0.5) c=2.0*lightness*saturation; else c=(2.0-2.0*lightness)*saturation; tmin=lightness-0.5*c; h-=360.0*floor(h/360.0); h/=60.0; x=c*(1.0-fabs(h-2.0*floor(h/2.0)-1.0)); switch ((int) floor(h)) { case 0: { r=tmin+c; g=tmin+x; b=tmin; break; } case 1: { r=tmin+x; g=tmin+c; b=tmin; break; } case 2: { r=tmin; g=tmin+c; b=tmin+x; break; } case 3: { r=tmin; g=tmin+x; b=tmin+c; break; } case 4: { r=tmin+x; g=tmin; b=tmin+c; break; } case 5: { r=tmin+c; g=tmin; b=tmin+x; break; } default: { r=0.0; g=0.0; b=0.0; } } *red=ClampToQuantum(QuantumRange*r); *green=ClampToQuantum(QuantumRange*g); *blue=ClampToQuantum(QuantumRange*b); } inline void ModulateHSL(const float percent_hue, const float percent_saturation,const float percent_lightness, CLQuantum *red,CLQuantum *green,CLQuantum *blue) { float hue, lightness, saturation; ConvertRGBToHSL(*red,*green,*blue,&hue,&saturation,&lightness); hue+=0.5*(0.01*percent_hue-1.0); while (hue < 0.0) hue+=1.0; while (hue >= 1.0) hue-=1.0; saturation*=0.01*percent_saturation; lightness*=0.01*percent_lightness; ConvertHSLToRGB(hue,saturation,lightness,red,green,blue); } __kernel void Modulate(__global CLPixelType *im, const float percent_brightness, const float percent_hue, const float percent_saturation, const int colorspace) { const int x = get_global_id(0); const int y = get_global_id(1); const int columns = get_global_size(0); const int c = x + y * columns; CLPixelType pixel = im[c]; CLQuantum blue, green, red; red=getRed(pixel); green=getGreen(pixel); blue=getBlue(pixel); switch (colorspace) { case HSLColorspace: default: { ModulateHSL(percent_hue, percent_saturation, percent_brightness, &red, &green, &blue); } } CLPixelType filteredPixel; setRed(&filteredPixel, red); setGreen(&filteredPixel, green); setBlue(&filteredPixel, blue); filteredPixel.w = pixel.w; im[c] = filteredPixel; }
                                                                                                                                                                                               ^~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1181:20: note: expanded from macro '__CLFN_ALL'
char2 __OVERLOAD__ name(char2 x, char2 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1182:20: note: expanded from macro '__CLFN_ALL'
char3 __OVERLOAD__ name(char3 x, char3 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1183:20: note: expanded from macro '__CLFN_ALL'
char4 __OVERLOAD__ name(char4 x, char4 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1184:20: note: expanded from macro '__CLFN_ALL'
char8 __OVERLOAD__ name(char8 x, char8 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1185:21: note: expanded from macro '__CLFN_ALL'
char16 __OVERLOAD__ name(char16 x, char16 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1187:21: note: expanded from macro '__CLFN_ALL'
uchar2 __OVERLOAD__ name(uchar2 x, uchar2 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1188:21: note: expanded from macro '__CLFN_ALL'
uchar3 __OVERLOAD__ name(uchar3 x, uchar3 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1189:21: note: expanded from macro '__CLFN_ALL'
uchar4 __OVERLOAD__ name(uchar4 x, uchar4 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1190:21: note: expanded from macro '__CLFN_ALL'
uchar8 __OVERLOAD__ name(uchar8 x, uchar8 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1191:22: note: expanded from macro '__CLFN_ALL'
uchar16 __OVERLOAD__ name(uchar16 x,uchar16 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1193:21: note: expanded from macro '__CLFN_ALL'
short2 __OVERLOAD__ name(short2 x, short2 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1194:21: note: expanded from macro '__CLFN_ALL'
short3 __OVERLOAD__ name(short3 x, short3 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1195:21: note: expanded from macro '__CLFN_ALL'
short4 __OVERLOAD__ name(short4 x, short4 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1196:21: note: expanded from macro '__CLFN_ALL'
short8 __OVERLOAD__ name(short8 x, short8 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1197:22: note: expanded from macro '__CLFN_ALL'
short16 __OVERLOAD__ name(short16 x, short16 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1199:22: note: expanded from macro '__CLFN_ALL'
ushort2 __OVERLOAD__ name(ushort2 x, ushort2 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1200:22: note: expanded from macro '__CLFN_ALL'
ushort3 __OVERLOAD__ name(ushort3 x, ushort3 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1201:22: note: expanded from macro '__CLFN_ALL'
ushort4 __OVERLOAD__ name(ushort4 x, ushort4 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1202:22: note: expanded from macro '__CLFN_ALL'
ushort8 __OVERLOAD__ name(ushort8 x, ushort8 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1203:23: note: expanded from macro '__CLFN_ALL'
ushort16 __OVERLOAD__ name(ushort16 x, ushort16 y); \
                      ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1205:19: note: expanded from macro '__CLFN_ALL'
int2 __OVERLOAD__ name(int2 x, int2 y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1206:19: note: expanded from macro '__CLFN_ALL'
int3 __OVERLOAD__ name(int3 x, int3 y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1207:19: note: expanded from macro '__CLFN_ALL'
int4 __OVERLOAD__ name(int4 x, int4 y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1208:19: note: expanded from macro '__CLFN_ALL'
int8 __OVERLOAD__ name(int8 x, int8 y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1209:20: note: expanded from macro '__CLFN_ALL'
int16 __OVERLOAD__ name(int16 x, int16 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1211:20: note: expanded from macro '__CLFN_ALL'
uint2 __OVERLOAD__ name(uint2 x, uint2 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1212:20: note: expanded from macro '__CLFN_ALL'
uint3 __OVERLOAD__ name(uint3 x, uint3 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1213:20: note: expanded from macro '__CLFN_ALL'
uint4 __OVERLOAD__ name(uint4 x, uint4 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1214:20: note: expanded from macro '__CLFN_ALL'
uint8 __OVERLOAD__ name(uint8 x, uint8 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1215:21: note: expanded from macro '__CLFN_ALL'
uint16 __OVERLOAD__ name(uint16 x, uint16 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1217:20: note: expanded from macro '__CLFN_ALL'
long2 __OVERLOAD__ name(long2 x, long2 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1218:20: note: expanded from macro '__CLFN_ALL'
long3 __OVERLOAD__ name(long3 x, long3 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1219:20: note: expanded from macro '__CLFN_ALL'
long4 __OVERLOAD__ name(long4 x, long4 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1220:20: note: expanded from macro '__CLFN_ALL'
long8 __OVERLOAD__ name(long8 x, long8 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1221:21: note: expanded from macro '__CLFN_ALL'
long16 __OVERLOAD__ name(long16 x, long16 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1223:21: note: expanded from macro '__CLFN_ALL'
ulong2 __OVERLOAD__ name(ulong2 x, ulong2 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1224:21: note: expanded from macro '__CLFN_ALL'
ulong3 __OVERLOAD__ name(ulong3 x, ulong3 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1225:21: note: expanded from macro '__CLFN_ALL'
ulong4 __OVERLOAD__ name(ulong4 x, ulong4 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1226:21: note: expanded from macro '__CLFN_ALL'
ulong8 __OVERLOAD__ name(ulong8 x, ulong8 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1227:22: note: expanded from macro '__CLFN_ALL'
ulong16 __OVERLOAD__ name(ulong16 x, ulong16 y); 
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1291:49: note: expanded from macro '__CLFN_ALL_MODD'
#define __CLFN_ALL_MODD(name) char __OVERLOAD__ name(char x, char y); \
                                                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1292:20: note: expanded from macro '__CLFN_ALL_MODD'
char2 __OVERLOAD__ name(char2 x, char y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1293:20: note: expanded from macro '__CLFN_ALL_MODD'
char3 __OVERLOAD__ name(char3 x, char y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1294:20: note: expanded from macro '__CLFN_ALL_MODD'
char4 __OVERLOAD__ name(char4 x, char y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1295:20: note: expanded from macro '__CLFN_ALL_MODD'
char8 __OVERLOAD__ name(char8 x, char y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1296:21: note: expanded from macro '__CLFN_ALL_MODD'
char16 __OVERLOAD__ name(char16 x, char y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1297:20: note: expanded from macro '__CLFN_ALL_MODD'
uchar __OVERLOAD__ name(uchar x, uchar y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1298:21: note: expanded from macro '__CLFN_ALL_MODD'
uchar2 __OVERLOAD__ name(uchar2 x, uchar y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1299:21: note: expanded from macro '__CLFN_ALL_MODD'
uchar3 __OVERLOAD__ name(uchar3 x, uchar y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1300:21: note: expanded from macro '__CLFN_ALL_MODD'
uchar4 __OVERLOAD__ name(uchar4 x, uchar y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1301:21: note: expanded from macro '__CLFN_ALL_MODD'
uchar8 __OVERLOAD__ name(uchar8 x, uchar y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1302:22: note: expanded from macro '__CLFN_ALL_MODD'
uchar16 __OVERLOAD__ name(uchar16 x,uchar y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1303:20: note: expanded from macro '__CLFN_ALL_MODD'
short __OVERLOAD__ name(short x, short y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1304:21: note: expanded from macro '__CLFN_ALL_MODD'
short2 __OVERLOAD__ name(short2 x, short y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1305:21: note: expanded from macro '__CLFN_ALL_MODD'
short3 __OVERLOAD__ name(short3 x, short y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1306:21: note: expanded from macro '__CLFN_ALL_MODD'
short4 __OVERLOAD__ name(short4 x, short y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1307:21: note: expanded from macro '__CLFN_ALL_MODD'
short8 __OVERLOAD__ name(short8 x, short y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1308:22: note: expanded from macro '__CLFN_ALL_MODD'
short16 __OVERLOAD__ name(short16 x, short y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1309:21: note: expanded from macro '__CLFN_ALL_MODD'
ushort __OVERLOAD__ name(ushort x, ushort y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1310:22: note: expanded from macro '__CLFN_ALL_MODD'
ushort2 __OVERLOAD__ name(ushort2 x, ushort y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1311:22: note: expanded from macro '__CLFN_ALL_MODD'
ushort3 __OVERLOAD__ name(ushort3 x, ushort y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1312:22: note: expanded from macro '__CLFN_ALL_MODD'
ushort4 __OVERLOAD__ name(ushort4 x, ushort y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1313:22: note: expanded from macro '__CLFN_ALL_MODD'
ushort8 __OVERLOAD__ name(ushort8 x, ushort y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1314:23: note: expanded from macro '__CLFN_ALL_MODD'
ushort16 __OVERLOAD__ name(ushort16 x, ushort y); \
                      ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1315:18: note: expanded from macro '__CLFN_ALL_MODD'
int __OVERLOAD__ name(int x, int y); \
                 ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1316:19: note: expanded from macro '__CLFN_ALL_MODD'
int2 __OVERLOAD__ name(int2 x, int y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1317:19: note: expanded from macro '__CLFN_ALL_MODD'
int3 __OVERLOAD__ name(int3 x, int y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1318:19: note: expanded from macro '__CLFN_ALL_MODD'
int4 __OVERLOAD__ name(int4 x, int y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1319:19: note: expanded from macro '__CLFN_ALL_MODD'
int8 __OVERLOAD__ name(int8 x, int y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1320:20: note: expanded from macro '__CLFN_ALL_MODD'
int16 __OVERLOAD__ name(int16 x, int y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1321:19: note: expanded from macro '__CLFN_ALL_MODD'
uint __OVERLOAD__ name(uint x, uint y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1322:20: note: expanded from macro '__CLFN_ALL_MODD'
uint2 __OVERLOAD__ name(uint2 x, uint y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1323:20: note: expanded from macro '__CLFN_ALL_MODD'
uint3 __OVERLOAD__ name(uint3 x, uint y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1324:20: note: expanded from macro '__CLFN_ALL_MODD'
uint4 __OVERLOAD__ name(uint4 x, uint y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1325:20: note: expanded from macro '__CLFN_ALL_MODD'
uint8 __OVERLOAD__ name(uint8 x, uint y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1326:21: note: expanded from macro '__CLFN_ALL_MODD'
uint16 __OVERLOAD__ name(uint16 x, uint y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1327:19: note: expanded from macro '__CLFN_ALL_MODD'
long __OVERLOAD__ name(long x, long y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1328:20: note: expanded from macro '__CLFN_ALL_MODD'
long2 __OVERLOAD__ name(long2 x, long y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1329:20: note: expanded from macro '__CLFN_ALL_MODD'
long3 __OVERLOAD__ name(long3 x, long y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1330:20: note: expanded from macro '__CLFN_ALL_MODD'
long4 __OVERLOAD__ name(long4 x, long y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1331:20: note: expanded from macro '__CLFN_ALL_MODD'
long8 __OVERLOAD__ name(long8 x, long y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1332:21: note: expanded from macro '__CLFN_ALL_MODD'
long16 __OVERLOAD__ name(long16 x, long y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1333:20: note: expanded from macro '__CLFN_ALL_MODD'
ulong __OVERLOAD__ name(ulong x, ulong y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1334:21: note: expanded from macro '__CLFN_ALL_MODD'
ulong2 __OVERLOAD__ name(ulong2 x, ulong y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1335:21: note: expanded from macro '__CLFN_ALL_MODD'
ulong3 __OVERLOAD__ name(ulong3 x, ulong y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1336:21: note: expanded from macro '__CLFN_ALL_MODD'
ulong4 __OVERLOAD__ name(ulong4 x, ulong y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1337:21: note: expanded from macro '__CLFN_ALL_MODD'
ulong8 __OVERLOAD__ name(ulong8 x, ulong y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1338:22: note: expanded from macro '__CLFN_ALL_MODD'
ulong16 __OVERLOAD__ name(ulong16 x, ulong y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1340:21: note: expanded from macro '__CLFN_ALL_MODD'
float2 __OVERLOAD__ name(float2 x, float y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1341:21: note: expanded from macro '__CLFN_ALL_MODD'
float3 __OVERLOAD__ name(float3 x, float y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1342:21: note: expanded from macro '__CLFN_ALL_MODD'
float4 __OVERLOAD__ name(float4 x, float y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1343:21: note: expanded from macro '__CLFN_ALL_MODD'
float8 __OVERLOAD__ name(float8 x, float y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1344:22: note: expanded from macro '__CLFN_ALL_MODD'
float16 __OVERLOAD__ name(float16 x, float y);
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4824:15: note: candidate function
__CLFN_FD_2FD(max);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1009:48: note: expanded from macro '__CLFN_FD_2FD'
#define __CLFN_FD_2FD(name) float __OVERLOAD__ name(float x, float y); \
                                               ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4824:15: note: candidate function
__CLFN_FD_2FD(max);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1010:21: note: expanded from macro '__CLFN_FD_2FD'
float2 __OVERLOAD__ name(float2 x, float2 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4824:15: note: candidate function
__CLFN_FD_2FD(max);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1011:21: note: expanded from macro '__CLFN_FD_2FD'
float3 __OVERLOAD__ name(float3 x, float3 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4824:15: note: candidate function
__CLFN_FD_2FD(max);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1012:21: note: expanded from macro '__CLFN_FD_2FD'
float4 __OVERLOAD__ name(float4 x, float4 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4824:15: note: candidate function
__CLFN_FD_2FD(max);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1013:21: note: expanded from macro '__CLFN_FD_2FD'
float8 __OVERLOAD__ name(float8 x, float8 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4824:15: note: candidate function
__CLFN_FD_2FD(max);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1014:22: note: expanded from macro '__CLFN_FD_2FD'
float16 __OVERLOAD__ name(float16 x, float16 y);
                     ^
<program source>:98:263: error: call to 'min' is ambiguous
inline void ConvertRGBToHSL(const CLQuantum red,const CLQuantum green, const CLQuantum blue, float *hue, float *saturation, float *lightness) { float c, tmax, tmin; tmax=max(QuantumScale*red,max(QuantumScale*green, QuantumScale*blue)); tmin=min(QuantumScale*red,min(QuantumScale*green, QuantumScale*blue)); c=tmax-tmin; *lightness=(tmax+tmin)/2.0; if (c <= 0.0) { *hue=0.0; *saturation=0.0; return; } if (tmax == (QuantumScale*red)) { *hue=(QuantumScale*green-QuantumScale*blue)/c; if ((QuantumScale*green) < (QuantumScale*blue)) *hue+=6.0; } else if (tmax == (QuantumScale*green)) *hue=2.0+(QuantumScale*blue-QuantumScale*red)/c; else *hue=4.0+(QuantumScale*red-QuantumScale*green)/c; *hue*=60.0/360.0; if (*lightness <= 0.5) *saturation=c/(2.0*(*lightness)); else *saturation=c/(2.0-2.0*(*lightness)); } inline void ConvertHSLToRGB(const float hue,const float saturation, const float lightness, CLQuantum *red,CLQuantum *green,CLQuantum *blue) { float b, c, g, h, tmin, r, x; h=hue*360.0; if (lightness <= 0.5) c=2.0*lightness*saturation; else c=(2.0-2.0*lightness)*saturation; tmin=lightness-0.5*c; h-=360.0*floor(h/360.0); h/=60.0; x=c*(1.0-fabs(h-2.0*floor(h/2.0)-1.0)); switch ((int) floor(h)) { case 0: { r=tmin+c; g=tmin+x; b=tmin; break; } case 1: { r=tmin+x; g=tmin+c; b=tmin; break; } case 2: { r=tmin; g=tmin+c; b=tmin+x; break; } case 3: { r=tmin; g=tmin+x; b=tmin+c; break; } case 4: { r=tmin+x; g=tmin; b=tmin+c; break; } case 5: { r=tmin+c; g=tmin; b=tmin+x; break; } default: { r=0.0; g=0.0; b=0.0; } } *red=ClampToQuantum(QuantumRange*r); *green=ClampToQuantum(QuantumRange*g); *blue=ClampToQuantum(QuantumRange*b); } inline void ModulateHSL(const float percent_hue, const float percent_saturation,const float percent_lightness, CLQuantum *red,CLQuantum *green,CLQuantum *blue) { float hue, lightness, saturation; ConvertRGBToHSL(*red,*green,*blue,&hue,&saturation,&lightness); hue+=0.5*(0.01*percent_hue-1.0); while (hue < 0.0) hue+=1.0; while (hue >= 1.0) hue-=1.0; saturation*=0.01*percent_saturation; lightness*=0.01*percent_lightness; ConvertHSLToRGB(hue,saturation,lightness,red,green,blue); } __kernel void Modulate(__global CLPixelType *im, const float percent_brightness, const float percent_hue, const float percent_saturation, const int colorspace) { const int x = get_global_id(0); const int y = get_global_id(1); const int columns = get_global_size(0); const int c = x + y * columns; CLPixelType pixel = im[c]; CLQuantum blue, green, red; red=getRed(pixel); green=getGreen(pixel); blue=getBlue(pixel); switch (colorspace) { case HSLColorspace: default: { ModulateHSL(percent_hue, percent_saturation, percent_brightness, &red, &green, &blue); } } CLPixelType filteredPixel; setRed(&filteredPixel, red); setGreen(&filteredPixel, green); setBlue(&filteredPixel, blue); filteredPixel.w = pixel.w; im[c] = filteredPixel; }
                                                                                                                                                                                                                                                                      ^~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1181:20: note: expanded from macro '__CLFN_ALL'
char2 __OVERLOAD__ name(char2 x, char2 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1182:20: note: expanded from macro '__CLFN_ALL'
char3 __OVERLOAD__ name(char3 x, char3 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1183:20: note: expanded from macro '__CLFN_ALL'
char4 __OVERLOAD__ name(char4 x, char4 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1184:20: note: expanded from macro '__CLFN_ALL'
char8 __OVERLOAD__ name(char8 x, char8 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1185:21: note: expanded from macro '__CLFN_ALL'
char16 __OVERLOAD__ name(char16 x, char16 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1187:21: note: expanded from macro '__CLFN_ALL'
uchar2 __OVERLOAD__ name(uchar2 x, uchar2 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1188:21: note: expanded from macro '__CLFN_ALL'
uchar3 __OVERLOAD__ name(uchar3 x, uchar3 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1189:21: note: expanded from macro '__CLFN_ALL'
uchar4 __OVERLOAD__ name(uchar4 x, uchar4 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1190:21: note: expanded from macro '__CLFN_ALL'
uchar8 __OVERLOAD__ name(uchar8 x, uchar8 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1191:22: note: expanded from macro '__CLFN_ALL'
uchar16 __OVERLOAD__ name(uchar16 x,uchar16 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1193:21: note: expanded from macro '__CLFN_ALL'
short2 __OVERLOAD__ name(short2 x, short2 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1194:21: note: expanded from macro '__CLFN_ALL'
short3 __OVERLOAD__ name(short3 x, short3 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1195:21: note: expanded from macro '__CLFN_ALL'
short4 __OVERLOAD__ name(short4 x, short4 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1196:21: note: expanded from macro '__CLFN_ALL'
short8 __OVERLOAD__ name(short8 x, short8 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1197:22: note: expanded from macro '__CLFN_ALL'
short16 __OVERLOAD__ name(short16 x, short16 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1199:22: note: expanded from macro '__CLFN_ALL'
ushort2 __OVERLOAD__ name(ushort2 x, ushort2 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1200:22: note: expanded from macro '__CLFN_ALL'
ushort3 __OVERLOAD__ name(ushort3 x, ushort3 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1201:22: note: expanded from macro '__CLFN_ALL'
ushort4 __OVERLOAD__ name(ushort4 x, ushort4 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1202:22: note: expanded from macro '__CLFN_ALL'
ushort8 __OVERLOAD__ name(ushort8 x, ushort8 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1203:23: note: expanded from macro '__CLFN_ALL'
ushort16 __OVERLOAD__ name(ushort16 x, ushort16 y); \
                      ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1205:19: note: expanded from macro '__CLFN_ALL'
int2 __OVERLOAD__ name(int2 x, int2 y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1206:19: note: expanded from macro '__CLFN_ALL'
int3 __OVERLOAD__ name(int3 x, int3 y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1207:19: note: expanded from macro '__CLFN_ALL'
int4 __OVERLOAD__ name(int4 x, int4 y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1208:19: note: expanded from macro '__CLFN_ALL'
int8 __OVERLOAD__ name(int8 x, int8 y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1209:20: note: expanded from macro '__CLFN_ALL'
int16 __OVERLOAD__ name(int16 x, int16 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1211:20: note: expanded from macro '__CLFN_ALL'
uint2 __OVERLOAD__ name(uint2 x, uint2 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1212:20: note: expanded from macro '__CLFN_ALL'
uint3 __OVERLOAD__ name(uint3 x, uint3 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1213:20: note: expanded from macro '__CLFN_ALL'
uint4 __OVERLOAD__ name(uint4 x, uint4 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1214:20: note: expanded from macro '__CLFN_ALL'
uint8 __OVERLOAD__ name(uint8 x, uint8 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1215:21: note: expanded from macro '__CLFN_ALL'
uint16 __OVERLOAD__ name(uint16 x, uint16 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1217:20: note: expanded from macro '__CLFN_ALL'
long2 __OVERLOAD__ name(long2 x, long2 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1218:20: note: expanded from macro '__CLFN_ALL'
long3 __OVERLOAD__ name(long3 x, long3 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1219:20: note: expanded from macro '__CLFN_ALL'
long4 __OVERLOAD__ name(long4 x, long4 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1220:20: note: expanded from macro '__CLFN_ALL'
long8 __OVERLOAD__ name(long8 x, long8 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1221:21: note: expanded from macro '__CLFN_ALL'
long16 __OVERLOAD__ name(long16 x, long16 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1223:21: note: expanded from macro '__CLFN_ALL'
ulong2 __OVERLOAD__ name(ulong2 x, ulong2 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1224:21: note: expanded from macro '__CLFN_ALL'
ulong3 __OVERLOAD__ name(ulong3 x, ulong3 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1225:21: note: expanded from macro '__CLFN_ALL'
ulong4 __OVERLOAD__ name(ulong4 x, ulong4 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1226:21: note: expanded from macro '__CLFN_ALL'
ulong8 __OVERLOAD__ name(ulong8 x, ulong8 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4826:12: note: candidate function
__CLFN_ALL(min);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1227:22: note: expanded from macro '__CLFN_ALL'
ulong16 __OVERLOAD__ name(ulong16 x, ulong16 y); 
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1291:49: note: expanded from macro '__CLFN_ALL_MODD'
#define __CLFN_ALL_MODD(name) char __OVERLOAD__ name(char x, char y); \
                                                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1292:20: note: expanded from macro '__CLFN_ALL_MODD'
char2 __OVERLOAD__ name(char2 x, char y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1293:20: note: expanded from macro '__CLFN_ALL_MODD'
char3 __OVERLOAD__ name(char3 x, char y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1294:20: note: expanded from macro '__CLFN_ALL_MODD'
char4 __OVERLOAD__ name(char4 x, char y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1295:20: note: expanded from macro '__CLFN_ALL_MODD'
char8 __OVERLOAD__ name(char8 x, char y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1296:21: note: expanded from macro '__CLFN_ALL_MODD'
char16 __OVERLOAD__ name(char16 x, char y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1297:20: note: expanded from macro '__CLFN_ALL_MODD'
uchar __OVERLOAD__ name(uchar x, uchar y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1298:21: note: expanded from macro '__CLFN_ALL_MODD'
uchar2 __OVERLOAD__ name(uchar2 x, uchar y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1299:21: note: expanded from macro '__CLFN_ALL_MODD'
uchar3 __OVERLOAD__ name(uchar3 x, uchar y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1300:21: note: expanded from macro '__CLFN_ALL_MODD'
uchar4 __OVERLOAD__ name(uchar4 x, uchar y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1301:21: note: expanded from macro '__CLFN_ALL_MODD'
uchar8 __OVERLOAD__ name(uchar8 x, uchar y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1302:22: note: expanded from macro '__CLFN_ALL_MODD'
uchar16 __OVERLOAD__ name(uchar16 x,uchar y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1303:20: note: expanded from macro '__CLFN_ALL_MODD'
short __OVERLOAD__ name(short x, short y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1304:21: note: expanded from macro '__CLFN_ALL_MODD'
short2 __OVERLOAD__ name(short2 x, short y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1305:21: note: expanded from macro '__CLFN_ALL_MODD'
short3 __OVERLOAD__ name(short3 x, short y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1306:21: note: expanded from macro '__CLFN_ALL_MODD'
short4 __OVERLOAD__ name(short4 x, short y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1307:21: note: expanded from macro '__CLFN_ALL_MODD'
short8 __OVERLOAD__ name(short8 x, short y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1308:22: note: expanded from macro '__CLFN_ALL_MODD'
short16 __OVERLOAD__ name(short16 x, short y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1309:21: note: expanded from macro '__CLFN_ALL_MODD'
ushort __OVERLOAD__ name(ushort x, ushort y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1310:22: note: expanded from macro '__CLFN_ALL_MODD'
ushort2 __OVERLOAD__ name(ushort2 x, ushort y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1311:22: note: expanded from macro '__CLFN_ALL_MODD'
ushort3 __OVERLOAD__ name(ushort3 x, ushort y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1312:22: note: expanded from macro '__CLFN_ALL_MODD'
ushort4 __OVERLOAD__ name(ushort4 x, ushort y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1313:22: note: expanded from macro '__CLFN_ALL_MODD'
ushort8 __OVERLOAD__ name(ushort8 x, ushort y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1314:23: note: expanded from macro '__CLFN_ALL_MODD'
ushort16 __OVERLOAD__ name(ushort16 x, ushort y); \
                      ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1315:18: note: expanded from macro '__CLFN_ALL_MODD'
int __OVERLOAD__ name(int x, int y); \
                 ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1316:19: note: expanded from macro '__CLFN_ALL_MODD'
int2 __OVERLOAD__ name(int2 x, int y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1317:19: note: expanded from macro '__CLFN_ALL_MODD'
int3 __OVERLOAD__ name(int3 x, int y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1318:19: note: expanded from macro '__CLFN_ALL_MODD'
int4 __OVERLOAD__ name(int4 x, int y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1319:19: note: expanded from macro '__CLFN_ALL_MODD'
int8 __OVERLOAD__ name(int8 x, int y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1320:20: note: expanded from macro '__CLFN_ALL_MODD'
int16 __OVERLOAD__ name(int16 x, int y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1321:19: note: expanded from macro '__CLFN_ALL_MODD'
uint __OVERLOAD__ name(uint x, uint y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1322:20: note: expanded from macro '__CLFN_ALL_MODD'
uint2 __OVERLOAD__ name(uint2 x, uint y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1323:20: note: expanded from macro '__CLFN_ALL_MODD'
uint3 __OVERLOAD__ name(uint3 x, uint y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1324:20: note: expanded from macro '__CLFN_ALL_MODD'
uint4 __OVERLOAD__ name(uint4 x, uint y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1325:20: note: expanded from macro '__CLFN_ALL_MODD'
uint8 __OVERLOAD__ name(uint8 x, uint y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1326:21: note: expanded from macro '__CLFN_ALL_MODD'
uint16 __OVERLOAD__ name(uint16 x, uint y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1327:19: note: expanded from macro '__CLFN_ALL_MODD'
long __OVERLOAD__ name(long x, long y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1328:20: note: expanded from macro '__CLFN_ALL_MODD'
long2 __OVERLOAD__ name(long2 x, long y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1329:20: note: expanded from macro '__CLFN_ALL_MODD'
long3 __OVERLOAD__ name(long3 x, long y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1330:20: note: expanded from macro '__CLFN_ALL_MODD'
long4 __OVERLOAD__ name(long4 x, long y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1331:20: note: expanded from macro '__CLFN_ALL_MODD'
long8 __OVERLOAD__ name(long8 x, long y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1332:21: note: expanded from macro '__CLFN_ALL_MODD'
long16 __OVERLOAD__ name(long16 x, long y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1333:20: note: expanded from macro '__CLFN_ALL_MODD'
ulong __OVERLOAD__ name(ulong x, ulong y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1334:21: note: expanded from macro '__CLFN_ALL_MODD'
ulong2 __OVERLOAD__ name(ulong2 x, ulong y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1335:21: note: expanded from macro '__CLFN_ALL_MODD'
ulong3 __OVERLOAD__ name(ulong3 x, ulong y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1336:21: note: expanded from macro '__CLFN_ALL_MODD'
ulong4 __OVERLOAD__ name(ulong4 x, ulong y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1337:21: note: expanded from macro '__CLFN_ALL_MODD'
ulong8 __OVERLOAD__ name(ulong8 x, ulong y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1338:22: note: expanded from macro '__CLFN_ALL_MODD'
ulong16 __OVERLOAD__ name(ulong16 x, ulong y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1340:21: note: expanded from macro '__CLFN_ALL_MODD'
float2 __OVERLOAD__ name(float2 x, float y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1341:21: note: expanded from macro '__CLFN_ALL_MODD'
float3 __OVERLOAD__ name(float3 x, float y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1342:21: note: expanded from macro '__CLFN_ALL_MODD'
float4 __OVERLOAD__ name(float4 x, float y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1343:21: note: expanded from macro '__CLFN_ALL_MODD'
float8 __OVERLOAD__ name(float8 x, float y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4827:17: note: candidate function
__CLFN_ALL_MODD(min);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1344:22: note: expanded from macro '__CLFN_ALL_MODD'
float16 __OVERLOAD__ name(float16 x, float y);
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4828:15: note: candidate function
__CLFN_FD_2FD(min);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1009:48: note: expanded from macro '__CLFN_FD_2FD'
#define __CLFN_FD_2FD(name) float __OVERLOAD__ name(float x, float y); \
                                               ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4828:15: note: candidate function
__CLFN_FD_2FD(min);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1010:21: note: expanded from macro '__CLFN_FD_2FD'
float2 __OVERLOAD__ name(float2 x, float2 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4828:15: note: candidate function
__CLFN_FD_2FD(min);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1011:21: note: expanded from macro '__CLFN_FD_2FD'
float3 __OVERLOAD__ name(float3 x, float3 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4828:15: note: candidate function
__CLFN_FD_2FD(min);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1012:21: note: expanded from macro '__CLFN_FD_2FD'
float4 __OVERLOAD__ name(float4 x, float4 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4828:15: note: candidate function
__CLFN_FD_2FD(min);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1013:21: note: expanded from macro '__CLFN_FD_2FD'
float8 __OVERLOAD__ name(float8 x, float8 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4828:15: note: candidate function
__CLFN_FD_2FD(min);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1014:22: note: expanded from macro '__CLFN_FD_2FD'
float16 __OVERLOAD__ name(float16 x, float16 y);
                     ^
<program source>:98:1112: error: call to '__cl_floor' is ambiguous
inline void ConvertRGBToHSL(const CLQuantum red,const CLQuantum green, const CLQuantum blue, float *hue, float *saturation, float *lightness) { float c, tmax, tmin; tmax=max(QuantumScale*red,max(QuantumScale*green, QuantumScale*blue)); tmin=min(QuantumScale*red,min(QuantumScale*green, QuantumScale*blue)); c=tmax-tmin; *lightness=(tmax+tmin)/2.0; if (c <= 0.0) { *hue=0.0; *saturation=0.0; return; } if (tmax == (QuantumScale*red)) { *hue=(QuantumScale*green-QuantumScale*blue)/c; if ((QuantumScale*green) < (QuantumScale*blue)) *hue+=6.0; } else if (tmax == (QuantumScale*green)) *hue=2.0+(QuantumScale*blue-QuantumScale*red)/c; else *hue=4.0+(QuantumScale*red-QuantumScale*green)/c; *hue*=60.0/360.0; if (*lightness <= 0.5) *saturation=c/(2.0*(*lightness)); else *saturation=c/(2.0-2.0*(*lightness)); } inline void ConvertHSLToRGB(const float hue,const float saturation, const float lightness, CLQuantum *red,CLQuantum *green,CLQuantum *blue) { float b, c, g, h, tmin, r, x; h=hue*360.0; if (lightness <= 0.5) c=2.0*lightness*saturation; else c=(2.0-2.0*lightness)*saturation; tmin=lightness-0.5*c; h-=360.0*floor(h/360.0); h/=60.0; x=c*(1.0-fabs(h-2.0*floor(h/2.0)-1.0)); switch ((int) floor(h)) { case 0: { r=tmin+c; g=tmin+x; b=tmin; break; } case 1: { r=tmin+x; g=tmin+c; b=tmin; break; } case 2: { r=tmin; g=tmin+c; b=tmin+x; break; } case 3: { r=tmin; g=tmin+x; b=tmin+c; break; } case 4: { r=tmin+x; g=tmin; b=tmin+c; break; } case 5: { r=tmin+c; g=tmin; b=tmin+x; break; } default: { r=0.0; g=0.0; b=0.0; } } *red=ClampToQuantum(QuantumRange*r); *green=ClampToQuantum(QuantumRange*g); *blue=ClampToQuantum(QuantumRange*b); } inline void ModulateHSL(const float percent_hue, const float percent_saturation,const float percent_lightness, CLQuantum *red,CLQuantum *green,CLQuantum *blue) { float hue, lightness, saturation; ConvertRGBToHSL(*red,*green,*blue,&hue,&saturation,&lightness); hue+=0.5*(0.01*percent_hue-1.0); while (hue < 0.0) hue+=1.0; while (hue >= 1.0) hue-=1.0; saturation*=0.01*percent_saturation; lightness*=0.01*percent_lightness; ConvertHSLToRGB(hue,saturation,lightness,red,green,blue); } __kernel void Modulate(__global CLPixelType *im, const float percent_brightness, const float percent_hue, const float percent_saturation, const int colorspace) { const int x = get_global_id(0); const int y = get_global_id(1); const int columns = get_global_size(0); const int c = x + y * columns; CLPixelType pixel = im[c]; CLQuantum blue, green, red; red=getRed(pixel); green=getGreen(pixel); blue=getBlue(pixel); switch (colorspace) { case HSLColorspace: default: { ModulateHSL(percent_hue, percent_saturation, percent_brightness, &red, &green, &blue); } } CLPixelType filteredPixel; setRed(&filteredPixel, red); setGreen(&filteredPixel, green); setBlue(&filteredPixel, blue); filteredPixel.w = pixel.w; im[c] = filteredPixel; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^~~~~~~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4536:24: note: expanded from macro 'floor'
    #define floor(__x) __cl_floor(__x)
                       ^~~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4533:15: note: candidate function
__CLFN_FD_1FD(__cl_floor);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:366:48: note: expanded from macro '__CLFN_FD_1FD'
#define __CLFN_FD_1FD(name) float __OVERLOAD__ name(float x); \
                                               ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4533:15: note: candidate function
__CLFN_FD_1FD(__cl_floor);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:367:21: note: expanded from macro '__CLFN_FD_1FD'
float2 __OVERLOAD__ name(float2 x); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4533:15: note: candidate function
__CLFN_FD_1FD(__cl_floor);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:368:21: note: expanded from macro '__CLFN_FD_1FD'
float3 __OVERLOAD__ name(float3 x); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4533:15: note: candidate function
__CLFN_FD_1FD(__cl_floor);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:369:21: note: expanded from macro '__CLFN_FD_1FD'
float4 __OVERLOAD__ name(float4 x); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4533:15: note: candidate function
__CLFN_FD_1FD(__cl_floor);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:370:21: note: expanded from macro '__CLFN_FD_1FD'
float8 __OVERLOAD__ name(float8 x); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4533:15: note: candidate function
__CLFN_FD_1FD(__cl_floor);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:371:22: note: expanded from macro '__CLFN_FD_1FD'
float16 __OVERLOAD__ name(float16 x);
                     ^
<program source>:98:1157: error: call to '__cl_floor' is ambiguous
inline void ConvertRGBToHSL(const CLQuantum red,const CLQuantum green, const CLQuantum blue, float *hue, float *saturation, float *lightness) { float c, tmax, tmin; tmax=max(QuantumScale*red,max(QuantumScale*green, QuantumScale*blue)); tmin=min(QuantumScale*red,min(QuantumScale*green, QuantumScale*blue)); c=tmax-tmin; *lightness=(tmax+tmin)/2.0; if (c <= 0.0) { *hue=0.0; *saturation=0.0; return; } if (tmax == (QuantumScale*red)) { *hue=(QuantumScale*green-QuantumScale*blue)/c; if ((QuantumScale*green) < (QuantumScale*blue)) *hue+=6.0; } else if (tmax == (QuantumScale*green)) *hue=2.0+(QuantumScale*blue-QuantumScale*red)/c; else *hue=4.0+(QuantumScale*red-QuantumScale*green)/c; *hue*=60.0/360.0; if (*lightness <= 0.5) *saturation=c/(2.0*(*lightness)); else *saturation=c/(2.0-2.0*(*lightness)); } inline void ConvertHSLToRGB(const float hue,const float saturation, const float lightness, CLQuantum *red,CLQuantum *green,CLQuantum *blue) { float b, c, g, h, tmin, r, x; h=hue*360.0; if (lightness <= 0.5) c=2.0*lightness*saturation; else c=(2.0-2.0*lightness)*saturation; tmin=lightness-0.5*c; h-=360.0*floor(h/360.0); h/=60.0; x=c*(1.0-fabs(h-2.0*floor(h/2.0)-1.0)); switch ((int) floor(h)) { case 0: { r=tmin+c; g=tmin+x; b=tmin; break; } case 1: { r=tmin+x; g=tmin+c; b=tmin; break; } case 2: { r=tmin; g=tmin+c; b=tmin+x; break; } case 3: { r=tmin; g=tmin+x; b=tmin+c; break; } case 4: { r=tmin+x; g=tmin; b=tmin+c; break; } case 5: { r=tmin+c; g=tmin; b=tmin+x; break; } default: { r=0.0; g=0.0; b=0.0; } } *red=ClampToQuantum(QuantumRange*r); *green=ClampToQuantum(QuantumRange*g); *blue=ClampToQuantum(QuantumRange*b); } inline void ModulateHSL(const float percent_hue, const float percent_saturation,const float percent_lightness, CLQuantum *red,CLQuantum *green,CLQuantum *blue) { float hue, lightness, saturation; ConvertRGBToHSL(*red,*green,*blue,&hue,&saturation,&lightness); hue+=0.5*(0.01*percent_hue-1.0); while (hue < 0.0) hue+=1.0; while (hue >= 1.0) hue-=1.0; saturation*=0.01*percent_saturation; lightness*=0.01*percent_lightness; ConvertHSLToRGB(hue,saturation,lightness,red,green,blue); } __kernel void Modulate(__global CLPixelType *im, const float percent_brightness, const float percent_hue, const float percent_saturation, const int colorspace) { const int x = get_global_id(0); const int y = get_global_id(1); const int columns = get_global_size(0); const int c = x + y * columns; CLPixelType pixel = im[c]; CLQuantum blue, green, red; red=getRed(pixel); green=getGreen(pixel); blue=getBlue(pixel); switch (colorspace) { case HSLColorspace: default: { ModulateHSL(percent_hue, percent_saturation, percent_brightness, &red, &green, &blue); } } CLPixelType filteredPixel; setRed(&filteredPixel, red); setGreen(&filteredPixel, green); setBlue(&filteredPixel, blue); filteredPixel.w = pixel.w; im[c] = filteredPixel; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^~~~~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4536:24: note: expanded from macro 'floor'
    #define floor(__x) __cl_floor(__x)
                       ^~~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4524:33: note: expanded from macro 'fabs'
    #define fabs(__x) __cl_fabs(__x)
                                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4533:15: note: candidate function
__CLFN_FD_1FD(__cl_floor);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:366:48: note: expanded from macro '__CLFN_FD_1FD'
#define __CLFN_FD_1FD(name) float __OVERLOAD__ name(float x); \
                                               ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4533:15: note: candidate function
__CLFN_FD_1FD(__cl_floor);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:367:21: note: expanded from macro '__CLFN_FD_1FD'
float2 __OVERLOAD__ name(float2 x); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4533:15: note: candidate function
__CLFN_FD_1FD(__cl_floor);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:368:21: note: expanded from macro '__CLFN_FD_1FD'
float3 __OVERLOAD__ name(float3 x); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4533:15: note: candidate function
__CLFN_FD_1FD(__cl_floor);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:369:21: note: expanded from macro '__CLFN_FD_1FD'
float4 __OVERLOAD__ name(float4 x); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4533:15: note: candidate function
__CLFN_FD_1FD(__cl_floor);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:370:21: note: expanded from macro '__CLFN_FD_1FD'
float8 __OVERLOAD__ name(float8 x); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4533:15: note: candidate function
__CLFN_FD_1FD(__cl_floor);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:371:22: note: expanded from macro '__CLFN_FD_1FD'
float16 __OVERLOAD__ name(float16 x);
                     ^
<program source>:99:1350: error: call to '__cl_sqrt' is ambiguous
__kernel void Grayscale(__global CLPixelType *im, const int method, const int colorspace) { const int x = get_global_id(0); const int y = get_global_id(1); const int columns = get_global_size(0); const int c = x + y * columns; CLPixelType pixel = im[c]; float blue, green, intensity, red; red=(float)getRed(pixel); green=(float)getGreen(pixel); blue=(float)getBlue(pixel); intensity=0.0; CLPixelType filteredPixel; switch (method) { case AveragePixelIntensityMethod: { intensity=(red+green+blue)/3.0; break; } case BrightnessPixelIntensityMethod: { intensity=max(max(red,green),blue); break; } case LightnessPixelIntensityMethod: { intensity=(min(min(red,green),blue)+ max(max(red,green),blue))/2.0; break; } case MSPixelIntensityMethod: { intensity=(float) (((float) red*red+green*green+ blue*blue)/(3.0*QuantumRange)); break; } case Rec601LumaPixelIntensityMethod: { intensity=0.298839*red+0.586811*green+0.114350*blue; break; } case Rec601LuminancePixelIntensityMethod: { intensity=0.298839*red+0.586811*green+0.114350*blue; break; } case Rec709LumaPixelIntensityMethod: default: { intensity=0.212656*red+0.715158*green+0.072186*blue; break; } case Rec709LuminancePixelIntensityMethod: { intensity=0.212656*red+0.715158*green+0.072186*blue; break; } case RMSPixelIntensityMethod: { intensity=(float) (sqrt((float) red*red+green*green+ blue*blue)/sqrt(3.0)); break; } } setGray(&filteredPixel, ClampToQuantum(intensity)); filteredPixel.w = pixel.w; im[c] = filteredPixel; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4741:23: note: expanded from macro 'sqrt'
    #define sqrt(__x) __cl_sqrt(__x)
                      ^~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4738:15: note: candidate function
__CLFN_FD_1FD(__cl_sqrt);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:366:48: note: expanded from macro '__CLFN_FD_1FD'
#define __CLFN_FD_1FD(name) float __OVERLOAD__ name(float x); \
                                               ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4738:15: note: candidate function
__CLFN_FD_1FD(__cl_sqrt);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:367:21: note: expanded from macro '__CLFN_FD_1FD'
float2 __OVERLOAD__ name(float2 x); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4738:15: note: candidate function
__CLFN_FD_1FD(__cl_sqrt);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:368:21: note: expanded from macro '__CLFN_FD_1FD'
float3 __OVERLOAD__ name(float3 x); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4738:15: note: candidate function
__CLFN_FD_1FD(__cl_sqrt);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:369:21: note: expanded from macro '__CLFN_FD_1FD'
float4 __OVERLOAD__ name(float4 x); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4738:15: note: candidate function
__CLFN_FD_1FD(__cl_sqrt);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:370:21: note: expanded from macro '__CLFN_FD_1FD'
float8 __OVERLOAD__ name(float8 x); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4738:15: note: candidate function
__CLFN_FD_1FD(__cl_sqrt);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:371:22: note: expanded from macro '__CLFN_FD_1FD'
float16 __OVERLOAD__ name(float16 x);
                     ^
<program source>:100:7: warning: no previous prototype for function 'BoxResizeFilter'
float BoxResizeFilter(const float x) { return 1.0f; }
      ^
<program source>:101:7: warning: no previous prototype for function 'CubicBC'
float CubicBC(const float x,const __global float* resizeFilterCoefficients) { if (x < 1.0) return(resizeFilterCoefficients[0]+x*(x* (resizeFilterCoefficients[1]+x*resizeFilterCoefficients[2]))); if (x < 2.0) return(resizeFilterCoefficients[3]+x*(resizeFilterCoefficients[4]+x* (resizeFilterCoefficients[5]+x*resizeFilterCoefficients[6]))); return(0.0); }
      ^
<program source>:102:7: warning: no previous prototype for function 'Sinc'
float Sinc(const float x) { if (x != 0.0f) { const float alpha=(float) (MagickPI*x); return sinpi(x)/alpha; } return(1.0f); }
      ^
<program source>:103:7: warning: no previous prototype for function 'Triangle'
float Triangle(const float x) { return ((x<1.0f)?(1.0f-x):0.0f); }
      ^
<program source>:104:7: warning: no previous prototype for function 'Hanning'
float Hanning(const float x) { const float cosine=cos((MagickPI*x)); return(0.5f+0.5f*cosine); }
      ^
<program source>:104:51: error: call to '__fast_relax_cos' is ambiguous
float Hanning(const float x) { const float cosine=cos((MagickPI*x)); return(0.5f+0.5f*cosine); }
                                                  ^~~~~~~~~~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4711:22: note: expanded from macro 'cos'
    #define cos(__x) __fast_relax_cos(__x)
                     ^~~~~~~~~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4709:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_cos, native_cos, __cl_cos);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:416:27: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float __OVERLOAD__ _name(float x) { return _default_name(x); } \
                          ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4709:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_cos, native_cos, __cl_cos);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:417:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float2 __OVERLOAD__ _name(float2 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4709:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_cos, native_cos, __cl_cos);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:418:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float3 __OVERLOAD__ _name(float3 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4709:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_cos, native_cos, __cl_cos);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:419:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float4 __OVERLOAD__ _name(float4 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4709:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_cos, native_cos, __cl_cos);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:420:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float8 __OVERLOAD__ _name(float8 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4709:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_cos, native_cos, __cl_cos);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:421:29: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float16 __OVERLOAD__ _name(float16 x){ return _default_name(x); }
                            ^
<program source>:105:7: warning: no previous prototype for function 'Hamming'
float Hamming(const float x) { const float cosine=cos((MagickPI*x)); return(0.54f+0.46f*cosine); }
      ^
<program source>:105:51: error: call to '__fast_relax_cos' is ambiguous
float Hamming(const float x) { const float cosine=cos((MagickPI*x)); return(0.54f+0.46f*cosine); }
                                                  ^~~~~~~~~~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4711:22: note: expanded from macro 'cos'
    #define cos(__x) __fast_relax_cos(__x)
                     ^~~~~~~~~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4709:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_cos, native_cos, __cl_cos);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:416:27: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float __OVERLOAD__ _name(float x) { return _default_name(x); } \
                          ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4709:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_cos, native_cos, __cl_cos);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:417:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float2 __OVERLOAD__ _name(float2 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4709:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_cos, native_cos, __cl_cos);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:418:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float3 __OVERLOAD__ _name(float3 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4709:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_cos, native_cos, __cl_cos);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:419:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float4 __OVERLOAD__ _name(float4 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4709:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_cos, native_cos, __cl_cos);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:420:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float8 __OVERLOAD__ _name(float8 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4709:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_cos, native_cos, __cl_cos);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:421:29: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float16 __OVERLOAD__ _name(float16 x){ return _default_name(x); }
                            ^
<program source>:106:7: warning: no previous prototype for function 'Blackman'
float Blackman(const float x) { const float cosine=cos((MagickPI*x)); return(0.34f+cosine*(0.5f+cosine*0.16f)); }
      ^
<program source>:106:52: error: call to '__fast_relax_cos' is ambiguous
float Blackman(const float x) { const float cosine=cos((MagickPI*x)); return(0.34f+cosine*(0.5f+cosine*0.16f)); }
                                                   ^~~~~~~~~~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4711:22: note: expanded from macro 'cos'
    #define cos(__x) __fast_relax_cos(__x)
                     ^~~~~~~~~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4709:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_cos, native_cos, __cl_cos);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:416:27: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float __OVERLOAD__ _name(float x) { return _default_name(x); } \
                          ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4709:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_cos, native_cos, __cl_cos);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:417:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float2 __OVERLOAD__ _name(float2 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4709:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_cos, native_cos, __cl_cos);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:418:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float3 __OVERLOAD__ _name(float3 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4709:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_cos, native_cos, __cl_cos);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:419:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float4 __OVERLOAD__ _name(float4 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4709:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_cos, native_cos, __cl_cos);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:420:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float8 __OVERLOAD__ _name(float8 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4709:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_cos, native_cos, __cl_cos);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:421:29: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float16 __OVERLOAD__ _name(float16 x){ return _default_name(x); }
                            ^
<program source>:110:453: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
inline unsigned int getNumWorkItemsPerPixel(const unsigned int pixelPerWorkgroup, const unsigned int numWorkItems) { return (numWorkItems/pixelPerWorkgroup); } inline int pixelToCompute(const unsigned itemID, const unsigned int pixelPerWorkgroup, const unsigned int numWorkItems) { const unsigned int numWorkItemsPerPixel = getNumWorkItemsPerPixel(pixelPerWorkgroup, numWorkItems); int pixelIndex = itemID/numWorkItemsPerPixel; pixelIndex = (pixelIndex<pixelPerWorkgroup)?pixelIndex:-1; return pixelIndex; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                          ~~~~~~~~~~^~~~~~~~~~~~~~~~~~
<program source>:111:1035: error: call to 'max' is ambiguous
__kernel __attribute__((reqd_work_group_size(256, 1, 1))) void ResizeHorizontalFilter(const __global CLPixelType* inputImage, const unsigned int inputColumns, const unsigned int inputRows, const unsigned int matte , const float xFactor, __global CLPixelType* filteredImage, const unsigned int filteredColumns, const unsigned int filteredRows , const int resizeFilterType, const int resizeWindowType , const __global float* resizeFilterCubicCoefficients , const float resizeFilterScale, const float resizeFilterSupport, const float resizeFilterWindowSupport, const float resizeFilterBlur , __local CLPixelType* inputImageCache, const int numCachedPixels, const unsigned int pixelPerWorkgroup, const unsigned int pixelChunkSize , __local float4* outputPixelCache, __local float* densityCache, __local float* gammaCache) { const unsigned int startX = get_group_id(0)*pixelPerWorkgroup; const unsigned int stopX = min(startX + pixelPerWorkgroup,filteredColumns); const unsigned int actualNumPixelToCompute = stopX - startX; float scale = max(1.0f/xFactor+MagickEpsilon ,1.0f); const float support = max(scale*resizeFilterSupport,0.5f); scale = PerceptibleReciprocal(scale); const int cacheRangeStartX = max((int)((startX+0.5f)/xFactor+MagickEpsilon-support+0.5f),(int)(0)); const int cacheRangeEndX = min((int)(cacheRangeStartX + numCachedPixels), (int)inputColumns); const unsigned int y = get_global_id(1); event_t e = async_work_group_copy(inputImageCache,inputImage+y*inputColumns+cacheRangeStartX,cacheRangeEndX-cacheRangeStartX,0); wait_group_events(1,&e); unsigned int totalNumChunks = (actualNumPixelToCompute+pixelChunkSize-1)/pixelChunkSize; for (unsigned int chunk = 0; chunk < totalNumChunks; chunk++) { const unsigned int chunkStartX = startX + chunk*pixelChunkSize; const unsigned int chunkStopX = min(chunkStartX + pixelChunkSize, stopX); const unsigned int actualNumPixelInThisChunk = chunkStopX - chunkStartX; const unsigned int itemID = get_local_id(0); const unsigned int numItems = getNumWorkItemsPerPixel(actualNumPixelInThisChunk, get_local_size(0)); const int pixelIndex = pixelToCompute(itemID, actualNumPixelInThisChunk, get_local_size(0)); float4 filteredPixel = (float4)0.0f; float density = 0.0f; float gamma = 0.0f; if (pixelIndex != -1) { const int x = chunkStartX + pixelIndex; const float bisect = (x+0.5)/xFactor+MagickEpsilon; const unsigned int start = (unsigned int)max(bisect-support+0.5f,0.0f); const unsigned int stop = (unsigned int)min(bisect+support+0.5f,(float)inputColumns); const unsigned int n = stop - start; unsigned int numStepsPerWorkItem = n / numItems; numStepsPerWorkItem += ((numItems*numStepsPerWorkItem)==n?0:1); const unsigned int startStep = (itemID%numItems)*numStepsPerWorkItem; if (startStep < n) { const unsigned int stopStep = min(startStep+numStepsPerWorkItem, n); unsigned int cacheIndex = start+startStep-cacheRangeStartX; if (matte == 0) { for (unsigned int i = startStep; i < stopStep; i++,cacheIndex++) { float4 cp = convert_float4(inputImageCache[cacheIndex]); float weight = getResizeFilterWeight(resizeFilterCubicCoefficients,(ResizeWeightingFunctionType)resizeFilterType , (ResizeWeightingFunctionType)resizeWindowType , resizeFilterScale, resizeFilterWindowSupport, resizeFilterBlur,scale*(start+i-bisect+0.5)); filteredPixel += ((float4)weight)*cp; density+=weight; } } else { for (unsigned int i = startStep; i < stopStep; i++,cacheIndex++) { CLPixelType p = inputImageCache[cacheIndex]; float weight = getResizeFilterWeight(resizeFilterCubicCoefficients,(ResizeWeightingFunctionType)resizeFilterType , (ResizeWeightingFunctionType)resizeWindowType , resizeFilterScale, resizeFilterWindowSupport, resizeFilterBlur,scale*(start+i-bisect+0.5)); float alpha = weight * QuantumScale * GetPixelAlpha(p); float4 cp = convert_float4(p); filteredPixel.x += alpha * cp.x; filteredPixel.y += alpha * cp.y; filteredPixel.z += alpha * cp.z; filteredPixel.w += weight * cp.w; density+=weight; gamma+=alpha; } } } } if (itemID < actualNumPixelInThisChunk) { outputPixelCache[itemID] = (float4)0.0f; densityCache[itemID] = 0.0f; if (matte != 0) gammaCache[itemID] = 0.0f; } barrier(CLK_LOCAL_MEM_FENCE); for (unsigned int i = 0; i < numItems; i++) { if (pixelIndex != -1) { if (itemID%numItems == i) { outputPixelCache[pixelIndex]+=filteredPixel; densityCache[pixelIndex]+=density; if (matte!=0) { gammaCache[pixelIndex]+=gamma; } } } barrier(CLK_LOCAL_MEM_FENCE); } if (itemID < actualNumPixelInThisChunk) { if (matte==0) { float density = densityCache[itemID]; float4 filteredPixel = outputPixelCache[itemID]; if (density!= 0.0f && density != 1.0) { density = PerceptibleReciprocal(density); filteredPixel *= (float4)density; } filteredImage[y*filteredColumns+chunkStartX+itemID] = (CLPixelType) (ClampToQuantum(filteredPixel.x) , ClampToQuantum(filteredPixel.y) , ClampToQuantum(filteredPixel.z) , ClampToQuantum(filteredPixel.w)); } else { float density = densityCache[itemID]; float gamma = gammaCache[itemID]; float4 filteredPixel = outputPixelCache[itemID]; if (density!= 0.0f && density != 1.0) { density = PerceptibleReciprocal(density); filteredPixel *= (float4)density; gamma *= density; } gamma = PerceptibleReciprocal(gamma); CLPixelType fp; fp = (CLPixelType) ( ClampToQuantum(gamma*filteredPixel.x) , ClampToQuantum(gamma*filteredPixel.y) , ClampToQuantum(gamma*filteredPixel.z) , ClampToQuantum(filteredPixel.w)); filteredImage[y*filteredColumns+chunkStartX+itemID] = fp; } } } }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1340:21: note: expanded from macro '__CLFN_ALL_MODD'
float2 __OVERLOAD__ name(float2 x, float y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1341:21: note: expanded from macro '__CLFN_ALL_MODD'
float3 __OVERLOAD__ name(float3 x, float y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1342:21: note: expanded from macro '__CLFN_ALL_MODD'
float4 __OVERLOAD__ name(float4 x, float y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1343:21: note: expanded from macro '__CLFN_ALL_MODD'
float8 __OVERLOAD__ name(float8 x, float y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1344:22: note: expanded from macro '__CLFN_ALL_MODD'
float16 __OVERLOAD__ name(float16 x, float y);
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4824:15: note: candidate function
__CLFN_FD_2FD(max);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1009:48: note: expanded from macro '__CLFN_FD_2FD'
#define __CLFN_FD_2FD(name) float __OVERLOAD__ name(float x, float y); \
                                               ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1181:20: note: expanded from macro '__CLFN_ALL'
char2 __OVERLOAD__ name(char2 x, char2 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1182:20: note: expanded from macro '__CLFN_ALL'
char3 __OVERLOAD__ name(char3 x, char3 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1183:20: note: expanded from macro '__CLFN_ALL'
char4 __OVERLOAD__ name(char4 x, char4 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1184:20: note: expanded from macro '__CLFN_ALL'
char8 __OVERLOAD__ name(char8 x, char8 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1185:21: note: expanded from macro '__CLFN_ALL'
char16 __OVERLOAD__ name(char16 x, char16 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1187:21: note: expanded from macro '__CLFN_ALL'
uchar2 __OVERLOAD__ name(uchar2 x, uchar2 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1188:21: note: expanded from macro '__CLFN_ALL'
uchar3 __OVERLOAD__ name(uchar3 x, uchar3 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1189:21: note: expanded from macro '__CLFN_ALL'
uchar4 __OVERLOAD__ name(uchar4 x, uchar4 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1190:21: note: expanded from macro '__CLFN_ALL'
uchar8 __OVERLOAD__ name(uchar8 x, uchar8 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1191:22: note: expanded from macro '__CLFN_ALL'
uchar16 __OVERLOAD__ name(uchar16 x,uchar16 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1193:21: note: expanded from macro '__CLFN_ALL'
short2 __OVERLOAD__ name(short2 x, short2 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1194:21: note: expanded from macro '__CLFN_ALL'
short3 __OVERLOAD__ name(short3 x, short3 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1195:21: note: expanded from macro '__CLFN_ALL'
short4 __OVERLOAD__ name(short4 x, short4 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1196:21: note: expanded from macro '__CLFN_ALL'
short8 __OVERLOAD__ name(short8 x, short8 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1197:22: note: expanded from macro '__CLFN_ALL'
short16 __OVERLOAD__ name(short16 x, short16 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1199:22: note: expanded from macro '__CLFN_ALL'
ushort2 __OVERLOAD__ name(ushort2 x, ushort2 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1200:22: note: expanded from macro '__CLFN_ALL'
ushort3 __OVERLOAD__ name(ushort3 x, ushort3 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1201:22: note: expanded from macro '__CLFN_ALL'
ushort4 __OVERLOAD__ name(ushort4 x, ushort4 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1202:22: note: expanded from macro '__CLFN_ALL'
ushort8 __OVERLOAD__ name(ushort8 x, ushort8 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1203:23: note: expanded from macro '__CLFN_ALL'
ushort16 __OVERLOAD__ name(ushort16 x, ushort16 y); \
                      ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1205:19: note: expanded from macro '__CLFN_ALL'
int2 __OVERLOAD__ name(int2 x, int2 y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1206:19: note: expanded from macro '__CLFN_ALL'
int3 __OVERLOAD__ name(int3 x, int3 y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1207:19: note: expanded from macro '__CLFN_ALL'
int4 __OVERLOAD__ name(int4 x, int4 y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1208:19: note: expanded from macro '__CLFN_ALL'
int8 __OVERLOAD__ name(int8 x, int8 y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1209:20: note: expanded from macro '__CLFN_ALL'
int16 __OVERLOAD__ name(int16 x, int16 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1211:20: note: expanded from macro '__CLFN_ALL'
uint2 __OVERLOAD__ name(uint2 x, uint2 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1212:20: note: expanded from macro '__CLFN_ALL'
uint3 __OVERLOAD__ name(uint3 x, uint3 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1213:20: note: expanded from macro '__CLFN_ALL'
uint4 __OVERLOAD__ name(uint4 x, uint4 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1214:20: note: expanded from macro '__CLFN_ALL'
uint8 __OVERLOAD__ name(uint8 x, uint8 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1215:21: note: expanded from macro '__CLFN_ALL'
uint16 __OVERLOAD__ name(uint16 x, uint16 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1217:20: note: expanded from macro '__CLFN_ALL'
long2 __OVERLOAD__ name(long2 x, long2 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1218:20: note: expanded from macro '__CLFN_ALL'
long3 __OVERLOAD__ name(long3 x, long3 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1219:20: note: expanded from macro '__CLFN_ALL'
long4 __OVERLOAD__ name(long4 x, long4 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1220:20: note: expanded from macro '__CLFN_ALL'
long8 __OVERLOAD__ name(long8 x, long8 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1221:21: note: expanded from macro '__CLFN_ALL'
long16 __OVERLOAD__ name(long16 x, long16 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1223:21: note: expanded from macro '__CLFN_ALL'
ulong2 __OVERLOAD__ name(ulong2 x, ulong2 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1224:21: note: expanded from macro '__CLFN_ALL'
ulong3 __OVERLOAD__ name(ulong3 x, ulong3 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1225:21: note: expanded from macro '__CLFN_ALL'
ulong4 __OVERLOAD__ name(ulong4 x, ulong4 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1226:21: note: expanded from macro '__CLFN_ALL'
ulong8 __OVERLOAD__ name(ulong8 x, ulong8 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1227:22: note: expanded from macro '__CLFN_ALL'
ulong16 __OVERLOAD__ name(ulong16 x, ulong16 y); 
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1291:49: note: expanded from macro '__CLFN_ALL_MODD'
#define __CLFN_ALL_MODD(name) char __OVERLOAD__ name(char x, char y); \
                                                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1292:20: note: expanded from macro '__CLFN_ALL_MODD'
char2 __OVERLOAD__ name(char2 x, char y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1293:20: note: expanded from macro '__CLFN_ALL_MODD'
char3 __OVERLOAD__ name(char3 x, char y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1294:20: note: expanded from macro '__CLFN_ALL_MODD'
char4 __OVERLOAD__ name(char4 x, char y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1295:20: note: expanded from macro '__CLFN_ALL_MODD'
char8 __OVERLOAD__ name(char8 x, char y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1296:21: note: expanded from macro '__CLFN_ALL_MODD'
char16 __OVERLOAD__ name(char16 x, char y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1297:20: note: expanded from macro '__CLFN_ALL_MODD'
uchar __OVERLOAD__ name(uchar x, uchar y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1298:21: note: expanded from macro '__CLFN_ALL_MODD'
uchar2 __OVERLOAD__ name(uchar2 x, uchar y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1299:21: note: expanded from macro '__CLFN_ALL_MODD'
uchar3 __OVERLOAD__ name(uchar3 x, uchar y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1300:21: note: expanded from macro '__CLFN_ALL_MODD'
uchar4 __OVERLOAD__ name(uchar4 x, uchar y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1301:21: note: expanded from macro '__CLFN_ALL_MODD'
uchar8 __OVERLOAD__ name(uchar8 x, uchar y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1302:22: note: expanded from macro '__CLFN_ALL_MODD'
uchar16 __OVERLOAD__ name(uchar16 x,uchar y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1303:20: note: expanded from macro '__CLFN_ALL_MODD'
short __OVERLOAD__ name(short x, short y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1304:21: note: expanded from macro '__CLFN_ALL_MODD'
short2 __OVERLOAD__ name(short2 x, short y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1305:21: note: expanded from macro '__CLFN_ALL_MODD'
short3 __OVERLOAD__ name(short3 x, short y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1306:21: note: expanded from macro '__CLFN_ALL_MODD'
short4 __OVERLOAD__ name(short4 x, short y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1307:21: note: expanded from macro '__CLFN_ALL_MODD'
short8 __OVERLOAD__ name(short8 x, short y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1308:22: note: expanded from macro '__CLFN_ALL_MODD'
short16 __OVERLOAD__ name(short16 x, short y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1309:21: note: expanded from macro '__CLFN_ALL_MODD'
ushort __OVERLOAD__ name(ushort x, ushort y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1310:22: note: expanded from macro '__CLFN_ALL_MODD'
ushort2 __OVERLOAD__ name(ushort2 x, ushort y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1311:22: note: expanded from macro '__CLFN_ALL_MODD'
ushort3 __OVERLOAD__ name(ushort3 x, ushort y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1312:22: note: expanded from macro '__CLFN_ALL_MODD'
ushort4 __OVERLOAD__ name(ushort4 x, ushort y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1313:22: note: expanded from macro '__CLFN_ALL_MODD'
ushort8 __OVERLOAD__ name(ushort8 x, ushort y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1314:23: note: expanded from macro '__CLFN_ALL_MODD'
ushort16 __OVERLOAD__ name(ushort16 x, ushort y); \
                      ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1315:18: note: expanded from macro '__CLFN_ALL_MODD'
int __OVERLOAD__ name(int x, int y); \
                 ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1316:19: note: expanded from macro '__CLFN_ALL_MODD'
int2 __OVERLOAD__ name(int2 x, int y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1317:19: note: expanded from macro '__CLFN_ALL_MODD'
int3 __OVERLOAD__ name(int3 x, int y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1318:19: note: expanded from macro '__CLFN_ALL_MODD'
int4 __OVERLOAD__ name(int4 x, int y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1319:19: note: expanded from macro '__CLFN_ALL_MODD'
int8 __OVERLOAD__ name(int8 x, int y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1320:20: note: expanded from macro '__CLFN_ALL_MODD'
int16 __OVERLOAD__ name(int16 x, int y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1321:19: note: expanded from macro '__CLFN_ALL_MODD'
uint __OVERLOAD__ name(uint x, uint y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1322:20: note: expanded from macro '__CLFN_ALL_MODD'
uint2 __OVERLOAD__ name(uint2 x, uint y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1323:20: note: expanded from macro '__CLFN_ALL_MODD'
uint3 __OVERLOAD__ name(uint3 x, uint y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1324:20: note: expanded from macro '__CLFN_ALL_MODD'
uint4 __OVERLOAD__ name(uint4 x, uint y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1325:20: note: expanded from macro '__CLFN_ALL_MODD'
uint8 __OVERLOAD__ name(uint8 x, uint y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1326:21: note: expanded from macro '__CLFN_ALL_MODD'
uint16 __OVERLOAD__ name(uint16 x, uint y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1327:19: note: expanded from macro '__CLFN_ALL_MODD'
long __OVERLOAD__ name(long x, long y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1328:20: note: expanded from macro '__CLFN_ALL_MODD'
long2 __OVERLOAD__ name(long2 x, long y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1329:20: note: expanded from macro '__CLFN_ALL_MODD'
long3 __OVERLOAD__ name(long3 x, long y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1330:20: note: expanded from macro '__CLFN_ALL_MODD'
long4 __OVERLOAD__ name(long4 x, long y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1331:20: note: expanded from macro '__CLFN_ALL_MODD'
long8 __OVERLOAD__ name(long8 x, long y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1332:21: note: expanded from macro '__CLFN_ALL_MODD'
long16 __OVERLOAD__ name(long16 x, long y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1333:20: note: expanded from macro '__CLFN_ALL_MODD'
ulong __OVERLOAD__ name(ulong x, ulong y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1334:21: note: expanded from macro '__CLFN_ALL_MODD'
ulong2 __OVERLOAD__ name(ulong2 x, ulong y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1335:21: note: expanded from macro '__CLFN_ALL_MODD'
ulong3 __OVERLOAD__ name(ulong3 x, ulong y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1336:21: note: expanded from macro '__CLFN_ALL_MODD'
ulong4 __OVERLOAD__ name(ulong4 x, ulong y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1337:21: note: expanded from macro '__CLFN_ALL_MODD'
ulong8 __OVERLOAD__ name(ulong8 x, ulong y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1338:22: note: expanded from macro '__CLFN_ALL_MODD'
ulong16 __OVERLOAD__ name(ulong16 x, ulong y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4824:15: note: candidate function
__CLFN_FD_2FD(max);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1010:21: note: expanded from macro '__CLFN_FD_2FD'
float2 __OVERLOAD__ name(float2 x, float2 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4824:15: note: candidate function
__CLFN_FD_2FD(max);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1011:21: note: expanded from macro '__CLFN_FD_2FD'
float3 __OVERLOAD__ name(float3 x, float3 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4824:15: note: candidate function
__CLFN_FD_2FD(max);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1012:21: note: expanded from macro '__CLFN_FD_2FD'
float4 __OVERLOAD__ name(float4 x, float4 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4824:15: note: candidate function
__CLFN_FD_2FD(max);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1013:21: note: expanded from macro '__CLFN_FD_2FD'
float8 __OVERLOAD__ name(float8 x, float8 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4824:15: note: candidate function
__CLFN_FD_2FD(max);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1014:22: note: expanded from macro '__CLFN_FD_2FD'
float16 __OVERLOAD__ name(float16 x, float16 y);
                     ^
<program source>:113:1030: error: call to 'max' is ambiguous
__kernel __attribute__((reqd_work_group_size(1, 256, 1))) void ResizeVerticalFilter(const __global CLPixelType* inputImage, const unsigned int inputColumns, const unsigned int inputRows, const unsigned int matte , const float yFactor, __global CLPixelType* filteredImage, const unsigned int filteredColumns, const unsigned int filteredRows , const int resizeFilterType, const int resizeWindowType , const __global float* resizeFilterCubicCoefficients , const float resizeFilterScale, const float resizeFilterSupport, const float resizeFilterWindowSupport, const float resizeFilterBlur , __local CLPixelType* inputImageCache, const int numCachedPixels, const unsigned int pixelPerWorkgroup, const unsigned int pixelChunkSize , __local float4* outputPixelCache, __local float* densityCache, __local float* gammaCache) { const unsigned int startY = get_group_id(1)*pixelPerWorkgroup; const unsigned int stopY = min(startY + pixelPerWorkgroup,filteredRows); const unsigned int actualNumPixelToCompute = stopY - startY; float scale = max(1.0f/yFactor+MagickEpsilon ,1.0f); const float support = max(scale*resizeFilterSupport,0.5f); scale = PerceptibleReciprocal(scale); const int cacheRangeStartY = max((int)((startY+0.5f)/yFactor+MagickEpsilon-support+0.5f),(int)(0)); const int cacheRangeEndY = min((int)(cacheRangeStartY + numCachedPixels), (int)inputRows); const unsigned int x = get_global_id(0); event_t e = async_work_group_strided_copy(inputImageCache, inputImage+cacheRangeStartY*inputColumns+x, cacheRangeEndY-cacheRangeStartY, inputColumns, 0); wait_group_events(1,&e); unsigned int totalNumChunks = (actualNumPixelToCompute+pixelChunkSize-1)/pixelChunkSize; for (unsigned int chunk = 0; chunk < totalNumChunks; chunk++) { const unsigned int chunkStartY = startY + chunk*pixelChunkSize; const unsigned int chunkStopY = min(chunkStartY + pixelChunkSize, stopY); const unsigned int actualNumPixelInThisChunk = chunkStopY - chunkStartY; const unsigned int itemID = get_local_id(1); const unsigned int numItems = getNumWorkItemsPerPixel(actualNumPixelInThisChunk, get_local_size(1)); const int pixelIndex = pixelToCompute(itemID, actualNumPixelInThisChunk, get_local_size(1)); float4 filteredPixel = (float4)0.0f; float density = 0.0f; float gamma = 0.0f; if (pixelIndex != -1) { const int y = chunkStartY + pixelIndex; const float bisect = (y+0.5)/yFactor+MagickEpsilon; const unsigned int start = (unsigned int)max(bisect-support+0.5f,0.0f); const unsigned int stop = (unsigned int)min(bisect+support+0.5f,(float)inputRows); const unsigned int n = stop - start; unsigned int numStepsPerWorkItem = n / numItems; numStepsPerWorkItem += ((numItems*numStepsPerWorkItem)==n?0:1); const unsigned int startStep = (itemID%numItems)*numStepsPerWorkItem; if (startStep < n) { const unsigned int stopStep = min(startStep+numStepsPerWorkItem, n); unsigned int cacheIndex = start+startStep-cacheRangeStartY; if (matte == 0) { for (unsigned int i = startStep; i < stopStep; i++,cacheIndex++) { float4 cp = convert_float4(inputImageCache[cacheIndex]); float weight = getResizeFilterWeight(resizeFilterCubicCoefficients,(ResizeWeightingFunctionType)resizeFilterType , (ResizeWeightingFunctionType)resizeWindowType , resizeFilterScale, resizeFilterWindowSupport, resizeFilterBlur,scale*(start+i-bisect+0.5)); filteredPixel += ((float4)weight)*cp; density+=weight; } } else { for (unsigned int i = startStep; i < stopStep; i++,cacheIndex++) { CLPixelType p = inputImageCache[cacheIndex]; float weight = getResizeFilterWeight(resizeFilterCubicCoefficients,(ResizeWeightingFunctionType)resizeFilterType , (ResizeWeightingFunctionType)resizeWindowType , resizeFilterScale, resizeFilterWindowSupport, resizeFilterBlur,scale*(start+i-bisect+0.5)); float alpha = weight * QuantumScale * GetPixelAlpha(p); float4 cp = convert_float4(p); filteredPixel.x += alpha * cp.x; filteredPixel.y += alpha * cp.y; filteredPixel.z += alpha * cp.z; filteredPixel.w += weight * cp.w; density+=weight; gamma+=alpha; } } } } if (itemID < actualNumPixelInThisChunk) { outputPixelCache[itemID] = (float4)0.0f; densityCache[itemID] = 0.0f; if (matte != 0) gammaCache[itemID] = 0.0f; } barrier(CLK_LOCAL_MEM_FENCE); for (unsigned int i = 0; i < numItems; i++) { if (pixelIndex != -1) { if (itemID%numItems == i) { outputPixelCache[pixelIndex]+=filteredPixel; densityCache[pixelIndex]+=density; if (matte!=0) { gammaCache[pixelIndex]+=gamma; } } } barrier(CLK_LOCAL_MEM_FENCE); } if (itemID < actualNumPixelInThisChunk) { if (matte==0) { float density = densityCache[itemID]; float4 filteredPixel = outputPixelCache[itemID]; if (density!= 0.0f && density != 1.0) { density = PerceptibleReciprocal(density); filteredPixel *= (float4)density; } filteredImage[(chunkStartY+itemID)*filteredColumns+x] = (CLPixelType) (ClampToQuantum(filteredPixel.x) , ClampToQuantum(filteredPixel.y) , ClampToQuantum(filteredPixel.z) , ClampToQuantum(filteredPixel.w)); } else { float density = densityCache[itemID]; float gamma = gammaCache[itemID]; float4 filteredPixel = outputPixelCache[itemID]; if (density!= 0.0f && density != 1.0) { density = PerceptibleReciprocal(density); filteredPixel *= (float4)density; gamma *= density; } gamma = PerceptibleReciprocal(gamma); CLPixelType fp; fp = (CLPixelType) ( ClampToQuantum(gamma*filteredPixel.x) , ClampToQuantum(gamma*filteredPixel.y) , ClampToQuantum(gamma*filteredPixel.z) , ClampToQuantum(filteredPixel.w)); filteredImage[(chunkStartY+itemID)*filteredColumns+x] = fp; } } } }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1340:21: note: expanded from macro '__CLFN_ALL_MODD'
float2 __OVERLOAD__ name(float2 x, float y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1341:21: note: expanded from macro '__CLFN_ALL_MODD'
float3 __OVERLOAD__ name(float3 x, float y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1342:21: note: expanded from macro '__CLFN_ALL_MODD'
float4 __OVERLOAD__ name(float4 x, float y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1343:21: note: expanded from macro '__CLFN_ALL_MODD'
float8 __OVERLOAD__ name(float8 x, float y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1344:22: note: expanded from macro '__CLFN_ALL_MODD'
float16 __OVERLOAD__ name(float16 x, float y);
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4824:15: note: candidate function
__CLFN_FD_2FD(max);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1009:48: note: expanded from macro '__CLFN_FD_2FD'
#define __CLFN_FD_2FD(name) float __OVERLOAD__ name(float x, float y); \
                                               ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1181:20: note: expanded from macro '__CLFN_ALL'
char2 __OVERLOAD__ name(char2 x, char2 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1182:20: note: expanded from macro '__CLFN_ALL'
char3 __OVERLOAD__ name(char3 x, char3 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1183:20: note: expanded from macro '__CLFN_ALL'
char4 __OVERLOAD__ name(char4 x, char4 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1184:20: note: expanded from macro '__CLFN_ALL'
char8 __OVERLOAD__ name(char8 x, char8 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1185:21: note: expanded from macro '__CLFN_ALL'
char16 __OVERLOAD__ name(char16 x, char16 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1187:21: note: expanded from macro '__CLFN_ALL'
uchar2 __OVERLOAD__ name(uchar2 x, uchar2 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1188:21: note: expanded from macro '__CLFN_ALL'
uchar3 __OVERLOAD__ name(uchar3 x, uchar3 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1189:21: note: expanded from macro '__CLFN_ALL'
uchar4 __OVERLOAD__ name(uchar4 x, uchar4 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1190:21: note: expanded from macro '__CLFN_ALL'
uchar8 __OVERLOAD__ name(uchar8 x, uchar8 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1191:22: note: expanded from macro '__CLFN_ALL'
uchar16 __OVERLOAD__ name(uchar16 x,uchar16 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1193:21: note: expanded from macro '__CLFN_ALL'
short2 __OVERLOAD__ name(short2 x, short2 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1194:21: note: expanded from macro '__CLFN_ALL'
short3 __OVERLOAD__ name(short3 x, short3 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1195:21: note: expanded from macro '__CLFN_ALL'
short4 __OVERLOAD__ name(short4 x, short4 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1196:21: note: expanded from macro '__CLFN_ALL'
short8 __OVERLOAD__ name(short8 x, short8 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1197:22: note: expanded from macro '__CLFN_ALL'
short16 __OVERLOAD__ name(short16 x, short16 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1199:22: note: expanded from macro '__CLFN_ALL'
ushort2 __OVERLOAD__ name(ushort2 x, ushort2 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1200:22: note: expanded from macro '__CLFN_ALL'
ushort3 __OVERLOAD__ name(ushort3 x, ushort3 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1201:22: note: expanded from macro '__CLFN_ALL'
ushort4 __OVERLOAD__ name(ushort4 x, ushort4 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1202:22: note: expanded from macro '__CLFN_ALL'
ushort8 __OVERLOAD__ name(ushort8 x, ushort8 y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1203:23: note: expanded from macro '__CLFN_ALL'
ushort16 __OVERLOAD__ name(ushort16 x, ushort16 y); \
                      ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1205:19: note: expanded from macro '__CLFN_ALL'
int2 __OVERLOAD__ name(int2 x, int2 y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1206:19: note: expanded from macro '__CLFN_ALL'
int3 __OVERLOAD__ name(int3 x, int3 y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1207:19: note: expanded from macro '__CLFN_ALL'
int4 __OVERLOAD__ name(int4 x, int4 y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1208:19: note: expanded from macro '__CLFN_ALL'
int8 __OVERLOAD__ name(int8 x, int8 y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1209:20: note: expanded from macro '__CLFN_ALL'
int16 __OVERLOAD__ name(int16 x, int16 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1211:20: note: expanded from macro '__CLFN_ALL'
uint2 __OVERLOAD__ name(uint2 x, uint2 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1212:20: note: expanded from macro '__CLFN_ALL'
uint3 __OVERLOAD__ name(uint3 x, uint3 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1213:20: note: expanded from macro '__CLFN_ALL'
uint4 __OVERLOAD__ name(uint4 x, uint4 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1214:20: note: expanded from macro '__CLFN_ALL'
uint8 __OVERLOAD__ name(uint8 x, uint8 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1215:21: note: expanded from macro '__CLFN_ALL'
uint16 __OVERLOAD__ name(uint16 x, uint16 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1217:20: note: expanded from macro '__CLFN_ALL'
long2 __OVERLOAD__ name(long2 x, long2 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1218:20: note: expanded from macro '__CLFN_ALL'
long3 __OVERLOAD__ name(long3 x, long3 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1219:20: note: expanded from macro '__CLFN_ALL'
long4 __OVERLOAD__ name(long4 x, long4 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1220:20: note: expanded from macro '__CLFN_ALL'
long8 __OVERLOAD__ name(long8 x, long8 y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1221:21: note: expanded from macro '__CLFN_ALL'
long16 __OVERLOAD__ name(long16 x, long16 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1223:21: note: expanded from macro '__CLFN_ALL'
ulong2 __OVERLOAD__ name(ulong2 x, ulong2 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1224:21: note: expanded from macro '__CLFN_ALL'
ulong3 __OVERLOAD__ name(ulong3 x, ulong3 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1225:21: note: expanded from macro '__CLFN_ALL'
ulong4 __OVERLOAD__ name(ulong4 x, ulong4 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1226:21: note: expanded from macro '__CLFN_ALL'
ulong8 __OVERLOAD__ name(ulong8 x, ulong8 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4822:12: note: candidate function
__CLFN_ALL(max);
           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1227:22: note: expanded from macro '__CLFN_ALL'
ulong16 __OVERLOAD__ name(ulong16 x, ulong16 y); 
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1291:49: note: expanded from macro '__CLFN_ALL_MODD'
#define __CLFN_ALL_MODD(name) char __OVERLOAD__ name(char x, char y); \
                                                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1292:20: note: expanded from macro '__CLFN_ALL_MODD'
char2 __OVERLOAD__ name(char2 x, char y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1293:20: note: expanded from macro '__CLFN_ALL_MODD'
char3 __OVERLOAD__ name(char3 x, char y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1294:20: note: expanded from macro '__CLFN_ALL_MODD'
char4 __OVERLOAD__ name(char4 x, char y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1295:20: note: expanded from macro '__CLFN_ALL_MODD'
char8 __OVERLOAD__ name(char8 x, char y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1296:21: note: expanded from macro '__CLFN_ALL_MODD'
char16 __OVERLOAD__ name(char16 x, char y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1297:20: note: expanded from macro '__CLFN_ALL_MODD'
uchar __OVERLOAD__ name(uchar x, uchar y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1298:21: note: expanded from macro '__CLFN_ALL_MODD'
uchar2 __OVERLOAD__ name(uchar2 x, uchar y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1299:21: note: expanded from macro '__CLFN_ALL_MODD'
uchar3 __OVERLOAD__ name(uchar3 x, uchar y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1300:21: note: expanded from macro '__CLFN_ALL_MODD'
uchar4 __OVERLOAD__ name(uchar4 x, uchar y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1301:21: note: expanded from macro '__CLFN_ALL_MODD'
uchar8 __OVERLOAD__ name(uchar8 x, uchar y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1302:22: note: expanded from macro '__CLFN_ALL_MODD'
uchar16 __OVERLOAD__ name(uchar16 x,uchar y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1303:20: note: expanded from macro '__CLFN_ALL_MODD'
short __OVERLOAD__ name(short x, short y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1304:21: note: expanded from macro '__CLFN_ALL_MODD'
short2 __OVERLOAD__ name(short2 x, short y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1305:21: note: expanded from macro '__CLFN_ALL_MODD'
short3 __OVERLOAD__ name(short3 x, short y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1306:21: note: expanded from macro '__CLFN_ALL_MODD'
short4 __OVERLOAD__ name(short4 x, short y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1307:21: note: expanded from macro '__CLFN_ALL_MODD'
short8 __OVERLOAD__ name(short8 x, short y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1308:22: note: expanded from macro '__CLFN_ALL_MODD'
short16 __OVERLOAD__ name(short16 x, short y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1309:21: note: expanded from macro '__CLFN_ALL_MODD'
ushort __OVERLOAD__ name(ushort x, ushort y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1310:22: note: expanded from macro '__CLFN_ALL_MODD'
ushort2 __OVERLOAD__ name(ushort2 x, ushort y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1311:22: note: expanded from macro '__CLFN_ALL_MODD'
ushort3 __OVERLOAD__ name(ushort3 x, ushort y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1312:22: note: expanded from macro '__CLFN_ALL_MODD'
ushort4 __OVERLOAD__ name(ushort4 x, ushort y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1313:22: note: expanded from macro '__CLFN_ALL_MODD'
ushort8 __OVERLOAD__ name(ushort8 x, ushort y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1314:23: note: expanded from macro '__CLFN_ALL_MODD'
ushort16 __OVERLOAD__ name(ushort16 x, ushort y); \
                      ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1315:18: note: expanded from macro '__CLFN_ALL_MODD'
int __OVERLOAD__ name(int x, int y); \
                 ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1316:19: note: expanded from macro '__CLFN_ALL_MODD'
int2 __OVERLOAD__ name(int2 x, int y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1317:19: note: expanded from macro '__CLFN_ALL_MODD'
int3 __OVERLOAD__ name(int3 x, int y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1318:19: note: expanded from macro '__CLFN_ALL_MODD'
int4 __OVERLOAD__ name(int4 x, int y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1319:19: note: expanded from macro '__CLFN_ALL_MODD'
int8 __OVERLOAD__ name(int8 x, int y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1320:20: note: expanded from macro '__CLFN_ALL_MODD'
int16 __OVERLOAD__ name(int16 x, int y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1321:19: note: expanded from macro '__CLFN_ALL_MODD'
uint __OVERLOAD__ name(uint x, uint y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1322:20: note: expanded from macro '__CLFN_ALL_MODD'
uint2 __OVERLOAD__ name(uint2 x, uint y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1323:20: note: expanded from macro '__CLFN_ALL_MODD'
uint3 __OVERLOAD__ name(uint3 x, uint y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1324:20: note: expanded from macro '__CLFN_ALL_MODD'
uint4 __OVERLOAD__ name(uint4 x, uint y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1325:20: note: expanded from macro '__CLFN_ALL_MODD'
uint8 __OVERLOAD__ name(uint8 x, uint y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1326:21: note: expanded from macro '__CLFN_ALL_MODD'
uint16 __OVERLOAD__ name(uint16 x, uint y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1327:19: note: expanded from macro '__CLFN_ALL_MODD'
long __OVERLOAD__ name(long x, long y); \
                  ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1328:20: note: expanded from macro '__CLFN_ALL_MODD'
long2 __OVERLOAD__ name(long2 x, long y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1329:20: note: expanded from macro '__CLFN_ALL_MODD'
long3 __OVERLOAD__ name(long3 x, long y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1330:20: note: expanded from macro '__CLFN_ALL_MODD'
long4 __OVERLOAD__ name(long4 x, long y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1331:20: note: expanded from macro '__CLFN_ALL_MODD'
long8 __OVERLOAD__ name(long8 x, long y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1332:21: note: expanded from macro '__CLFN_ALL_MODD'
long16 __OVERLOAD__ name(long16 x, long y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1333:20: note: expanded from macro '__CLFN_ALL_MODD'
ulong __OVERLOAD__ name(ulong x, ulong y); \
                   ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1334:21: note: expanded from macro '__CLFN_ALL_MODD'
ulong2 __OVERLOAD__ name(ulong2 x, ulong y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1335:21: note: expanded from macro '__CLFN_ALL_MODD'
ulong3 __OVERLOAD__ name(ulong3 x, ulong y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1336:21: note: expanded from macro '__CLFN_ALL_MODD'
ulong4 __OVERLOAD__ name(ulong4 x, ulong y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1337:21: note: expanded from macro '__CLFN_ALL_MODD'
ulong8 __OVERLOAD__ name(ulong8 x, ulong y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4823:17: note: candidate function
__CLFN_ALL_MODD(max);
                ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1338:22: note: expanded from macro '__CLFN_ALL_MODD'
ulong16 __OVERLOAD__ name(ulong16 x, ulong y); \
                     ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4824:15: note: candidate function
__CLFN_FD_2FD(max);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1010:21: note: expanded from macro '__CLFN_FD_2FD'
float2 __OVERLOAD__ name(float2 x, float2 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4824:15: note: candidate function
__CLFN_FD_2FD(max);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1011:21: note: expanded from macro '__CLFN_FD_2FD'
float3 __OVERLOAD__ name(float3 x, float3 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4824:15: note: candidate function
__CLFN_FD_2FD(max);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1012:21: note: expanded from macro '__CLFN_FD_2FD'
float4 __OVERLOAD__ name(float4 x, float4 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4824:15: note: candidate function
__CLFN_FD_2FD(max);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1013:21: note: expanded from macro '__CLFN_FD_2FD'
float8 __OVERLOAD__ name(float8 x, float8 y); \
                    ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4824:15: note: candidate function
__CLFN_FD_2FD(max);
              ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:1014:22: note: expanded from macro '__CLFN_FD_2FD'
float16 __OVERLOAD__ name(float16 x, float16 y);
                     ^
<program source>:131:7: warning: no previous prototype for function 'MWC_AddMod64'
ulong MWC_AddMod64(ulong a, ulong b, ulong M) { ulong v=a+b; if( (v>=M) || (convert_float(v) < convert_float(a)) ) v=v-M; return v; } ulong MWC_MulMod64(ulong a, ulong b, ulong M) { ulong r=0; while(a!=0){ if(a&1) r=MWC_AddMod64(r,b,M); b=MWC_AddMod64(b,b,M); a=a>>1; } return r; } ulong MWC_PowMod64(ulong a, ulong e, ulong M) { ulong sqr=a, acc=1; while(e!=0){ if(e&1) acc=MWC_MulMod64(acc,sqr,M); sqr=MWC_MulMod64(sqr,sqr,M); e=e>>1; } return acc; } uint2 MWC_SkipImpl_Mod64(uint2 curr, ulong A, ulong M, ulong distance) { ulong m=MWC_PowMod64(A, distance, M); ulong x=curr.x*(ulong)A+curr.y; x=MWC_MulMod64(x, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } uint2 MWC_SeedImpl_Mod64(ulong A, ulong M, uint vecSize, uint vecOffset, ulong streamBase, ulong streamGap) { enum{ MWC_BASEID = 4077358422479273989UL }; ulong dist=streamBase + (get_global_id(0)*vecSize+vecOffset)*streamGap; ulong m=MWC_PowMod64(A, dist, M); ulong x=MWC_MulMod64(MWC_BASEID, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } typedef struct{ uint x; uint c; } mwc64x_state_t; enum{ MWC64X_A = 4294883355U }; enum{ MWC64X_M = 18446383549859758079UL }; void MWC64X_Step(mwc64x_state_t *s) { uint X=s->x, C=s->c; uint Xn=MWC64X_A*X+C; uint carry=(uint)(Xn<C); uint Cn=mad_hi(MWC64X_A,X,carry); s->x=Xn; s->c=Cn; } void MWC64X_Skip(mwc64x_state_t *s, ulong distance) { uint2 tmp=MWC_SkipImpl_Mod64((uint2)(s->x,s->c), MWC64X_A, MWC64X_M, distance); s->x=tmp.x; s->c=tmp.y; } void MWC64X_SeedStreams(mwc64x_state_t *s, ulong baseOffset, ulong perStreamOffset) { uint2 tmp=MWC_SeedImpl_Mod64(MWC64X_A, MWC64X_M, 1, 0, baseOffset, perStreamOffset); s->x=tmp.x; s->c=tmp.y; } uint MWC64X_NextUint(mwc64x_state_t *s) { uint res=s->x ^ s->c; MWC64X_Step(s); return res; } typedef enum { UndefinedNoise, UniformNoise, GaussianNoise, MultiplicativeGaussianNoise, ImpulseNoise, LaplacianNoise, PoissonNoise, RandomNoise } NoiseType; float mwcReadPseudoRandomValue(mwc64x_state_t* rng) { return (1.0f * MWC64X_NextUint(rng)) / (float)(0xffffffff); } float mwcGenerateDifferentialNoise(mwc64x_state_t* r, CLQuantum pixel, NoiseType noise_type, float attenuate) { float alpha, beta, noise, sigma; noise = 0.0f; alpha=mwcReadPseudoRandomValue(r); switch(noise_type) { case UniformNoise: default: { noise=(pixel+QuantumRange*SigmaUniform*(alpha-0.5f)); break; } case GaussianNoise: { float gamma, tau; if (alpha == 0.0f) alpha=1.0f; beta=mwcReadPseudoRandomValue(r); gamma=sqrt(-2.0f*log(alpha)); sigma=gamma*cospi((2.0f*beta)); tau=gamma*sinpi((2.0f*beta)); noise=(float)(pixel+sqrt((float) pixel)*SigmaGaussian*sigma+ QuantumRange*TauGaussian*tau); break; } case ImpulseNoise: { if (alpha < (SigmaImpulse/2.0f)) noise=0.0f; else if (alpha >= (1.0f-(SigmaImpulse/2.0f))) noise=(float)QuantumRange; else noise=(float)pixel; break; } case LaplacianNoise: { if (alpha <= 0.5f) { if (alpha <= MagickEpsilon) noise=(float) (pixel-QuantumRange); else noise=(float) (pixel+QuantumRange*SigmaLaplacian*log(2.0f*alpha)+ 0.5f); break; } beta=1.0f-alpha; if (beta <= (0.5f*MagickEpsilon)) noise=(float) (pixel+QuantumRange); else noise=(float) (pixel-QuantumRange*SigmaLaplacian*log(2.0f*beta)+0.5f); break; } case MultiplicativeGaussianNoise: { sigma=1.0f; if (alpha > MagickEpsilon) sigma=sqrt(-2.0f*log(alpha)); beta=mwcReadPseudoRandomValue(r); noise=(float) (pixel+pixel*SigmaMultiplicativeGaussian*sigma* cospi((float) (2.0f*beta))/2.0f); break; } case PoissonNoise: { float poisson; unsigned int i; poisson=exp(-SigmaPoisson*QuantumScale*pixel); for (i=0; alpha > poisson; i++) { beta=mwcReadPseudoRandomValue(r); alpha*=beta; } noise=(float) (QuantumRange*i/SigmaPoisson); break; } case RandomNoise: { noise=(float) (QuantumRange*SigmaRandom*alpha); break; } }; return noise; } __kernel void GenerateNoiseImage(const __global CLPixelType* inputImage, __global CLPixelType* filteredImage ,const unsigned int inputPixelCount, const unsigned int pixelsPerWorkItem ,const ChannelType channel ,const NoiseType noise_type, const float attenuate ,const unsigned int seed0, const unsigned int seed1 ,const unsigned int numRandomNumbersPerPixel) { mwc64x_state_t rng; rng.x = seed0; rng.c = seed1; uint span = pixelsPerWorkItem * numRandomNumbersPerPixel; uint offset = span * get_local_size(0) * get_group_id(0); MWC64X_SeedStreams(&rng, offset, span); uint pos = get_local_size(0) * get_group_id(0) * pixelsPerWorkItem + get_local_id(0); uint count = pixelsPerWorkItem; while (count > 0) { if (pos < inputPixelCount) { CLPixelType p = inputImage[pos]; if ((channel&RedChannel)!=0) { setRed(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getRed(p),noise_type,attenuate))); } if ((channel&GreenChannel)!=0) { setGreen(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getGreen(p),noise_type,attenuate))); } if ((channel&BlueChannel)!=0) { setBlue(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getBlue(p),noise_type,attenuate))); } if ((channel & OpacityChannel) != 0) { setOpacity(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getOpacity(p),noise_type,attenuate))); } filteredImage[pos] = p; } pos += get_local_size(0); --count; } }
      ^
<program source>:131:141: warning: no previous prototype for function 'MWC_MulMod64'
ulong MWC_AddMod64(ulong a, ulong b, ulong M) { ulong v=a+b; if( (v>=M) || (convert_float(v) < convert_float(a)) ) v=v-M; return v; } ulong MWC_MulMod64(ulong a, ulong b, ulong M) { ulong r=0; while(a!=0){ if(a&1) r=MWC_AddMod64(r,b,M); b=MWC_AddMod64(b,b,M); a=a>>1; } return r; } ulong MWC_PowMod64(ulong a, ulong e, ulong M) { ulong sqr=a, acc=1; while(e!=0){ if(e&1) acc=MWC_MulMod64(acc,sqr,M); sqr=MWC_MulMod64(sqr,sqr,M); e=e>>1; } return acc; } uint2 MWC_SkipImpl_Mod64(uint2 curr, ulong A, ulong M, ulong distance) { ulong m=MWC_PowMod64(A, distance, M); ulong x=curr.x*(ulong)A+curr.y; x=MWC_MulMod64(x, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } uint2 MWC_SeedImpl_Mod64(ulong A, ulong M, uint vecSize, uint vecOffset, ulong streamBase, ulong streamGap) { enum{ MWC_BASEID = 4077358422479273989UL }; ulong dist=streamBase + (get_global_id(0)*vecSize+vecOffset)*streamGap; ulong m=MWC_PowMod64(A, dist, M); ulong x=MWC_MulMod64(MWC_BASEID, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } typedef struct{ uint x; uint c; } mwc64x_state_t; enum{ MWC64X_A = 4294883355U }; enum{ MWC64X_M = 18446383549859758079UL }; void MWC64X_Step(mwc64x_state_t *s) { uint X=s->x, C=s->c; uint Xn=MWC64X_A*X+C; uint carry=(uint)(Xn<C); uint Cn=mad_hi(MWC64X_A,X,carry); s->x=Xn; s->c=Cn; } void MWC64X_Skip(mwc64x_state_t *s, ulong distance) { uint2 tmp=MWC_SkipImpl_Mod64((uint2)(s->x,s->c), MWC64X_A, MWC64X_M, distance); s->x=tmp.x; s->c=tmp.y; } void MWC64X_SeedStreams(mwc64x_state_t *s, ulong baseOffset, ulong perStreamOffset) { uint2 tmp=MWC_SeedImpl_Mod64(MWC64X_A, MWC64X_M, 1, 0, baseOffset, perStreamOffset); s->x=tmp.x; s->c=tmp.y; } uint MWC64X_NextUint(mwc64x_state_t *s) { uint res=s->x ^ s->c; MWC64X_Step(s); return res; } typedef enum { UndefinedNoise, UniformNoise, GaussianNoise, MultiplicativeGaussianNoise, ImpulseNoise, LaplacianNoise, PoissonNoise, RandomNoise } NoiseType; float mwcReadPseudoRandomValue(mwc64x_state_t* rng) { return (1.0f * MWC64X_NextUint(rng)) / (float)(0xffffffff); } float mwcGenerateDifferentialNoise(mwc64x_state_t* r, CLQuantum pixel, NoiseType noise_type, float attenuate) { float alpha, beta, noise, sigma; noise = 0.0f; alpha=mwcReadPseudoRandomValue(r); switch(noise_type) { case UniformNoise: default: { noise=(pixel+QuantumRange*SigmaUniform*(alpha-0.5f)); break; } case GaussianNoise: { float gamma, tau; if (alpha == 0.0f) alpha=1.0f; beta=mwcReadPseudoRandomValue(r); gamma=sqrt(-2.0f*log(alpha)); sigma=gamma*cospi((2.0f*beta)); tau=gamma*sinpi((2.0f*beta)); noise=(float)(pixel+sqrt((float) pixel)*SigmaGaussian*sigma+ QuantumRange*TauGaussian*tau); break; } case ImpulseNoise: { if (alpha < (SigmaImpulse/2.0f)) noise=0.0f; else if (alpha >= (1.0f-(SigmaImpulse/2.0f))) noise=(float)QuantumRange; else noise=(float)pixel; break; } case LaplacianNoise: { if (alpha <= 0.5f) { if (alpha <= MagickEpsilon) noise=(float) (pixel-QuantumRange); else noise=(float) (pixel+QuantumRange*SigmaLaplacian*log(2.0f*alpha)+ 0.5f); break; } beta=1.0f-alpha; if (beta <= (0.5f*MagickEpsilon)) noise=(float) (pixel+QuantumRange); else noise=(float) (pixel-QuantumRange*SigmaLaplacian*log(2.0f*beta)+0.5f); break; } case MultiplicativeGaussianNoise: { sigma=1.0f; if (alpha > MagickEpsilon) sigma=sqrt(-2.0f*log(alpha)); beta=mwcReadPseudoRandomValue(r); noise=(float) (pixel+pixel*SigmaMultiplicativeGaussian*sigma* cospi((float) (2.0f*beta))/2.0f); break; } case PoissonNoise: { float poisson; unsigned int i; poisson=exp(-SigmaPoisson*QuantumScale*pixel); for (i=0; alpha > poisson; i++) { beta=mwcReadPseudoRandomValue(r); alpha*=beta; } noise=(float) (QuantumRange*i/SigmaPoisson); break; } case RandomNoise: { noise=(float) (QuantumRange*SigmaRandom*alpha); break; } }; return noise; } __kernel void GenerateNoiseImage(const __global CLPixelType* inputImage, __global CLPixelType* filteredImage ,const unsigned int inputPixelCount, const unsigned int pixelsPerWorkItem ,const ChannelType channel ,const NoiseType noise_type, const float attenuate ,const unsigned int seed0, const unsigned int seed1 ,const unsigned int numRandomNumbersPerPixel) { mwc64x_state_t rng; rng.x = seed0; rng.c = seed1; uint span = pixelsPerWorkItem * numRandomNumbersPerPixel; uint offset = span * get_local_size(0) * get_group_id(0); MWC64X_SeedStreams(&rng, offset, span); uint pos = get_local_size(0) * get_group_id(0) * pixelsPerWorkItem + get_local_id(0); uint count = pixelsPerWorkItem; while (count > 0) { if (pos < inputPixelCount) { CLPixelType p = inputImage[pos]; if ((channel&RedChannel)!=0) { setRed(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getRed(p),noise_type,attenuate))); } if ((channel&GreenChannel)!=0) { setGreen(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getGreen(p),noise_type,attenuate))); } if ((channel&BlueChannel)!=0) { setBlue(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getBlue(p),noise_type,attenuate))); } if ((channel & OpacityChannel) != 0) { setOpacity(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getOpacity(p),noise_type,attenuate))); } filteredImage[pos] = p; } pos += get_local_size(0); --count; } }
                                                                                                                                            ^
<program source>:131:289: warning: no previous prototype for function 'MWC_PowMod64'
ulong MWC_AddMod64(ulong a, ulong b, ulong M) { ulong v=a+b; if( (v>=M) || (convert_float(v) < convert_float(a)) ) v=v-M; return v; } ulong MWC_MulMod64(ulong a, ulong b, ulong M) { ulong r=0; while(a!=0){ if(a&1) r=MWC_AddMod64(r,b,M); b=MWC_AddMod64(b,b,M); a=a>>1; } return r; } ulong MWC_PowMod64(ulong a, ulong e, ulong M) { ulong sqr=a, acc=1; while(e!=0){ if(e&1) acc=MWC_MulMod64(acc,sqr,M); sqr=MWC_MulMod64(sqr,sqr,M); e=e>>1; } return acc; } uint2 MWC_SkipImpl_Mod64(uint2 curr, ulong A, ulong M, ulong distance) { ulong m=MWC_PowMod64(A, distance, M); ulong x=curr.x*(ulong)A+curr.y; x=MWC_MulMod64(x, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } uint2 MWC_SeedImpl_Mod64(ulong A, ulong M, uint vecSize, uint vecOffset, ulong streamBase, ulong streamGap) { enum{ MWC_BASEID = 4077358422479273989UL }; ulong dist=streamBase + (get_global_id(0)*vecSize+vecOffset)*streamGap; ulong m=MWC_PowMod64(A, dist, M); ulong x=MWC_MulMod64(MWC_BASEID, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } typedef struct{ uint x; uint c; } mwc64x_state_t; enum{ MWC64X_A = 4294883355U }; enum{ MWC64X_M = 18446383549859758079UL }; void MWC64X_Step(mwc64x_state_t *s) { uint X=s->x, C=s->c; uint Xn=MWC64X_A*X+C; uint carry=(uint)(Xn<C); uint Cn=mad_hi(MWC64X_A,X,carry); s->x=Xn; s->c=Cn; } void MWC64X_Skip(mwc64x_state_t *s, ulong distance) { uint2 tmp=MWC_SkipImpl_Mod64((uint2)(s->x,s->c), MWC64X_A, MWC64X_M, distance); s->x=tmp.x; s->c=tmp.y; } void MWC64X_SeedStreams(mwc64x_state_t *s, ulong baseOffset, ulong perStreamOffset) { uint2 tmp=MWC_SeedImpl_Mod64(MWC64X_A, MWC64X_M, 1, 0, baseOffset, perStreamOffset); s->x=tmp.x; s->c=tmp.y; } uint MWC64X_NextUint(mwc64x_state_t *s) { uint res=s->x ^ s->c; MWC64X_Step(s); return res; } typedef enum { UndefinedNoise, UniformNoise, GaussianNoise, MultiplicativeGaussianNoise, ImpulseNoise, LaplacianNoise, PoissonNoise, RandomNoise } NoiseType; float mwcReadPseudoRandomValue(mwc64x_state_t* rng) { return (1.0f * MWC64X_NextUint(rng)) / (float)(0xffffffff); } float mwcGenerateDifferentialNoise(mwc64x_state_t* r, CLQuantum pixel, NoiseType noise_type, float attenuate) { float alpha, beta, noise, sigma; noise = 0.0f; alpha=mwcReadPseudoRandomValue(r); switch(noise_type) { case UniformNoise: default: { noise=(pixel+QuantumRange*SigmaUniform*(alpha-0.5f)); break; } case GaussianNoise: { float gamma, tau; if (alpha == 0.0f) alpha=1.0f; beta=mwcReadPseudoRandomValue(r); gamma=sqrt(-2.0f*log(alpha)); sigma=gamma*cospi((2.0f*beta)); tau=gamma*sinpi((2.0f*beta)); noise=(float)(pixel+sqrt((float) pixel)*SigmaGaussian*sigma+ QuantumRange*TauGaussian*tau); break; } case ImpulseNoise: { if (alpha < (SigmaImpulse/2.0f)) noise=0.0f; else if (alpha >= (1.0f-(SigmaImpulse/2.0f))) noise=(float)QuantumRange; else noise=(float)pixel; break; } case LaplacianNoise: { if (alpha <= 0.5f) { if (alpha <= MagickEpsilon) noise=(float) (pixel-QuantumRange); else noise=(float) (pixel+QuantumRange*SigmaLaplacian*log(2.0f*alpha)+ 0.5f); break; } beta=1.0f-alpha; if (beta <= (0.5f*MagickEpsilon)) noise=(float) (pixel+QuantumRange); else noise=(float) (pixel-QuantumRange*SigmaLaplacian*log(2.0f*beta)+0.5f); break; } case MultiplicativeGaussianNoise: { sigma=1.0f; if (alpha > MagickEpsilon) sigma=sqrt(-2.0f*log(alpha)); beta=mwcReadPseudoRandomValue(r); noise=(float) (pixel+pixel*SigmaMultiplicativeGaussian*sigma* cospi((float) (2.0f*beta))/2.0f); break; } case PoissonNoise: { float poisson; unsigned int i; poisson=exp(-SigmaPoisson*QuantumScale*pixel); for (i=0; alpha > poisson; i++) { beta=mwcReadPseudoRandomValue(r); alpha*=beta; } noise=(float) (QuantumRange*i/SigmaPoisson); break; } case RandomNoise: { noise=(float) (QuantumRange*SigmaRandom*alpha); break; } }; return noise; } __kernel void GenerateNoiseImage(const __global CLPixelType* inputImage, __global CLPixelType* filteredImage ,const unsigned int inputPixelCount, const unsigned int pixelsPerWorkItem ,const ChannelType channel ,const NoiseType noise_type, const float attenuate ,const unsigned int seed0, const unsigned int seed1 ,const unsigned int numRandomNumbersPerPixel) { mwc64x_state_t rng; rng.x = seed0; rng.c = seed1; uint span = pixelsPerWorkItem * numRandomNumbersPerPixel; uint offset = span * get_local_size(0) * get_group_id(0); MWC64X_SeedStreams(&rng, offset, span); uint pos = get_local_size(0) * get_group_id(0) * pixelsPerWorkItem + get_local_id(0); uint count = pixelsPerWorkItem; while (count > 0) { if (pos < inputPixelCount) { CLPixelType p = inputImage[pos]; if ((channel&RedChannel)!=0) { setRed(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getRed(p),noise_type,attenuate))); } if ((channel&GreenChannel)!=0) { setGreen(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getGreen(p),noise_type,attenuate))); } if ((channel&BlueChannel)!=0) { setBlue(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getBlue(p),noise_type,attenuate))); } if ((channel & OpacityChannel) != 0) { setOpacity(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getOpacity(p),noise_type,attenuate))); } filteredImage[pos] = p; } pos += get_local_size(0); --count; } }
                                                                                                                                                                                                                                                                                                ^
<program source>:131:460: warning: no previous prototype for function 'MWC_SkipImpl_Mod64'
ulong MWC_AddMod64(ulong a, ulong b, ulong M) { ulong v=a+b; if( (v>=M) || (convert_float(v) < convert_float(a)) ) v=v-M; return v; } ulong MWC_MulMod64(ulong a, ulong b, ulong M) { ulong r=0; while(a!=0){ if(a&1) r=MWC_AddMod64(r,b,M); b=MWC_AddMod64(b,b,M); a=a>>1; } return r; } ulong MWC_PowMod64(ulong a, ulong e, ulong M) { ulong sqr=a, acc=1; while(e!=0){ if(e&1) acc=MWC_MulMod64(acc,sqr,M); sqr=MWC_MulMod64(sqr,sqr,M); e=e>>1; } return acc; } uint2 MWC_SkipImpl_Mod64(uint2 curr, ulong A, ulong M, ulong distance) { ulong m=MWC_PowMod64(A, distance, M); ulong x=curr.x*(ulong)A+curr.y; x=MWC_MulMod64(x, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } uint2 MWC_SeedImpl_Mod64(ulong A, ulong M, uint vecSize, uint vecOffset, ulong streamBase, ulong streamGap) { enum{ MWC_BASEID = 4077358422479273989UL }; ulong dist=streamBase + (get_global_id(0)*vecSize+vecOffset)*streamGap; ulong m=MWC_PowMod64(A, dist, M); ulong x=MWC_MulMod64(MWC_BASEID, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } typedef struct{ uint x; uint c; } mwc64x_state_t; enum{ MWC64X_A = 4294883355U }; enum{ MWC64X_M = 18446383549859758079UL }; void MWC64X_Step(mwc64x_state_t *s) { uint X=s->x, C=s->c; uint Xn=MWC64X_A*X+C; uint carry=(uint)(Xn<C); uint Cn=mad_hi(MWC64X_A,X,carry); s->x=Xn; s->c=Cn; } void MWC64X_Skip(mwc64x_state_t *s, ulong distance) { uint2 tmp=MWC_SkipImpl_Mod64((uint2)(s->x,s->c), MWC64X_A, MWC64X_M, distance); s->x=tmp.x; s->c=tmp.y; } void MWC64X_SeedStreams(mwc64x_state_t *s, ulong baseOffset, ulong perStreamOffset) { uint2 tmp=MWC_SeedImpl_Mod64(MWC64X_A, MWC64X_M, 1, 0, baseOffset, perStreamOffset); s->x=tmp.x; s->c=tmp.y; } uint MWC64X_NextUint(mwc64x_state_t *s) { uint res=s->x ^ s->c; MWC64X_Step(s); return res; } typedef enum { UndefinedNoise, UniformNoise, GaussianNoise, MultiplicativeGaussianNoise, ImpulseNoise, LaplacianNoise, PoissonNoise, RandomNoise } NoiseType; float mwcReadPseudoRandomValue(mwc64x_state_t* rng) { return (1.0f * MWC64X_NextUint(rng)) / (float)(0xffffffff); } float mwcGenerateDifferentialNoise(mwc64x_state_t* r, CLQuantum pixel, NoiseType noise_type, float attenuate) { float alpha, beta, noise, sigma; noise = 0.0f; alpha=mwcReadPseudoRandomValue(r); switch(noise_type) { case UniformNoise: default: { noise=(pixel+QuantumRange*SigmaUniform*(alpha-0.5f)); break; } case GaussianNoise: { float gamma, tau; if (alpha == 0.0f) alpha=1.0f; beta=mwcReadPseudoRandomValue(r); gamma=sqrt(-2.0f*log(alpha)); sigma=gamma*cospi((2.0f*beta)); tau=gamma*sinpi((2.0f*beta)); noise=(float)(pixel+sqrt((float) pixel)*SigmaGaussian*sigma+ QuantumRange*TauGaussian*tau); break; } case ImpulseNoise: { if (alpha < (SigmaImpulse/2.0f)) noise=0.0f; else if (alpha >= (1.0f-(SigmaImpulse/2.0f))) noise=(float)QuantumRange; else noise=(float)pixel; break; } case LaplacianNoise: { if (alpha <= 0.5f) { if (alpha <= MagickEpsilon) noise=(float) (pixel-QuantumRange); else noise=(float) (pixel+QuantumRange*SigmaLaplacian*log(2.0f*alpha)+ 0.5f); break; } beta=1.0f-alpha; if (beta <= (0.5f*MagickEpsilon)) noise=(float) (pixel+QuantumRange); else noise=(float) (pixel-QuantumRange*SigmaLaplacian*log(2.0f*beta)+0.5f); break; } case MultiplicativeGaussianNoise: { sigma=1.0f; if (alpha > MagickEpsilon) sigma=sqrt(-2.0f*log(alpha)); beta=mwcReadPseudoRandomValue(r); noise=(float) (pixel+pixel*SigmaMultiplicativeGaussian*sigma* cospi((float) (2.0f*beta))/2.0f); break; } case PoissonNoise: { float poisson; unsigned int i; poisson=exp(-SigmaPoisson*QuantumScale*pixel); for (i=0; alpha > poisson; i++) { beta=mwcReadPseudoRandomValue(r); alpha*=beta; } noise=(float) (QuantumRange*i/SigmaPoisson); break; } case RandomNoise: { noise=(float) (QuantumRange*SigmaRandom*alpha); break; } }; return noise; } __kernel void GenerateNoiseImage(const __global CLPixelType* inputImage, __global CLPixelType* filteredImage ,const unsigned int inputPixelCount, const unsigned int pixelsPerWorkItem ,const ChannelType channel ,const NoiseType noise_type, const float attenuate ,const unsigned int seed0, const unsigned int seed1 ,const unsigned int numRandomNumbersPerPixel) { mwc64x_state_t rng; rng.x = seed0; rng.c = seed1; uint span = pixelsPerWorkItem * numRandomNumbersPerPixel; uint offset = span * get_local_size(0) * get_group_id(0); MWC64X_SeedStreams(&rng, offset, span); uint pos = get_local_size(0) * get_group_id(0) * pixelsPerWorkItem + get_local_id(0); uint count = pixelsPerWorkItem; while (count > 0) { if (pos < inputPixelCount) { CLPixelType p = inputImage[pos]; if ((channel&RedChannel)!=0) { setRed(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getRed(p),noise_type,attenuate))); } if ((channel&GreenChannel)!=0) { setGreen(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getGreen(p),noise_type,attenuate))); } if ((channel&BlueChannel)!=0) { setBlue(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getBlue(p),noise_type,attenuate))); } if ((channel & OpacityChannel) != 0) { setOpacity(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getOpacity(p),noise_type,attenuate))); } filteredImage[pos] = p; } pos += get_local_size(0); --count; } }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
<program source>:131:672: warning: no previous prototype for function 'MWC_SeedImpl_Mod64'
ulong MWC_AddMod64(ulong a, ulong b, ulong M) { ulong v=a+b; if( (v>=M) || (convert_float(v) < convert_float(a)) ) v=v-M; return v; } ulong MWC_MulMod64(ulong a, ulong b, ulong M) { ulong r=0; while(a!=0){ if(a&1) r=MWC_AddMod64(r,b,M); b=MWC_AddMod64(b,b,M); a=a>>1; } return r; } ulong MWC_PowMod64(ulong a, ulong e, ulong M) { ulong sqr=a, acc=1; while(e!=0){ if(e&1) acc=MWC_MulMod64(acc,sqr,M); sqr=MWC_MulMod64(sqr,sqr,M); e=e>>1; } return acc; } uint2 MWC_SkipImpl_Mod64(uint2 curr, ulong A, ulong M, ulong distance) { ulong m=MWC_PowMod64(A, distance, M); ulong x=curr.x*(ulong)A+curr.y; x=MWC_MulMod64(x, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } uint2 MWC_SeedImpl_Mod64(ulong A, ulong M, uint vecSize, uint vecOffset, ulong streamBase, ulong streamGap) { enum{ MWC_BASEID = 4077358422479273989UL }; ulong dist=streamBase + (get_global_id(0)*vecSize+vecOffset)*streamGap; ulong m=MWC_PowMod64(A, dist, M); ulong x=MWC_MulMod64(MWC_BASEID, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } typedef struct{ uint x; uint c; } mwc64x_state_t; enum{ MWC64X_A = 4294883355U }; enum{ MWC64X_M = 18446383549859758079UL }; void MWC64X_Step(mwc64x_state_t *s) { uint X=s->x, C=s->c; uint Xn=MWC64X_A*X+C; uint carry=(uint)(Xn<C); uint Cn=mad_hi(MWC64X_A,X,carry); s->x=Xn; s->c=Cn; } void MWC64X_Skip(mwc64x_state_t *s, ulong distance) { uint2 tmp=MWC_SkipImpl_Mod64((uint2)(s->x,s->c), MWC64X_A, MWC64X_M, distance); s->x=tmp.x; s->c=tmp.y; } void MWC64X_SeedStreams(mwc64x_state_t *s, ulong baseOffset, ulong perStreamOffset) { uint2 tmp=MWC_SeedImpl_Mod64(MWC64X_A, MWC64X_M, 1, 0, baseOffset, perStreamOffset); s->x=tmp.x; s->c=tmp.y; } uint MWC64X_NextUint(mwc64x_state_t *s) { uint res=s->x ^ s->c; MWC64X_Step(s); return res; } typedef enum { UndefinedNoise, UniformNoise, GaussianNoise, MultiplicativeGaussianNoise, ImpulseNoise, LaplacianNoise, PoissonNoise, RandomNoise } NoiseType; float mwcReadPseudoRandomValue(mwc64x_state_t* rng) { return (1.0f * MWC64X_NextUint(rng)) / (float)(0xffffffff); } float mwcGenerateDifferentialNoise(mwc64x_state_t* r, CLQuantum pixel, NoiseType noise_type, float attenuate) { float alpha, beta, noise, sigma; noise = 0.0f; alpha=mwcReadPseudoRandomValue(r); switch(noise_type) { case UniformNoise: default: { noise=(pixel+QuantumRange*SigmaUniform*(alpha-0.5f)); break; } case GaussianNoise: { float gamma, tau; if (alpha == 0.0f) alpha=1.0f; beta=mwcReadPseudoRandomValue(r); gamma=sqrt(-2.0f*log(alpha)); sigma=gamma*cospi((2.0f*beta)); tau=gamma*sinpi((2.0f*beta)); noise=(float)(pixel+sqrt((float) pixel)*SigmaGaussian*sigma+ QuantumRange*TauGaussian*tau); break; } case ImpulseNoise: { if (alpha < (SigmaImpulse/2.0f)) noise=0.0f; else if (alpha >= (1.0f-(SigmaImpulse/2.0f))) noise=(float)QuantumRange; else noise=(float)pixel; break; } case LaplacianNoise: { if (alpha <= 0.5f) { if (alpha <= MagickEpsilon) noise=(float) (pixel-QuantumRange); else noise=(float) (pixel+QuantumRange*SigmaLaplacian*log(2.0f*alpha)+ 0.5f); break; } beta=1.0f-alpha; if (beta <= (0.5f*MagickEpsilon)) noise=(float) (pixel+QuantumRange); else noise=(float) (pixel-QuantumRange*SigmaLaplacian*log(2.0f*beta)+0.5f); break; } case MultiplicativeGaussianNoise: { sigma=1.0f; if (alpha > MagickEpsilon) sigma=sqrt(-2.0f*log(alpha)); beta=mwcReadPseudoRandomValue(r); noise=(float) (pixel+pixel*SigmaMultiplicativeGaussian*sigma* cospi((float) (2.0f*beta))/2.0f); break; } case PoissonNoise: { float poisson; unsigned int i; poisson=exp(-SigmaPoisson*QuantumScale*pixel); for (i=0; alpha > poisson; i++) { beta=mwcReadPseudoRandomValue(r); alpha*=beta; } noise=(float) (QuantumRange*i/SigmaPoisson); break; } case RandomNoise: { noise=(float) (QuantumRange*SigmaRandom*alpha); break; } }; return noise; } __kernel void GenerateNoiseImage(const __global CLPixelType* inputImage, __global CLPixelType* filteredImage ,const unsigned int inputPixelCount, const unsigned int pixelsPerWorkItem ,const ChannelType channel ,const NoiseType noise_type, const float attenuate ,const unsigned int seed0, const unsigned int seed1 ,const unsigned int numRandomNumbersPerPixel) { mwc64x_state_t rng; rng.x = seed0; rng.c = seed1; uint span = pixelsPerWorkItem * numRandomNumbersPerPixel; uint offset = span * get_local_size(0) * get_group_id(0); MWC64X_SeedStreams(&rng, offset, span); uint pos = get_local_size(0) * get_group_id(0) * pixelsPerWorkItem + get_local_id(0); uint count = pixelsPerWorkItem; while (count > 0) { if (pos < inputPixelCount) { CLPixelType p = inputImage[pos]; if ((channel&RedChannel)!=0) { setRed(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getRed(p),noise_type,attenuate))); } if ((channel&GreenChannel)!=0) { setGreen(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getGreen(p),noise_type,attenuate))); } if ((channel&BlueChannel)!=0) { setBlue(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getBlue(p),noise_type,attenuate))); } if ((channel & OpacityChannel) != 0) { setOpacity(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getOpacity(p),noise_type,attenuate))); } filteredImage[pos] = p; } pos += get_local_size(0); --count; } }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
<program source>:131:1140: warning: no previous prototype for function 'MWC64X_Step'
ulong MWC_AddMod64(ulong a, ulong b, ulong M) { ulong v=a+b; if( (v>=M) || (convert_float(v) < convert_float(a)) ) v=v-M; return v; } ulong MWC_MulMod64(ulong a, ulong b, ulong M) { ulong r=0; while(a!=0){ if(a&1) r=MWC_AddMod64(r,b,M); b=MWC_AddMod64(b,b,M); a=a>>1; } return r; } ulong MWC_PowMod64(ulong a, ulong e, ulong M) { ulong sqr=a, acc=1; while(e!=0){ if(e&1) acc=MWC_MulMod64(acc,sqr,M); sqr=MWC_MulMod64(sqr,sqr,M); e=e>>1; } return acc; } uint2 MWC_SkipImpl_Mod64(uint2 curr, ulong A, ulong M, ulong distance) { ulong m=MWC_PowMod64(A, distance, M); ulong x=curr.x*(ulong)A+curr.y; x=MWC_MulMod64(x, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } uint2 MWC_SeedImpl_Mod64(ulong A, ulong M, uint vecSize, uint vecOffset, ulong streamBase, ulong streamGap) { enum{ MWC_BASEID = 4077358422479273989UL }; ulong dist=streamBase + (get_global_id(0)*vecSize+vecOffset)*streamGap; ulong m=MWC_PowMod64(A, dist, M); ulong x=MWC_MulMod64(MWC_BASEID, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } typedef struct{ uint x; uint c; } mwc64x_state_t; enum{ MWC64X_A = 4294883355U }; enum{ MWC64X_M = 18446383549859758079UL }; void MWC64X_Step(mwc64x_state_t *s) { uint X=s->x, C=s->c; uint Xn=MWC64X_A*X+C; uint carry=(uint)(Xn<C); uint Cn=mad_hi(MWC64X_A,X,carry); s->x=Xn; s->c=Cn; } void MWC64X_Skip(mwc64x_state_t *s, ulong distance) { uint2 tmp=MWC_SkipImpl_Mod64((uint2)(s->x,s->c), MWC64X_A, MWC64X_M, distance); s->x=tmp.x; s->c=tmp.y; } void MWC64X_SeedStreams(mwc64x_state_t *s, ulong baseOffset, ulong perStreamOffset) { uint2 tmp=MWC_SeedImpl_Mod64(MWC64X_A, MWC64X_M, 1, 0, baseOffset, perStreamOffset); s->x=tmp.x; s->c=tmp.y; } uint MWC64X_NextUint(mwc64x_state_t *s) { uint res=s->x ^ s->c; MWC64X_Step(s); return res; } typedef enum { UndefinedNoise, UniformNoise, GaussianNoise, MultiplicativeGaussianNoise, ImpulseNoise, LaplacianNoise, PoissonNoise, RandomNoise } NoiseType; float mwcReadPseudoRandomValue(mwc64x_state_t* rng) { return (1.0f * MWC64X_NextUint(rng)) / (float)(0xffffffff); } float mwcGenerateDifferentialNoise(mwc64x_state_t* r, CLQuantum pixel, NoiseType noise_type, float attenuate) { float alpha, beta, noise, sigma; noise = 0.0f; alpha=mwcReadPseudoRandomValue(r); switch(noise_type) { case UniformNoise: default: { noise=(pixel+QuantumRange*SigmaUniform*(alpha-0.5f)); break; } case GaussianNoise: { float gamma, tau; if (alpha == 0.0f) alpha=1.0f; beta=mwcReadPseudoRandomValue(r); gamma=sqrt(-2.0f*log(alpha)); sigma=gamma*cospi((2.0f*beta)); tau=gamma*sinpi((2.0f*beta)); noise=(float)(pixel+sqrt((float) pixel)*SigmaGaussian*sigma+ QuantumRange*TauGaussian*tau); break; } case ImpulseNoise: { if (alpha < (SigmaImpulse/2.0f)) noise=0.0f; else if (alpha >= (1.0f-(SigmaImpulse/2.0f))) noise=(float)QuantumRange; else noise=(float)pixel; break; } case LaplacianNoise: { if (alpha <= 0.5f) { if (alpha <= MagickEpsilon) noise=(float) (pixel-QuantumRange); else noise=(float) (pixel+QuantumRange*SigmaLaplacian*log(2.0f*alpha)+ 0.5f); break; } beta=1.0f-alpha; if (beta <= (0.5f*MagickEpsilon)) noise=(float) (pixel+QuantumRange); else noise=(float) (pixel-QuantumRange*SigmaLaplacian*log(2.0f*beta)+0.5f); break; } case MultiplicativeGaussianNoise: { sigma=1.0f; if (alpha > MagickEpsilon) sigma=sqrt(-2.0f*log(alpha)); beta=mwcReadPseudoRandomValue(r); noise=(float) (pixel+pixel*SigmaMultiplicativeGaussian*sigma* cospi((float) (2.0f*beta))/2.0f); break; } case PoissonNoise: { float poisson; unsigned int i; poisson=exp(-SigmaPoisson*QuantumScale*pixel); for (i=0; alpha > poisson; i++) { beta=mwcReadPseudoRandomValue(r); alpha*=beta; } noise=(float) (QuantumRange*i/SigmaPoisson); break; } case RandomNoise: { noise=(float) (QuantumRange*SigmaRandom*alpha); break; } }; return noise; } __kernel void GenerateNoiseImage(const __global CLPixelType* inputImage, __global CLPixelType* filteredImage ,const unsigned int inputPixelCount, const unsigned int pixelsPerWorkItem ,const ChannelType channel ,const NoiseType noise_type, const float attenuate ,const unsigned int seed0, const unsigned int seed1 ,const unsigned int numRandomNumbersPerPixel) { mwc64x_state_t rng; rng.x = seed0; rng.c = seed1; uint span = pixelsPerWorkItem * numRandomNumbersPerPixel; uint offset = span * get_local_size(0) * get_group_id(0); MWC64X_SeedStreams(&rng, offset, span); uint pos = get_local_size(0) * get_group_id(0) * pixelsPerWorkItem + get_local_id(0); uint count = pixelsPerWorkItem; while (count > 0) { if (pos < inputPixelCount) { CLPixelType p = inputImage[pos]; if ((channel&RedChannel)!=0) { setRed(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getRed(p),noise_type,attenuate))); } if ((channel&GreenChannel)!=0) { setGreen(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getGreen(p),noise_type,attenuate))); } if ((channel&BlueChannel)!=0) { setBlue(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getBlue(p),noise_type,attenuate))); } if ((channel & OpacityChannel) != 0) { setOpacity(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getOpacity(p),noise_type,attenuate))); } filteredImage[pos] = p; } pos += get_local_size(0); --count; } }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
<program source>:131:1300: warning: no previous prototype for function 'MWC64X_Skip'
ulong MWC_AddMod64(ulong a, ulong b, ulong M) { ulong v=a+b; if( (v>=M) || (convert_float(v) < convert_float(a)) ) v=v-M; return v; } ulong MWC_MulMod64(ulong a, ulong b, ulong M) { ulong r=0; while(a!=0){ if(a&1) r=MWC_AddMod64(r,b,M); b=MWC_AddMod64(b,b,M); a=a>>1; } return r; } ulong MWC_PowMod64(ulong a, ulong e, ulong M) { ulong sqr=a, acc=1; while(e!=0){ if(e&1) acc=MWC_MulMod64(acc,sqr,M); sqr=MWC_MulMod64(sqr,sqr,M); e=e>>1; } return acc; } uint2 MWC_SkipImpl_Mod64(uint2 curr, ulong A, ulong M, ulong distance) { ulong m=MWC_PowMod64(A, distance, M); ulong x=curr.x*(ulong)A+curr.y; x=MWC_MulMod64(x, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } uint2 MWC_SeedImpl_Mod64(ulong A, ulong M, uint vecSize, uint vecOffset, ulong streamBase, ulong streamGap) { enum{ MWC_BASEID = 4077358422479273989UL }; ulong dist=streamBase + (get_global_id(0)*vecSize+vecOffset)*streamGap; ulong m=MWC_PowMod64(A, dist, M); ulong x=MWC_MulMod64(MWC_BASEID, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } typedef struct{ uint x; uint c; } mwc64x_state_t; enum{ MWC64X_A = 4294883355U }; enum{ MWC64X_M = 18446383549859758079UL }; void MWC64X_Step(mwc64x_state_t *s) { uint X=s->x, C=s->c; uint Xn=MWC64X_A*X+C; uint carry=(uint)(Xn<C); uint Cn=mad_hi(MWC64X_A,X,carry); s->x=Xn; s->c=Cn; } void MWC64X_Skip(mwc64x_state_t *s, ulong distance) { uint2 tmp=MWC_SkipImpl_Mod64((uint2)(s->x,s->c), MWC64X_A, MWC64X_M, distance); s->x=tmp.x; s->c=tmp.y; } void MWC64X_SeedStreams(mwc64x_state_t *s, ulong baseOffset, ulong perStreamOffset) { uint2 tmp=MWC_SeedImpl_Mod64(MWC64X_A, MWC64X_M, 1, 0, baseOffset, perStreamOffset); s->x=tmp.x; s->c=tmp.y; } uint MWC64X_NextUint(mwc64x_state_t *s) { uint res=s->x ^ s->c; MWC64X_Step(s); return res; } typedef enum { UndefinedNoise, UniformNoise, GaussianNoise, MultiplicativeGaussianNoise, ImpulseNoise, LaplacianNoise, PoissonNoise, RandomNoise } NoiseType; float mwcReadPseudoRandomValue(mwc64x_state_t* rng) { return (1.0f * MWC64X_NextUint(rng)) / (float)(0xffffffff); } float mwcGenerateDifferentialNoise(mwc64x_state_t* r, CLQuantum pixel, NoiseType noise_type, float attenuate) { float alpha, beta, noise, sigma; noise = 0.0f; alpha=mwcReadPseudoRandomValue(r); switch(noise_type) { case UniformNoise: default: { noise=(pixel+QuantumRange*SigmaUniform*(alpha-0.5f)); break; } case GaussianNoise: { float gamma, tau; if (alpha == 0.0f) alpha=1.0f; beta=mwcReadPseudoRandomValue(r); gamma=sqrt(-2.0f*log(alpha)); sigma=gamma*cospi((2.0f*beta)); tau=gamma*sinpi((2.0f*beta)); noise=(float)(pixel+sqrt((float) pixel)*SigmaGaussian*sigma+ QuantumRange*TauGaussian*tau); break; } case ImpulseNoise: { if (alpha < (SigmaImpulse/2.0f)) noise=0.0f; else if (alpha >= (1.0f-(SigmaImpulse/2.0f))) noise=(float)QuantumRange; else noise=(float)pixel; break; } case LaplacianNoise: { if (alpha <= 0.5f) { if (alpha <= MagickEpsilon) noise=(float) (pixel-QuantumRange); else noise=(float) (pixel+QuantumRange*SigmaLaplacian*log(2.0f*alpha)+ 0.5f); break; } beta=1.0f-alpha; if (beta <= (0.5f*MagickEpsilon)) noise=(float) (pixel+QuantumRange); else noise=(float) (pixel-QuantumRange*SigmaLaplacian*log(2.0f*beta)+0.5f); break; } case MultiplicativeGaussianNoise: { sigma=1.0f; if (alpha > MagickEpsilon) sigma=sqrt(-2.0f*log(alpha)); beta=mwcReadPseudoRandomValue(r); noise=(float) (pixel+pixel*SigmaMultiplicativeGaussian*sigma* cospi((float) (2.0f*beta))/2.0f); break; } case PoissonNoise: { float poisson; unsigned int i; poisson=exp(-SigmaPoisson*QuantumScale*pixel); for (i=0; alpha > poisson; i++) { beta=mwcReadPseudoRandomValue(r); alpha*=beta; } noise=(float) (QuantumRange*i/SigmaPoisson); break; } case RandomNoise: { noise=(float) (QuantumRange*SigmaRandom*alpha); break; } }; return noise; } __kernel void GenerateNoiseImage(const __global CLPixelType* inputImage, __global CLPixelType* filteredImage ,const unsigned int inputPixelCount, const unsigned int pixelsPerWorkItem ,const ChannelType channel ,const NoiseType noise_type, const float attenuate ,const unsigned int seed0, const unsigned int seed1 ,const unsigned int numRandomNumbersPerPixel) { mwc64x_state_t rng; rng.x = seed0; rng.c = seed1; uint span = pixelsPerWorkItem * numRandomNumbersPerPixel; uint offset = span * get_local_size(0) * get_group_id(0); MWC64X_SeedStreams(&rng, offset, span); uint pos = get_local_size(0) * get_group_id(0) * pixelsPerWorkItem + get_local_id(0); uint count = pixelsPerWorkItem; while (count > 0) { if (pos < inputPixelCount) { CLPixelType p = inputImage[pos]; if ((channel&RedChannel)!=0) { setRed(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getRed(p),noise_type,attenuate))); } if ((channel&GreenChannel)!=0) { setGreen(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getGreen(p),noise_type,attenuate))); } if ((channel&BlueChannel)!=0) { setBlue(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getBlue(p),noise_type,attenuate))); } if ((channel & OpacityChannel) != 0) { setOpacity(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getOpacity(p),noise_type,attenuate))); } filteredImage[pos] = p; } pos += get_local_size(0); --count; } }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
<program source>:131:1460: warning: no previous prototype for function 'MWC64X_SeedStreams'
ulong MWC_AddMod64(ulong a, ulong b, ulong M) { ulong v=a+b; if( (v>=M) || (convert_float(v) < convert_float(a)) ) v=v-M; return v; } ulong MWC_MulMod64(ulong a, ulong b, ulong M) { ulong r=0; while(a!=0){ if(a&1) r=MWC_AddMod64(r,b,M); b=MWC_AddMod64(b,b,M); a=a>>1; } return r; } ulong MWC_PowMod64(ulong a, ulong e, ulong M) { ulong sqr=a, acc=1; while(e!=0){ if(e&1) acc=MWC_MulMod64(acc,sqr,M); sqr=MWC_MulMod64(sqr,sqr,M); e=e>>1; } return acc; } uint2 MWC_SkipImpl_Mod64(uint2 curr, ulong A, ulong M, ulong distance) { ulong m=MWC_PowMod64(A, distance, M); ulong x=curr.x*(ulong)A+curr.y; x=MWC_MulMod64(x, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } uint2 MWC_SeedImpl_Mod64(ulong A, ulong M, uint vecSize, uint vecOffset, ulong streamBase, ulong streamGap) { enum{ MWC_BASEID = 4077358422479273989UL }; ulong dist=streamBase + (get_global_id(0)*vecSize+vecOffset)*streamGap; ulong m=MWC_PowMod64(A, dist, M); ulong x=MWC_MulMod64(MWC_BASEID, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } typedef struct{ uint x; uint c; } mwc64x_state_t; enum{ MWC64X_A = 4294883355U }; enum{ MWC64X_M = 18446383549859758079UL }; void MWC64X_Step(mwc64x_state_t *s) { uint X=s->x, C=s->c; uint Xn=MWC64X_A*X+C; uint carry=(uint)(Xn<C); uint Cn=mad_hi(MWC64X_A,X,carry); s->x=Xn; s->c=Cn; } void MWC64X_Skip(mwc64x_state_t *s, ulong distance) { uint2 tmp=MWC_SkipImpl_Mod64((uint2)(s->x,s->c), MWC64X_A, MWC64X_M, distance); s->x=tmp.x; s->c=tmp.y; } void MWC64X_SeedStreams(mwc64x_state_t *s, ulong baseOffset, ulong perStreamOffset) { uint2 tmp=MWC_SeedImpl_Mod64(MWC64X_A, MWC64X_M, 1, 0, baseOffset, perStreamOffset); s->x=tmp.x; s->c=tmp.y; } uint MWC64X_NextUint(mwc64x_state_t *s) { uint res=s->x ^ s->c; MWC64X_Step(s); return res; } typedef enum { UndefinedNoise, UniformNoise, GaussianNoise, MultiplicativeGaussianNoise, ImpulseNoise, LaplacianNoise, PoissonNoise, RandomNoise } NoiseType; float mwcReadPseudoRandomValue(mwc64x_state_t* rng) { return (1.0f * MWC64X_NextUint(rng)) / (float)(0xffffffff); } float mwcGenerateDifferentialNoise(mwc64x_state_t* r, CLQuantum pixel, NoiseType noise_type, float attenuate) { float alpha, beta, noise, sigma; noise = 0.0f; alpha=mwcReadPseudoRandomValue(r); switch(noise_type) { case UniformNoise: default: { noise=(pixel+QuantumRange*SigmaUniform*(alpha-0.5f)); break; } case GaussianNoise: { float gamma, tau; if (alpha == 0.0f) alpha=1.0f; beta=mwcReadPseudoRandomValue(r); gamma=sqrt(-2.0f*log(alpha)); sigma=gamma*cospi((2.0f*beta)); tau=gamma*sinpi((2.0f*beta)); noise=(float)(pixel+sqrt((float) pixel)*SigmaGaussian*sigma+ QuantumRange*TauGaussian*tau); break; } case ImpulseNoise: { if (alpha < (SigmaImpulse/2.0f)) noise=0.0f; else if (alpha >= (1.0f-(SigmaImpulse/2.0f))) noise=(float)QuantumRange; else noise=(float)pixel; break; } case LaplacianNoise: { if (alpha <= 0.5f) { if (alpha <= MagickEpsilon) noise=(float) (pixel-QuantumRange); else noise=(float) (pixel+QuantumRange*SigmaLaplacian*log(2.0f*alpha)+ 0.5f); break; } beta=1.0f-alpha; if (beta <= (0.5f*MagickEpsilon)) noise=(float) (pixel+QuantumRange); else noise=(float) (pixel-QuantumRange*SigmaLaplacian*log(2.0f*beta)+0.5f); break; } case MultiplicativeGaussianNoise: { sigma=1.0f; if (alpha > MagickEpsilon) sigma=sqrt(-2.0f*log(alpha)); beta=mwcReadPseudoRandomValue(r); noise=(float) (pixel+pixel*SigmaMultiplicativeGaussian*sigma* cospi((float) (2.0f*beta))/2.0f); break; } case PoissonNoise: { float poisson; unsigned int i; poisson=exp(-SigmaPoisson*QuantumScale*pixel); for (i=0; alpha > poisson; i++) { beta=mwcReadPseudoRandomValue(r); alpha*=beta; } noise=(float) (QuantumRange*i/SigmaPoisson); break; } case RandomNoise: { noise=(float) (QuantumRange*SigmaRandom*alpha); break; } }; return noise; } __kernel void GenerateNoiseImage(const __global CLPixelType* inputImage, __global CLPixelType* filteredImage ,const unsigned int inputPixelCount, const unsigned int pixelsPerWorkItem ,const ChannelType channel ,const NoiseType noise_type, const float attenuate ,const unsigned int seed0, const unsigned int seed1 ,const unsigned int numRandomNumbersPerPixel) { mwc64x_state_t rng; rng.x = seed0; rng.c = seed1; uint span = pixelsPerWorkItem * numRandomNumbersPerPixel; uint offset = span * get_local_size(0) * get_group_id(0); MWC64X_SeedStreams(&rng, offset, span); uint pos = get_local_size(0) * get_group_id(0) * pixelsPerWorkItem + get_local_id(0); uint count = pixelsPerWorkItem; while (count > 0) { if (pos < inputPixelCount) { CLPixelType p = inputImage[pos]; if ((channel&RedChannel)!=0) { setRed(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getRed(p),noise_type,attenuate))); } if ((channel&GreenChannel)!=0) { setGreen(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getGreen(p),noise_type,attenuate))); } if ((channel&BlueChannel)!=0) { setBlue(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getBlue(p),noise_type,attenuate))); } if ((channel & OpacityChannel) != 0) { setOpacity(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getOpacity(p),noise_type,attenuate))); } filteredImage[pos] = p; } pos += get_local_size(0); --count; } }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
<program source>:131:1657: warning: no previous prototype for function 'MWC64X_NextUint'
ulong MWC_AddMod64(ulong a, ulong b, ulong M) { ulong v=a+b; if( (v>=M) || (convert_float(v) < convert_float(a)) ) v=v-M; return v; } ulong MWC_MulMod64(ulong a, ulong b, ulong M) { ulong r=0; while(a!=0){ if(a&1) r=MWC_AddMod64(r,b,M); b=MWC_AddMod64(b,b,M); a=a>>1; } return r; } ulong MWC_PowMod64(ulong a, ulong e, ulong M) { ulong sqr=a, acc=1; while(e!=0){ if(e&1) acc=MWC_MulMod64(acc,sqr,M); sqr=MWC_MulMod64(sqr,sqr,M); e=e>>1; } return acc; } uint2 MWC_SkipImpl_Mod64(uint2 curr, ulong A, ulong M, ulong distance) { ulong m=MWC_PowMod64(A, distance, M); ulong x=curr.x*(ulong)A+curr.y; x=MWC_MulMod64(x, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } uint2 MWC_SeedImpl_Mod64(ulong A, ulong M, uint vecSize, uint vecOffset, ulong streamBase, ulong streamGap) { enum{ MWC_BASEID = 4077358422479273989UL }; ulong dist=streamBase + (get_global_id(0)*vecSize+vecOffset)*streamGap; ulong m=MWC_PowMod64(A, dist, M); ulong x=MWC_MulMod64(MWC_BASEID, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } typedef struct{ uint x; uint c; } mwc64x_state_t; enum{ MWC64X_A = 4294883355U }; enum{ MWC64X_M = 18446383549859758079UL }; void MWC64X_Step(mwc64x_state_t *s) { uint X=s->x, C=s->c; uint Xn=MWC64X_A*X+C; uint carry=(uint)(Xn<C); uint Cn=mad_hi(MWC64X_A,X,carry); s->x=Xn; s->c=Cn; } void MWC64X_Skip(mwc64x_state_t *s, ulong distance) { uint2 tmp=MWC_SkipImpl_Mod64((uint2)(s->x,s->c), MWC64X_A, MWC64X_M, distance); s->x=tmp.x; s->c=tmp.y; } void MWC64X_SeedStreams(mwc64x_state_t *s, ulong baseOffset, ulong perStreamOffset) { uint2 tmp=MWC_SeedImpl_Mod64(MWC64X_A, MWC64X_M, 1, 0, baseOffset, perStreamOffset); s->x=tmp.x; s->c=tmp.y; } uint MWC64X_NextUint(mwc64x_state_t *s) { uint res=s->x ^ s->c; MWC64X_Step(s); return res; } typedef enum { UndefinedNoise, UniformNoise, GaussianNoise, MultiplicativeGaussianNoise, ImpulseNoise, LaplacianNoise, PoissonNoise, RandomNoise } NoiseType; float mwcReadPseudoRandomValue(mwc64x_state_t* rng) { return (1.0f * MWC64X_NextUint(rng)) / (float)(0xffffffff); } float mwcGenerateDifferentialNoise(mwc64x_state_t* r, CLQuantum pixel, NoiseType noise_type, float attenuate) { float alpha, beta, noise, sigma; noise = 0.0f; alpha=mwcReadPseudoRandomValue(r); switch(noise_type) { case UniformNoise: default: { noise=(pixel+QuantumRange*SigmaUniform*(alpha-0.5f)); break; } case GaussianNoise: { float gamma, tau; if (alpha == 0.0f) alpha=1.0f; beta=mwcReadPseudoRandomValue(r); gamma=sqrt(-2.0f*log(alpha)); sigma=gamma*cospi((2.0f*beta)); tau=gamma*sinpi((2.0f*beta)); noise=(float)(pixel+sqrt((float) pixel)*SigmaGaussian*sigma+ QuantumRange*TauGaussian*tau); break; } case ImpulseNoise: { if (alpha < (SigmaImpulse/2.0f)) noise=0.0f; else if (alpha >= (1.0f-(SigmaImpulse/2.0f))) noise=(float)QuantumRange; else noise=(float)pixel; break; } case LaplacianNoise: { if (alpha <= 0.5f) { if (alpha <= MagickEpsilon) noise=(float) (pixel-QuantumRange); else noise=(float) (pixel+QuantumRange*SigmaLaplacian*log(2.0f*alpha)+ 0.5f); break; } beta=1.0f-alpha; if (beta <= (0.5f*MagickEpsilon)) noise=(float) (pixel+QuantumRange); else noise=(float) (pixel-QuantumRange*SigmaLaplacian*log(2.0f*beta)+0.5f); break; } case MultiplicativeGaussianNoise: { sigma=1.0f; if (alpha > MagickEpsilon) sigma=sqrt(-2.0f*log(alpha)); beta=mwcReadPseudoRandomValue(r); noise=(float) (pixel+pixel*SigmaMultiplicativeGaussian*sigma* cospi((float) (2.0f*beta))/2.0f); break; } case PoissonNoise: { float poisson; unsigned int i; poisson=exp(-SigmaPoisson*QuantumScale*pixel); for (i=0; alpha > poisson; i++) { beta=mwcReadPseudoRandomValue(r); alpha*=beta; } noise=(float) (QuantumRange*i/SigmaPoisson); break; } case RandomNoise: { noise=(float) (QuantumRange*SigmaRandom*alpha); break; } }; return noise; } __kernel void GenerateNoiseImage(const __global CLPixelType* inputImage, __global CLPixelType* filteredImage ,const unsigned int inputPixelCount, const unsigned int pixelsPerWorkItem ,const ChannelType channel ,const NoiseType noise_type, const float attenuate ,const unsigned int seed0, const unsigned int seed1 ,const unsigned int numRandomNumbersPerPixel) { mwc64x_state_t rng; rng.x = seed0; rng.c = seed1; uint span = pixelsPerWorkItem * numRandomNumbersPerPixel; uint offset = span * get_local_size(0) * get_group_id(0); MWC64X_SeedStreams(&rng, offset, span); uint pos = get_local_size(0) * get_group_id(0) * pixelsPerWorkItem + get_local_id(0); uint count = pixelsPerWorkItem; while (count > 0) { if (pos < inputPixelCount) { CLPixelType p = inputImage[pos]; if ((channel&RedChannel)!=0) { setRed(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getRed(p),noise_type,attenuate))); } if ((channel&GreenChannel)!=0) { setGreen(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getGreen(p),noise_type,attenuate))); } if ((channel&BlueChannel)!=0) { setBlue(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getBlue(p),noise_type,attenuate))); } if ((channel & OpacityChannel) != 0) { setOpacity(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getOpacity(p),noise_type,attenuate))); } filteredImage[pos] = p; } pos += get_local_size(0); --count; } }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
<program source>:131:1910: warning: no previous prototype for function 'mwcReadPseudoRandomValue'
ulong MWC_AddMod64(ulong a, ulong b, ulong M) { ulong v=a+b; if( (v>=M) || (convert_float(v) < convert_float(a)) ) v=v-M; return v; } ulong MWC_MulMod64(ulong a, ulong b, ulong M) { ulong r=0; while(a!=0){ if(a&1) r=MWC_AddMod64(r,b,M); b=MWC_AddMod64(b,b,M); a=a>>1; } return r; } ulong MWC_PowMod64(ulong a, ulong e, ulong M) { ulong sqr=a, acc=1; while(e!=0){ if(e&1) acc=MWC_MulMod64(acc,sqr,M); sqr=MWC_MulMod64(sqr,sqr,M); e=e>>1; } return acc; } uint2 MWC_SkipImpl_Mod64(uint2 curr, ulong A, ulong M, ulong distance) { ulong m=MWC_PowMod64(A, distance, M); ulong x=curr.x*(ulong)A+curr.y; x=MWC_MulMod64(x, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } uint2 MWC_SeedImpl_Mod64(ulong A, ulong M, uint vecSize, uint vecOffset, ulong streamBase, ulong streamGap) { enum{ MWC_BASEID = 4077358422479273989UL }; ulong dist=streamBase + (get_global_id(0)*vecSize+vecOffset)*streamGap; ulong m=MWC_PowMod64(A, dist, M); ulong x=MWC_MulMod64(MWC_BASEID, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } typedef struct{ uint x; uint c; } mwc64x_state_t; enum{ MWC64X_A = 4294883355U }; enum{ MWC64X_M = 18446383549859758079UL }; void MWC64X_Step(mwc64x_state_t *s) { uint X=s->x, C=s->c; uint Xn=MWC64X_A*X+C; uint carry=(uint)(Xn<C); uint Cn=mad_hi(MWC64X_A,X,carry); s->x=Xn; s->c=Cn; } void MWC64X_Skip(mwc64x_state_t *s, ulong distance) { uint2 tmp=MWC_SkipImpl_Mod64((uint2)(s->x,s->c), MWC64X_A, MWC64X_M, distance); s->x=tmp.x; s->c=tmp.y; } void MWC64X_SeedStreams(mwc64x_state_t *s, ulong baseOffset, ulong perStreamOffset) { uint2 tmp=MWC_SeedImpl_Mod64(MWC64X_A, MWC64X_M, 1, 0, baseOffset, perStreamOffset); s->x=tmp.x; s->c=tmp.y; } uint MWC64X_NextUint(mwc64x_state_t *s) { uint res=s->x ^ s->c; MWC64X_Step(s); return res; } typedef enum { UndefinedNoise, UniformNoise, GaussianNoise, MultiplicativeGaussianNoise, ImpulseNoise, LaplacianNoise, PoissonNoise, RandomNoise } NoiseType; float mwcReadPseudoRandomValue(mwc64x_state_t* rng) { return (1.0f * MWC64X_NextUint(rng)) / (float)(0xffffffff); } float mwcGenerateDifferentialNoise(mwc64x_state_t* r, CLQuantum pixel, NoiseType noise_type, float attenuate) { float alpha, beta, noise, sigma; noise = 0.0f; alpha=mwcReadPseudoRandomValue(r); switch(noise_type) { case UniformNoise: default: { noise=(pixel+QuantumRange*SigmaUniform*(alpha-0.5f)); break; } case GaussianNoise: { float gamma, tau; if (alpha == 0.0f) alpha=1.0f; beta=mwcReadPseudoRandomValue(r); gamma=sqrt(-2.0f*log(alpha)); sigma=gamma*cospi((2.0f*beta)); tau=gamma*sinpi((2.0f*beta)); noise=(float)(pixel+sqrt((float) pixel)*SigmaGaussian*sigma+ QuantumRange*TauGaussian*tau); break; } case ImpulseNoise: { if (alpha < (SigmaImpulse/2.0f)) noise=0.0f; else if (alpha >= (1.0f-(SigmaImpulse/2.0f))) noise=(float)QuantumRange; else noise=(float)pixel; break; } case LaplacianNoise: { if (alpha <= 0.5f) { if (alpha <= MagickEpsilon) noise=(float) (pixel-QuantumRange); else noise=(float) (pixel+QuantumRange*SigmaLaplacian*log(2.0f*alpha)+ 0.5f); break; } beta=1.0f-alpha; if (beta <= (0.5f*MagickEpsilon)) noise=(float) (pixel+QuantumRange); else noise=(float) (pixel-QuantumRange*SigmaLaplacian*log(2.0f*beta)+0.5f); break; } case MultiplicativeGaussianNoise: { sigma=1.0f; if (alpha > MagickEpsilon) sigma=sqrt(-2.0f*log(alpha)); beta=mwcReadPseudoRandomValue(r); noise=(float) (pixel+pixel*SigmaMultiplicativeGaussian*sigma* cospi((float) (2.0f*beta))/2.0f); break; } case PoissonNoise: { float poisson; unsigned int i; poisson=exp(-SigmaPoisson*QuantumScale*pixel); for (i=0; alpha > poisson; i++) { beta=mwcReadPseudoRandomValue(r); alpha*=beta; } noise=(float) (QuantumRange*i/SigmaPoisson); break; } case RandomNoise: { noise=(float) (QuantumRange*SigmaRandom*alpha); break; } }; return noise; } __kernel void GenerateNoiseImage(const __global CLPixelType* inputImage, __global CLPixelType* filteredImage ,const unsigned int inputPixelCount, const unsigned int pixelsPerWorkItem ,const ChannelType channel ,const NoiseType noise_type, const float attenuate ,const unsigned int seed0, const unsigned int seed1 ,const unsigned int numRandomNumbersPerPixel) { mwc64x_state_t rng; rng.x = seed0; rng.c = seed1; uint span = pixelsPerWorkItem * numRandomNumbersPerPixel; uint offset = span * get_local_size(0) * get_group_id(0); MWC64X_SeedStreams(&rng, offset, span); uint pos = get_local_size(0) * get_group_id(0) * pixelsPerWorkItem + get_local_id(0); uint count = pixelsPerWorkItem; while (count > 0) { if (pos < inputPixelCount) { CLPixelType p = inputImage[pos]; if ((channel&RedChannel)!=0) { setRed(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getRed(p),noise_type,attenuate))); } if ((channel&GreenChannel)!=0) { setGreen(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getGreen(p),noise_type,attenuate))); } if ((channel&BlueChannel)!=0) { setBlue(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getBlue(p),noise_type,attenuate))); } if ((channel & OpacityChannel) != 0) { setOpacity(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getOpacity(p),noise_type,attenuate))); } filteredImage[pos] = p; } pos += get_local_size(0); --count; } }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
<program source>:131:2026: warning: no previous prototype for function 'mwcGenerateDifferentialNoise'
ulong MWC_AddMod64(ulong a, ulong b, ulong M) { ulong v=a+b; if( (v>=M) || (convert_float(v) < convert_float(a)) ) v=v-M; return v; } ulong MWC_MulMod64(ulong a, ulong b, ulong M) { ulong r=0; while(a!=0){ if(a&1) r=MWC_AddMod64(r,b,M); b=MWC_AddMod64(b,b,M); a=a>>1; } return r; } ulong MWC_PowMod64(ulong a, ulong e, ulong M) { ulong sqr=a, acc=1; while(e!=0){ if(e&1) acc=MWC_MulMod64(acc,sqr,M); sqr=MWC_MulMod64(sqr,sqr,M); e=e>>1; } return acc; } uint2 MWC_SkipImpl_Mod64(uint2 curr, ulong A, ulong M, ulong distance) { ulong m=MWC_PowMod64(A, distance, M); ulong x=curr.x*(ulong)A+curr.y; x=MWC_MulMod64(x, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } uint2 MWC_SeedImpl_Mod64(ulong A, ulong M, uint vecSize, uint vecOffset, ulong streamBase, ulong streamGap) { enum{ MWC_BASEID = 4077358422479273989UL }; ulong dist=streamBase + (get_global_id(0)*vecSize+vecOffset)*streamGap; ulong m=MWC_PowMod64(A, dist, M); ulong x=MWC_MulMod64(MWC_BASEID, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } typedef struct{ uint x; uint c; } mwc64x_state_t; enum{ MWC64X_A = 4294883355U }; enum{ MWC64X_M = 18446383549859758079UL }; void MWC64X_Step(mwc64x_state_t *s) { uint X=s->x, C=s->c; uint Xn=MWC64X_A*X+C; uint carry=(uint)(Xn<C); uint Cn=mad_hi(MWC64X_A,X,carry); s->x=Xn; s->c=Cn; } void MWC64X_Skip(mwc64x_state_t *s, ulong distance) { uint2 tmp=MWC_SkipImpl_Mod64((uint2)(s->x,s->c), MWC64X_A, MWC64X_M, distance); s->x=tmp.x; s->c=tmp.y; } void MWC64X_SeedStreams(mwc64x_state_t *s, ulong baseOffset, ulong perStreamOffset) { uint2 tmp=MWC_SeedImpl_Mod64(MWC64X_A, MWC64X_M, 1, 0, baseOffset, perStreamOffset); s->x=tmp.x; s->c=tmp.y; } uint MWC64X_NextUint(mwc64x_state_t *s) { uint res=s->x ^ s->c; MWC64X_Step(s); return res; } typedef enum { UndefinedNoise, UniformNoise, GaussianNoise, MultiplicativeGaussianNoise, ImpulseNoise, LaplacianNoise, PoissonNoise, RandomNoise } NoiseType; float mwcReadPseudoRandomValue(mwc64x_state_t* rng) { return (1.0f * MWC64X_NextUint(rng)) / (float)(0xffffffff); } float mwcGenerateDifferentialNoise(mwc64x_state_t* r, CLQuantum pixel, NoiseType noise_type, float attenuate) { float alpha, beta, noise, sigma; noise = 0.0f; alpha=mwcReadPseudoRandomValue(r); switch(noise_type) { case UniformNoise: default: { noise=(pixel+QuantumRange*SigmaUniform*(alpha-0.5f)); break; } case GaussianNoise: { float gamma, tau; if (alpha == 0.0f) alpha=1.0f; beta=mwcReadPseudoRandomValue(r); gamma=sqrt(-2.0f*log(alpha)); sigma=gamma*cospi((2.0f*beta)); tau=gamma*sinpi((2.0f*beta)); noise=(float)(pixel+sqrt((float) pixel)*SigmaGaussian*sigma+ QuantumRange*TauGaussian*tau); break; } case ImpulseNoise: { if (alpha < (SigmaImpulse/2.0f)) noise=0.0f; else if (alpha >= (1.0f-(SigmaImpulse/2.0f))) noise=(float)QuantumRange; else noise=(float)pixel; break; } case LaplacianNoise: { if (alpha <= 0.5f) { if (alpha <= MagickEpsilon) noise=(float) (pixel-QuantumRange); else noise=(float) (pixel+QuantumRange*SigmaLaplacian*log(2.0f*alpha)+ 0.5f); break; } beta=1.0f-alpha; if (beta <= (0.5f*MagickEpsilon)) noise=(float) (pixel+QuantumRange); else noise=(float) (pixel-QuantumRange*SigmaLaplacian*log(2.0f*beta)+0.5f); break; } case MultiplicativeGaussianNoise: { sigma=1.0f; if (alpha > MagickEpsilon) sigma=sqrt(-2.0f*log(alpha)); beta=mwcReadPseudoRandomValue(r); noise=(float) (pixel+pixel*SigmaMultiplicativeGaussian*sigma* cospi((float) (2.0f*beta))/2.0f); break; } case PoissonNoise: { float poisson; unsigned int i; poisson=exp(-SigmaPoisson*QuantumScale*pixel); for (i=0; alpha > poisson; i++) { beta=mwcReadPseudoRandomValue(r); alpha*=beta; } noise=(float) (QuantumRange*i/SigmaPoisson); break; } case RandomNoise: { noise=(float) (QuantumRange*SigmaRandom*alpha); break; } }; return noise; } __kernel void GenerateNoiseImage(const __global CLPixelType* inputImage, __global CLPixelType* filteredImage ,const unsigned int inputPixelCount, const unsigned int pixelsPerWorkItem ,const ChannelType channel ,const NoiseType noise_type, const float attenuate ,const unsigned int seed0, const unsigned int seed1 ,const unsigned int numRandomNumbersPerPixel) { mwc64x_state_t rng; rng.x = seed0; rng.c = seed1; uint span = pixelsPerWorkItem * numRandomNumbersPerPixel; uint offset = span * get_local_size(0) * get_group_id(0); MWC64X_SeedStreams(&rng, offset, span); uint pos = get_local_size(0) * get_group_id(0) * pixelsPerWorkItem + get_local_id(0); uint count = pixelsPerWorkItem; while (count > 0) { if (pos < inputPixelCount) { CLPixelType p = inputImage[pos]; if ((channel&RedChannel)!=0) { setRed(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getRed(p),noise_type,attenuate))); } if ((channel&GreenChannel)!=0) { setGreen(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getGreen(p),noise_type,attenuate))); } if ((channel&BlueChannel)!=0) { setBlue(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getBlue(p),noise_type,attenuate))); } if ((channel & OpacityChannel) != 0) { setOpacity(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getOpacity(p),noise_type,attenuate))); } filteredImage[pos] = p; } pos += get_local_size(0); --count; } }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
<program source>:131:3470: error: call to '__fast_relax_exp' is ambiguous
ulong MWC_AddMod64(ulong a, ulong b, ulong M) { ulong v=a+b; if( (v>=M) || (convert_float(v) < convert_float(a)) ) v=v-M; return v; } ulong MWC_MulMod64(ulong a, ulong b, ulong M) { ulong r=0; while(a!=0){ if(a&1) r=MWC_AddMod64(r,b,M); b=MWC_AddMod64(b,b,M); a=a>>1; } return r; } ulong MWC_PowMod64(ulong a, ulong e, ulong M) { ulong sqr=a, acc=1; while(e!=0){ if(e&1) acc=MWC_MulMod64(acc,sqr,M); sqr=MWC_MulMod64(sqr,sqr,M); e=e>>1; } return acc; } uint2 MWC_SkipImpl_Mod64(uint2 curr, ulong A, ulong M, ulong distance) { ulong m=MWC_PowMod64(A, distance, M); ulong x=curr.x*(ulong)A+curr.y; x=MWC_MulMod64(x, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } uint2 MWC_SeedImpl_Mod64(ulong A, ulong M, uint vecSize, uint vecOffset, ulong streamBase, ulong streamGap) { enum{ MWC_BASEID = 4077358422479273989UL }; ulong dist=streamBase + (get_global_id(0)*vecSize+vecOffset)*streamGap; ulong m=MWC_PowMod64(A, dist, M); ulong x=MWC_MulMod64(MWC_BASEID, m, M); return (uint2)((uint)(x/A), (uint)(x%A)); } typedef struct{ uint x; uint c; } mwc64x_state_t; enum{ MWC64X_A = 4294883355U }; enum{ MWC64X_M = 18446383549859758079UL }; void MWC64X_Step(mwc64x_state_t *s) { uint X=s->x, C=s->c; uint Xn=MWC64X_A*X+C; uint carry=(uint)(Xn<C); uint Cn=mad_hi(MWC64X_A,X,carry); s->x=Xn; s->c=Cn; } void MWC64X_Skip(mwc64x_state_t *s, ulong distance) { uint2 tmp=MWC_SkipImpl_Mod64((uint2)(s->x,s->c), MWC64X_A, MWC64X_M, distance); s->x=tmp.x; s->c=tmp.y; } void MWC64X_SeedStreams(mwc64x_state_t *s, ulong baseOffset, ulong perStreamOffset) { uint2 tmp=MWC_SeedImpl_Mod64(MWC64X_A, MWC64X_M, 1, 0, baseOffset, perStreamOffset); s->x=tmp.x; s->c=tmp.y; } uint MWC64X_NextUint(mwc64x_state_t *s) { uint res=s->x ^ s->c; MWC64X_Step(s); return res; } typedef enum { UndefinedNoise, UniformNoise, GaussianNoise, MultiplicativeGaussianNoise, ImpulseNoise, LaplacianNoise, PoissonNoise, RandomNoise } NoiseType; float mwcReadPseudoRandomValue(mwc64x_state_t* rng) { return (1.0f * MWC64X_NextUint(rng)) / (float)(0xffffffff); } float mwcGenerateDifferentialNoise(mwc64x_state_t* r, CLQuantum pixel, NoiseType noise_type, float attenuate) { float alpha, beta, noise, sigma; noise = 0.0f; alpha=mwcReadPseudoRandomValue(r); switch(noise_type) { case UniformNoise: default: { noise=(pixel+QuantumRange*SigmaUniform*(alpha-0.5f)); break; } case GaussianNoise: { float gamma, tau; if (alpha == 0.0f) alpha=1.0f; beta=mwcReadPseudoRandomValue(r); gamma=sqrt(-2.0f*log(alpha)); sigma=gamma*cospi((2.0f*beta)); tau=gamma*sinpi((2.0f*beta)); noise=(float)(pixel+sqrt((float) pixel)*SigmaGaussian*sigma+ QuantumRange*TauGaussian*tau); break; } case ImpulseNoise: { if (alpha < (SigmaImpulse/2.0f)) noise=0.0f; else if (alpha >= (1.0f-(SigmaImpulse/2.0f))) noise=(float)QuantumRange; else noise=(float)pixel; break; } case LaplacianNoise: { if (alpha <= 0.5f) { if (alpha <= MagickEpsilon) noise=(float) (pixel-QuantumRange); else noise=(float) (pixel+QuantumRange*SigmaLaplacian*log(2.0f*alpha)+ 0.5f); break; } beta=1.0f-alpha; if (beta <= (0.5f*MagickEpsilon)) noise=(float) (pixel+QuantumRange); else noise=(float) (pixel-QuantumRange*SigmaLaplacian*log(2.0f*beta)+0.5f); break; } case MultiplicativeGaussianNoise: { sigma=1.0f; if (alpha > MagickEpsilon) sigma=sqrt(-2.0f*log(alpha)); beta=mwcReadPseudoRandomValue(r); noise=(float) (pixel+pixel*SigmaMultiplicativeGaussian*sigma* cospi((float) (2.0f*beta))/2.0f); break; } case PoissonNoise: { float poisson; unsigned int i; poisson=exp(-SigmaPoisson*QuantumScale*pixel); for (i=0; alpha > poisson; i++) { beta=mwcReadPseudoRandomValue(r); alpha*=beta; } noise=(float) (QuantumRange*i/SigmaPoisson); break; } case RandomNoise: { noise=(float) (QuantumRange*SigmaRandom*alpha); break; } }; return noise; } __kernel void GenerateNoiseImage(const __global CLPixelType* inputImage, __global CLPixelType* filteredImage ,const unsigned int inputPixelCount, const unsigned int pixelsPerWorkItem ,const ChannelType channel ,const NoiseType noise_type, const float attenuate ,const unsigned int seed0, const unsigned int seed1 ,const unsigned int numRandomNumbersPerPixel) { mwc64x_state_t rng; rng.x = seed0; rng.c = seed1; uint span = pixelsPerWorkItem * numRandomNumbersPerPixel; uint offset = span * get_local_size(0) * get_group_id(0); MWC64X_SeedStreams(&rng, offset, span); uint pos = get_local_size(0) * get_group_id(0) * pixelsPerWorkItem + get_local_id(0); uint count = pixelsPerWorkItem; while (count > 0) { if (pos < inputPixelCount) { CLPixelType p = inputImage[pos]; if ((channel&RedChannel)!=0) { setRed(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getRed(p),noise_type,attenuate))); } if ((channel&GreenChannel)!=0) { setGreen(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getGreen(p),noise_type,attenuate))); } if ((channel&BlueChannel)!=0) { setBlue(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getBlue(p),noise_type,attenuate))); } if ((channel & OpacityChannel) != 0) { setOpacity(&p,ClampToQuantum(mwcGenerateDifferentialNoise(&rng,getOpacity(p),noise_type,attenuate))); } filteredImage[pos] = p; } pos += get_local_size(0); --count; } }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4496:22: note: expanded from macro 'exp'
    #define exp(__x) __fast_relax_exp(__x)
                     ^~~~~~~~~~~~~~~~
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4494:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_exp, native_exp, __cl_exp);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:416:27: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float __OVERLOAD__ _name(float x) { return _default_name(x); } \
                          ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4494:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_exp, native_exp, __cl_exp);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:417:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float2 __OVERLOAD__ _name(float2 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4494:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_exp, native_exp, __cl_exp);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:418:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float3 __OVERLOAD__ _name(float3 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4494:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_exp, native_exp, __cl_exp);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:419:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float4 __OVERLOAD__ _name(float4 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4494:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_exp, native_exp, __cl_exp);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:420:28: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float8 __OVERLOAD__ _name(float8 x) { return _default_name(x); } \
                           ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:4494:30: note: candidate function
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_exp, native_exp, __cl_exp);
                             ^
/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include/cl_kernel.h:421:29: note: expanded from macro '__CLFN_FD_1FD_FAST_RELAX'
inline float16 __OVERLOAD__ _name(float16 x){ return _default_name(x); }
                            ^
<program source>:132:421: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void MotionBlur(const __global CLPixelType *input, __global CLPixelType *output, const unsigned int imageWidth, const unsigned int imageHeight, const __global float *filter, const unsigned int width, const __global int2* offset, const float4 bias, const ChannelType channel, const unsigned int matte) { int2 currentPixel; currentPixel.x = get_global_id(0); currentPixel.y = get_global_id(1); if (currentPixel.x >= imageWidth || currentPixel.y >= imageHeight) return; float4 pixel; pixel.x = (float)bias.x; pixel.y = (float)bias.y; pixel.z = (float)bias.z; pixel.w = (float)bias.w; if (((channel & OpacityChannel) == 0) || (matte == 0)) { for (int i = 0; i < width; i++) { int2 samplePixel = currentPixel + offset[i]; samplePixel.x = ClampToCanvas(samplePixel.x, imageWidth); samplePixel.y = ClampToCanvas(samplePixel.y, imageHeight); CLPixelType samplePixelValue = input[ samplePixel.y * imageWidth + samplePixel.x]; pixel.x += (filter[i] * (float)samplePixelValue.x); pixel.y += (filter[i] * (float)samplePixelValue.y); pixel.z += (filter[i] * (float)samplePixelValue.z); pixel.w += (filter[i] * (float)samplePixelValue.w); } CLPixelType outputPixel; outputPixel.x = ClampToQuantum(pixel.x); outputPixel.y = ClampToQuantum(pixel.y); outputPixel.z = ClampToQuantum(pixel.z); outputPixel.w = ClampToQuantum(pixel.w); output[currentPixel.y * imageWidth + currentPixel.x] = outputPixel; } else { float gamma = 0.0f; for (int i = 0; i < width; i++) { int2 samplePixel = currentPixel + offset[i]; samplePixel.x = ClampToCanvas(samplePixel.x, imageWidth); samplePixel.y = ClampToCanvas(samplePixel.y, imageHeight); CLPixelType samplePixelValue = input[ samplePixel.y * imageWidth + samplePixel.x]; float alpha = QuantumScale*(QuantumRange-samplePixelValue.w); float k = filter[i]; pixel.x = pixel.x + k * alpha * samplePixelValue.x; pixel.y = pixel.y + k * alpha * samplePixelValue.y; pixel.z = pixel.z + k * alpha * samplePixelValue.z; pixel.w += k * alpha * samplePixelValue.w; gamma+=k*alpha; } gamma = PerceptibleReciprocal(gamma); pixel.xyz = gamma*pixel.xyz; CLPixelType outputPixel; outputPixel.x = ClampToQuantum(pixel.x); outputPixel.y = ClampToQuantum(pixel.y); outputPixel.z = ClampToQuantum(pixel.z); outputPixel.w = ClampToQuantum(pixel.w); output[currentPixel.y * imageWidth + currentPixel.x] = outputPixel; } }
                                                                                                                                                                                                                                                                                                                                                                                                                     ~~~~~~~~~~~~~~ ^  ~~~~~~~~~~
<program source>:132:453: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void MotionBlur(const __global CLPixelType *input, __global CLPixelType *output, const unsigned int imageWidth, const unsigned int imageHeight, const __global float *filter, const unsigned int width, const __global int2* offset, const float4 bias, const ChannelType channel, const unsigned int matte) { int2 currentPixel; currentPixel.x = get_global_id(0); currentPixel.y = get_global_id(1); if (currentPixel.x >= imageWidth || currentPixel.y >= imageHeight) return; float4 pixel; pixel.x = (float)bias.x; pixel.y = (float)bias.y; pixel.z = (float)bias.z; pixel.w = (float)bias.w; if (((channel & OpacityChannel) == 0) || (matte == 0)) { for (int i = 0; i < width; i++) { int2 samplePixel = currentPixel + offset[i]; samplePixel.x = ClampToCanvas(samplePixel.x, imageWidth); samplePixel.y = ClampToCanvas(samplePixel.y, imageHeight); CLPixelType samplePixelValue = input[ samplePixel.y * imageWidth + samplePixel.x]; pixel.x += (filter[i] * (float)samplePixelValue.x); pixel.y += (filter[i] * (float)samplePixelValue.y); pixel.z += (filter[i] * (float)samplePixelValue.z); pixel.w += (filter[i] * (float)samplePixelValue.w); } CLPixelType outputPixel; outputPixel.x = ClampToQuantum(pixel.x); outputPixel.y = ClampToQuantum(pixel.y); outputPixel.z = ClampToQuantum(pixel.z); outputPixel.w = ClampToQuantum(pixel.w); output[currentPixel.y * imageWidth + currentPixel.x] = outputPixel; } else { float gamma = 0.0f; for (int i = 0; i < width; i++) { int2 samplePixel = currentPixel + offset[i]; samplePixel.x = ClampToCanvas(samplePixel.x, imageWidth); samplePixel.y = ClampToCanvas(samplePixel.y, imageHeight); CLPixelType samplePixelValue = input[ samplePixel.y * imageWidth + samplePixel.x]; float alpha = QuantumScale*(QuantumRange-samplePixelValue.w); float k = filter[i]; pixel.x = pixel.x + k * alpha * samplePixelValue.x; pixel.y = pixel.y + k * alpha * samplePixelValue.y; pixel.z = pixel.z + k * alpha * samplePixelValue.z; pixel.w += k * alpha * samplePixelValue.w; gamma+=k*alpha; } gamma = PerceptibleReciprocal(gamma); pixel.xyz = gamma*pixel.xyz; CLPixelType outputPixel; outputPixel.x = ClampToQuantum(pixel.x); outputPixel.y = ClampToQuantum(pixel.y); outputPixel.z = ClampToQuantum(pixel.z); outputPixel.w = ClampToQuantum(pixel.w); output[currentPixel.y * imageWidth + currentPixel.x] = outputPixel; } }
                                                                                                                                                                                                                                                                                                                                                                                                                                                     ~~~~~~~~~~~~~~ ^  ~~~~~~~~~~~
<program source>:132:666: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void MotionBlur(const __global CLPixelType *input, __global CLPixelType *output, const unsigned int imageWidth, const unsigned int imageHeight, const __global float *filter, const unsigned int width, const __global int2* offset, const float4 bias, const ChannelType channel, const unsigned int matte) { int2 currentPixel; currentPixel.x = get_global_id(0); currentPixel.y = get_global_id(1); if (currentPixel.x >= imageWidth || currentPixel.y >= imageHeight) return; float4 pixel; pixel.x = (float)bias.x; pixel.y = (float)bias.y; pixel.z = (float)bias.z; pixel.w = (float)bias.w; if (((channel & OpacityChannel) == 0) || (matte == 0)) { for (int i = 0; i < width; i++) { int2 samplePixel = currentPixel + offset[i]; samplePixel.x = ClampToCanvas(samplePixel.x, imageWidth); samplePixel.y = ClampToCanvas(samplePixel.y, imageHeight); CLPixelType samplePixelValue = input[ samplePixel.y * imageWidth + samplePixel.x]; pixel.x += (filter[i] * (float)samplePixelValue.x); pixel.y += (filter[i] * (float)samplePixelValue.y); pixel.z += (filter[i] * (float)samplePixelValue.z); pixel.w += (filter[i] * (float)samplePixelValue.w); } CLPixelType outputPixel; outputPixel.x = ClampToQuantum(pixel.x); outputPixel.y = ClampToQuantum(pixel.y); outputPixel.z = ClampToQuantum(pixel.z); outputPixel.w = ClampToQuantum(pixel.w); output[currentPixel.y * imageWidth + currentPixel.x] = outputPixel; } else { float gamma = 0.0f; for (int i = 0; i < width; i++) { int2 samplePixel = currentPixel + offset[i]; samplePixel.x = ClampToCanvas(samplePixel.x, imageWidth); samplePixel.y = ClampToCanvas(samplePixel.y, imageHeight); CLPixelType samplePixelValue = input[ samplePixel.y * imageWidth + samplePixel.x]; float alpha = QuantumScale*(QuantumRange-samplePixelValue.w); float k = filter[i]; pixel.x = pixel.x + k * alpha * samplePixelValue.x; pixel.y = pixel.y + k * alpha * samplePixelValue.y; pixel.z = pixel.z + k * alpha * samplePixelValue.z; pixel.w += k * alpha * samplePixelValue.w; gamma+=k*alpha; } gamma = PerceptibleReciprocal(gamma); pixel.xyz = gamma*pixel.xyz; CLPixelType outputPixel; outputPixel.x = ClampToQuantum(pixel.x); outputPixel.y = ClampToQuantum(pixel.y); outputPixel.z = ClampToQuantum(pixel.z); outputPixel.w = ClampToQuantum(pixel.w); output[currentPixel.y * imageWidth + currentPixel.x] = outputPixel; } }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ~ ^ ~~~~~
<program source>:132:1441: warning: comparison of integers of different signs: 'int' and 'const unsigned int'
__kernel void MotionBlur(const __global CLPixelType *input, __global CLPixelType *output, const unsigned int imageWidth, const unsigned int imageHeight, const __global float *filter, const unsigned int width, const __global int2* offset, const float4 bias, const ChannelType channel, const unsigned int matte) { int2 currentPixel; currentPixel.x = get_global_id(0); currentPixel.y = get_global_id(1); if (currentPixel.x >= imageWidth || currentPixel.y >= imageHeight) return; float4 pixel; pixel.x = (float)bias.x; pixel.y = (float)bias.y; pixel.z = (float)bias.z; pixel.w = (float)bias.w; if (((channel & OpacityChannel) == 0) || (matte == 0)) { for (int i = 0; i < width; i++) { int2 samplePixel = currentPixel + offset[i]; samplePixel.x = ClampToCanvas(samplePixel.x, imageWidth); samplePixel.y = ClampToCanvas(samplePixel.y, imageHeight); CLPixelType samplePixelValue = input[ samplePixel.y * imageWidth + samplePixel.x]; pixel.x += (filter[i] * (float)samplePixelValue.x); pixel.y += (filter[i] * (float)samplePixelValue.y); pixel.z += (filter[i] * (float)samplePixelValue.z); pixel.w += (filter[i] * (float)samplePixelValue.w); } CLPixelType outputPixel; outputPixel.x = ClampToQuantum(pixel.x); outputPixel.y = ClampToQuantum(pixel.y); outputPixel.z = ClampToQuantum(pixel.z); outputPixel.w = ClampToQuantum(pixel.w); output[currentPixel.y * imageWidth + currentPixel.x] = outputPixel; } else { float gamma = 0.0f; for (int i = 0; i < width; i++) { int2 samplePixel = currentPixel + offset[i]; samplePixel.x = ClampToCanvas(samplePixel.x, imageWidth); samplePixel.y = ClampToCanvas(samplePixel.y, imageHeight); CLPixelType samplePixelValue = input[ samplePixel.y * imageWidth + samplePixel.x]; float alpha = QuantumScale*(QuantumRange-samplePixelValue.w); float k = filter[i]; pixel.x = pixel.x + k * alpha * samplePixelValue.x; pixel.y = pixel.y + k * alpha * samplePixelValue.y; pixel.z = pixel.z + k * alpha * samplePixelValue.z; pixel.w += k * alpha * samplePixelValue.w; gamma+=k*alpha; } gamma = PerceptibleReciprocal(gamma); pixel.xyz = gamma*pixel.xyz; CLPixelType outputPixel; outputPixel.x = ClampToQuantum(pixel.x); outputPixel.y = ClampToQuantum(pixel.y); outputPixel.z = ClampToQuantum(pixel.z); outputPixel.w = ClampToQuantum(pixel.w); output[currentPixel.y * imageWidth + currentPixel.x] = outputPixel; } }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ~ ^ ~~~~~
 